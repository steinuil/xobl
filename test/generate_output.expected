type xid = int
type file_descr = int
type ('flags, 'vals) mask = F of 'flags | V of 'vals
type 't alt_enum = E of 't | Custom of int
let (let*) = Option.bind

let identity x = x

let char_to_int64 c = Char.code c |> Int64.of_int

let bool_to_int64 b = Bool.to_int b |> Int64.of_int

let bool_of_int b = if b then 1 else 0

let decode f buf ~at ~size =
  if Bytes.length buf < at + size - 1 then None else Some (f buf at, at + size)

let decode_char buf ~at = decode Bytes.get buf ~at ~size:1

let decode_uint8 buf ~at = decode Bytes.get_uint8 buf ~at ~size:1

let decode_int8 buf ~at = decode Bytes.get_int8 buf ~at ~size:1

let decode_bool buf ~at =
  decode_uint8 buf ~at |> Option.map (fun (n, at) -> (n <> 0, at))

let decode_uint16 buf ~at = decode Bytes.get_uint16_le buf ~at ~size:2

let decode_int16 buf ~at = decode Bytes.get_int16_le buf ~at ~size:2

let decode_int32 buf ~at = decode Bytes.get_int32_le buf ~at ~size:4 |> Option.map (fun (n, at) -> (Int32.to_int n, at))

let decode_int64 buf ~at = decode Bytes.get_int64_le buf ~at ~size:8

let decode_float buf ~at =
  decode_int64 buf ~at
  |> Option.map (fun (n, at) -> (Int64.float_of_bits n, at))

let decode_file_descr buf ~at =
  decode Bytes.get_int16_le buf ~at ~size:2
  |> Option.map (fun (n, at) -> ((Obj.magic n : Unix.file_descr), at))

let decode_xid = decode_int16

let decode_enum decode to_int of_int buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int (to_int n) with
    | None -> None
    | Some e -> Some (e, at)

let decode_alt_enum decode to_int of_int buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    let n = to_int n in
    match of_int n with
    | Some e -> Some (E e, at)
    | None -> Some (Custom n, at)

let decode_list decode_item len buf ~at =
  let rec loop items at len =
    if len = 0 then Some ((List.rev items), at)
    else
      match decode_item buf ~at with
      | None -> None
      | Some (item, at) ->
        loop (item :: items) at (len - 1)
  in
  loop [] at len

let mask_of_int of_bit mask =
  let rec iter mask pos acc =
    if mask = 0L then Some acc
    else if Int64.logand mask 1L <> 0L then
      match of_bit pos with
      | Some item -> iter Int64.(shift_right mask 1) Int64.(pos + 1) (item :: acc)
      | None -> None
    else iter Int64.(shift_right mask 1) Int64.(pos + 1) acc
  in
  iter mask 0 []

let mask_value_of_int of_bit of_value mask =
  match of_value mask with
  | Some v -> Some (V v)
  | None ->
    match mask_of_int of_bit mask with
    | Some f -> Some (F f)
    | None -> None

let decode_mask decode to_int64 of_int64 buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int64 (to_int64 n) with
    | None -> None
    | Some e -> Some (e, at)

let decode_alt_mask decode to_int64 of_int64 buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int64 (to_int64 n) with
    | Some e -> Some (F e, at)
    | None -> Some (V n, at)

let encode f buf v ~at ~size =
  if Bytes.length buf < at + size then None else (
    f buf at v;
    Some (at + size)
  )

let encode_char buf v ~at = encode Bytes.set buf  v ~at ~size:1

let encode_uint8 buf v ~at = encode Bytes.set_uint8 buf v ~at ~size:1

let encode_int8 buf v ~at = encode Bytes.set_int8 buf v ~at ~size:1

let encode_bool buf v ~at = encode_uint8 buf (if v then 1 else 0) ~at

let encode_uint16 buf v ~at = encode Bytes.set_uint16_le buf v ~at ~size:2

let encode_int16 buf v ~at = encode Bytes.set_int16_le buf v ~at ~size:2

let encode_int32 buf v ~at = encode Bytes.set_int32_le buf (Int32.of_int v) ~at ~size:4

let encode_int64 buf v ~at = encode Bytes.set_int64_le buf v ~at ~size:8

let encode_float buf v ~at =
  encode_int64 buf (Int64.bits_of_float v) ~at

let encode_file_descr buf (v : Unix.file_descr) ~at =
  encode_int16 buf (Obj.magic v) ~at

let encode_xid = encode_int16

let encode_list encode_item buf ls ~at =
  let rec loop at = function
    | [] -> Some at
    | item :: rest -> (
      match encode_item buf item ~at with
      | Some at -> loop at rest
      | None -> None )
  in
  loop at ls

let encode_enum decode to_int of_int buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int (to_int n) with
    | None -> None
    | Some e -> Some (e, at)

let encode_enum encode of_int to_int buf v ~at =
  let v = to_int v in
  encode buf (of_int v) ~at

let encode_mask encode of_int to_int buf v ~at =
  let v = to_int v in
  encode buf (of_int v) ~at

let int_of_mask to_bit mask =
  List.fold_left (fun mask v -> mask lor (to_bit v)) 0 mask

let mask_value_to_int to_mask to_enum = function
  | F f -> int_of_mask to_mask f
  | V v -> to_enum v

let encode_alt_enum encode of_int to_int buf v ~at =
  match v with
  | E v -> encode_enum encode of_int to_int buf v ~at
  | Custom v -> encode buf v ~at

open Sexplib.Conv

type char2b = { byte1 : int; byte2 : int; } [@@deriving sexp];;
let decode_char2b buf ~at : (char2b * int) option = let orig = at in let* byte1, at = decode_uint8 buf ~at in
let* byte2, at = decode_uint8 buf ~at in
ignore orig;
Some ({ byte1; byte2 }, at);;
let encode_char2b buf (v : char2b) ~at : int option = let orig = at in let* at = encode_uint8 buf v.byte1 ~at in let* at = encode_uint8 buf v.byte2 ~at in ignore orig; Some at;;

type window = xid [@@deriving sexp];;
let decode_window = decode_xid;;
let encode_window = encode_xid;;

type pixmap = xid [@@deriving sexp];;
let decode_pixmap = decode_xid;;
let encode_pixmap = encode_xid;;

type cursor = xid [@@deriving sexp];;
let decode_cursor = decode_xid;;
let encode_cursor = encode_xid;;

type font = xid [@@deriving sexp];;
let decode_font = decode_xid;;
let encode_font = encode_xid;;

type gcontext = xid [@@deriving sexp];;
let decode_gcontext = decode_xid;;
let encode_gcontext = encode_xid;;

type colormap = xid [@@deriving sexp];;
let decode_colormap = decode_xid;;
let encode_colormap = encode_xid;;

type atom = xid [@@deriving sexp];;
let decode_atom = decode_xid;;
let encode_atom = encode_xid;;

type drawable = xid [@@deriving sexp];;
let decode_drawable = decode_xid;;
let encode_drawable = encode_xid;;

type fontable = xid [@@deriving sexp];;
let decode_fontable = decode_xid;;
let encode_fontable = encode_xid;;

type bool32 = int [@@deriving sexp];;
let decode_bool32 = decode_int32;;
let encode_bool32 = encode_int32;;

type visualid = int [@@deriving sexp];;
let decode_visualid = decode_int32;;
let encode_visualid = encode_int32;;

type timestamp = int [@@deriving sexp];;
let decode_timestamp = decode_int32;;
let encode_timestamp = encode_int32;;

type keysym = int [@@deriving sexp];;
let decode_keysym = decode_int32;;
let encode_keysym = encode_int32;;

type keycode = int [@@deriving sexp];;
let decode_keycode = decode_uint8;;
let encode_keycode = encode_uint8;;

type keycode32 = int [@@deriving sexp];;
let decode_keycode32 = decode_int32;;
let encode_keycode32 = encode_int32;;

type button = int [@@deriving sexp];;
let decode_button = decode_uint8;;
let encode_button = encode_uint8;;

type point = { x : int; y : int; } [@@deriving sexp];;
let decode_point buf ~at : (point * int) option = let orig = at in let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
ignore orig;
Some ({ x; y }, at);;
let encode_point buf (v : point) ~at : int option = let orig = at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in ignore orig; Some at;;

type rectangle = { x : int; y : int; width : int; height : int; } [@@deriving sexp];;
let decode_rectangle buf ~at : (rectangle * int) option = let orig = at in let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ x; y; width; height }, at);;
let encode_rectangle buf (v : rectangle) ~at : int option = let orig = at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in ignore orig; Some at;;

type arc = { x : int; y : int; width : int; height : int; angle1 : int; angle2 : int; } [@@deriving sexp];;
let decode_arc buf ~at : (arc * int) option = let orig = at in let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* angle1, at = decode_int16 buf ~at in
let* angle2, at = decode_int16 buf ~at in
ignore orig;
Some ({ x; y; width; height; angle1; angle2 }, at);;
let encode_arc buf (v : arc) ~at : int option = let orig = at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_int16 buf v.angle1 ~at in let* at = encode_int16 buf v.angle2 ~at in ignore orig; Some at;;

type format = { depth : int; bits_per_pixel : int; scanline_pad : int; } [@@deriving sexp];;
let decode_format buf ~at : (format * int) option = let orig = at in let* depth, at = decode_uint8 buf ~at in
let* bits_per_pixel, at = decode_uint8 buf ~at in
let* scanline_pad, at = decode_uint8 buf ~at in
let at = at + 5 in
ignore orig;
Some ({ depth; bits_per_pixel; scanline_pad }, at);;
let encode_format buf (v : format) ~at : int option = let orig = at in let* at = encode_uint8 buf v.depth ~at in let* at = encode_uint8 buf v.bits_per_pixel ~at in let* at = encode_uint8 buf v.scanline_pad ~at in let at = at + 5 in ignore orig; Some at;;

type visual_class_enum = [ `Static_gray | `Gray_scale | `Static_color | `Pseudo_color | `True_color | `Direct_color ] [@@deriving sexp];;
let visual_class_enum_of_int : int -> [> visual_class_enum ] option = function 0 -> Some `Static_gray | 1 -> Some `Gray_scale | 2 -> Some `Static_color | 3 -> Some `Pseudo_color | 4 -> Some `True_color | 5 -> Some `Direct_color | n -> Printf.printf "unknown visual_class_enum: %d\n" n; None;;
let visual_class_int_of_enum : visual_class_enum -> int = function `Static_gray -> 0 | `Gray_scale -> 1 | `Static_color -> 2 | `Pseudo_color -> 3 | `True_color -> 4 | `Direct_color -> 5;;
type visualtype = { visual_id : visualid; class_ : visual_class_enum; bits_per_rgb_value : int; colormap_entries : int; red_mask : int; green_mask : int; blue_mask : int; } [@@deriving sexp];;
let decode_visualtype buf ~at : (visualtype * int) option = let orig = at in let* visual_id, at = decode_visualid buf ~at in
let* class_, at = decode_enum decode_uint8 identity visual_class_enum_of_int buf ~at in
let* bits_per_rgb_value, at = decode_uint8 buf ~at in
let* colormap_entries, at = decode_uint16 buf ~at in
let* red_mask, at = decode_int32 buf ~at in
let* green_mask, at = decode_int32 buf ~at in
let* blue_mask, at = decode_int32 buf ~at in
let at = at + 4 in
ignore orig;
Some ({ visual_id; class_; bits_per_rgb_value; colormap_entries; red_mask; green_mask; blue_mask }, at);;
let encode_visualtype buf (v : visualtype) ~at : int option = let orig = at in let* at = encode_visualid buf v.visual_id ~at in let* at = encode_enum encode_uint8 identity visual_class_int_of_enum buf v.class_ ~at in let* at = encode_uint8 buf v.bits_per_rgb_value ~at in let* at = encode_uint16 buf v.colormap_entries ~at in let* at = encode_int32 buf v.red_mask ~at in let* at = encode_int32 buf v.green_mask ~at in let* at = encode_int32 buf v.blue_mask ~at in let at = at + 4 in ignore orig; Some at;;

type depth = { depth : int; visuals : visualtype list; } [@@deriving sexp];;
let decode_depth buf ~at : (depth * int) option = let orig = at in let* depth, at = decode_uint8 buf ~at in
let at = at + 1 in
let* visuals_len, at = decode_uint16 buf ~at in let visuals_len = visuals_len in
let at = at + 4 in
let* visuals, at = decode_list (decode_visualtype) visuals_len buf ~at in
ignore orig;
Some ({ depth; visuals }, at);;
let encode_depth buf (v : depth) ~at : int option = let orig = at in let* at = encode_uint8 buf v.depth ~at in let at = at + 1 in let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length v.visuals)) ~at in let at = at + 4 in let* at = encode_list encode_visualtype buf v.visuals ~at in ignore orig; Some at;;

type event_mask = ([ `Key_press | `Key_release | `Button_press | `Button_release | `Enter_window | `Leave_window | `Pointer_motion | `Pointer_motion_hint | `Button1_motion | `Button2_motion | `Button3_motion | `Button4_motion | `Button5_motion | `Button_motion | `Keymap_state | `Exposure | `Visibility_change | `Structure_notify | `Resize_redirect | `Substructure_notify | `Substructure_redirect | `Focus_change | `Property_change | `Color_map_change | `Owner_grab_button ] list, [ `No_event ]) mask [@@deriving sexp];;let event_mask_mask_of_int64 mask : event_mask option = let of_enum = function 0L -> Some `No_event | _ -> None in let of_mask = function 0 -> Some `Key_press | 1 -> Some `Key_release | 2 -> Some `Button_press | 3 -> Some `Button_release | 4 -> Some `Enter_window | 5 -> Some `Leave_window | 6 -> Some `Pointer_motion | 7 -> Some `Pointer_motion_hint | 8 -> Some `Button1_motion | 9 -> Some `Button2_motion | 10 -> Some `Button3_motion | 11 -> Some `Button4_motion | 12 -> Some `Button5_motion | 13 -> Some `Button_motion | 14 -> Some `Keymap_state | 15 -> Some `Exposure | 16 -> Some `Visibility_change | 17 -> Some `Structure_notify | 18 -> Some `Resize_redirect | 19 -> Some `Substructure_notify | 20 -> Some `Substructure_redirect | 21 -> Some `Focus_change | 22 -> Some `Property_change | 23 -> Some `Color_map_change | 24 -> Some `Owner_grab_button | _ -> None in mask_value_of_int of_mask of_enum mask;;
let event_mask_int_of_mask (mask : event_mask) : int = let to_enum = function `No_event -> 0 in let to_mask = function `Key_press -> 0 | `Key_release -> 1 | `Button_press -> 2 | `Button_release -> 3 | `Enter_window -> 4 | `Leave_window -> 5 | `Pointer_motion -> 6 | `Pointer_motion_hint -> 7 | `Button1_motion -> 8 | `Button2_motion -> 9 | `Button3_motion -> 10 | `Button4_motion -> 11 | `Button5_motion -> 12 | `Button_motion -> 13 | `Keymap_state -> 14 | `Exposure -> 15 | `Visibility_change -> 16 | `Structure_notify -> 17 | `Resize_redirect -> 18 | `Substructure_notify -> 19 | `Substructure_redirect -> 20 | `Focus_change -> 21 | `Property_change -> 22 | `Color_map_change -> 23 | `Owner_grab_button -> 24 in mask_value_to_int to_mask to_enum mask;;
type backing_store_enum = [ `Not_useful | `When_mapped | `Always ] [@@deriving sexp];;
let backing_store_enum_of_int : int -> [> backing_store_enum ] option = function 0 -> Some `Not_useful | 1 -> Some `When_mapped | 2 -> Some `Always | n -> Printf.printf "unknown backing_store_enum: %d\n" n; None;;
let backing_store_int_of_enum : backing_store_enum -> int = function `Not_useful -> 0 | `When_mapped -> 1 | `Always -> 2;;
type screen = { root : window; default_colormap : colormap; white_pixel : int; black_pixel : int; current_input_masks : event_mask; width_in_pixels : int; height_in_pixels : int; width_in_millimeters : int; height_in_millimeters : int; min_installed_maps : int; max_installed_maps : int; root_visual : visualid; backing_stores : backing_store_enum; save_unders : bool; root_depth : int; allowed_depths : depth list; } [@@deriving sexp];;
let decode_screen buf ~at : (screen * int) option = let orig = at in let* root, at = decode_window buf ~at in
let* default_colormap, at = decode_colormap buf ~at in
let* white_pixel, at = decode_int32 buf ~at in
let* black_pixel, at = decode_int32 buf ~at in
let* current_input_masks, at = decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at in
let* width_in_pixels, at = decode_uint16 buf ~at in
let* height_in_pixels, at = decode_uint16 buf ~at in
let* width_in_millimeters, at = decode_uint16 buf ~at in
let* height_in_millimeters, at = decode_uint16 buf ~at in
let* min_installed_maps, at = decode_uint16 buf ~at in
let* max_installed_maps, at = decode_uint16 buf ~at in
let* root_visual, at = decode_visualid buf ~at in
let* backing_stores, at = decode_enum decode_char Char.code backing_store_enum_of_int buf ~at in
let* save_unders, at = decode_bool buf ~at in
let* root_depth, at = decode_uint8 buf ~at in
let* allowed_depths_len, at = decode_uint8 buf ~at in let allowed_depths_len = allowed_depths_len in
let* allowed_depths, at = decode_list (decode_depth) allowed_depths_len buf ~at in
ignore orig;
Some ({ root; default_colormap; white_pixel; black_pixel; current_input_masks; width_in_pixels; height_in_pixels; width_in_millimeters; height_in_millimeters; min_installed_maps; max_installed_maps; root_visual; backing_stores; save_unders; root_depth; allowed_depths }, at);;
let encode_screen buf (v : screen) ~at : int option = let orig = at in let* at = encode_window buf v.root ~at in let* at = encode_colormap buf v.default_colormap ~at in let* at = encode_int32 buf v.white_pixel ~at in let* at = encode_int32 buf v.black_pixel ~at in let* at = encode_mask encode_int32 identity event_mask_int_of_mask buf v.current_input_masks ~at in let* at = encode_uint16 buf v.width_in_pixels ~at in let* at = encode_uint16 buf v.height_in_pixels ~at in let* at = encode_uint16 buf v.width_in_millimeters ~at in let* at = encode_uint16 buf v.height_in_millimeters ~at in let* at = encode_uint16 buf v.min_installed_maps ~at in let* at = encode_uint16 buf v.max_installed_maps ~at in let* at = encode_visualid buf v.root_visual ~at in let* at = encode_enum encode_char Char.chr backing_store_int_of_enum buf v.backing_stores ~at in let* at = encode_bool buf v.save_unders ~at in let* at = encode_uint8 buf v.root_depth ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.allowed_depths)) ~at in let* at = encode_list encode_depth buf v.allowed_depths ~at in ignore orig; Some at;;

type setup_request = { byte_order : int; protocol_major_version : int; protocol_minor_version : int; authorization_protocol_name : string; authorization_protocol_data : string; } [@@deriving sexp];;
let decode_setup_request buf ~at : (setup_request * int) option = let orig = at in let* byte_order, at = decode_uint8 buf ~at in
let at = at + 1 in
let* protocol_major_version, at = decode_uint16 buf ~at in
let* protocol_minor_version, at = decode_uint16 buf ~at in
let* authorization_protocol_name_len, at = decode_uint16 buf ~at in let authorization_protocol_name_len = authorization_protocol_name_len in
let* authorization_protocol_data_len, at = decode_uint16 buf ~at in let authorization_protocol_data_len = authorization_protocol_data_len in
let at = at + 2 in
let* authorization_protocol_name, at = decode_string authorization_protocol_name_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* authorization_protocol_data, at = decode_string authorization_protocol_data_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ byte_order; protocol_major_version; protocol_minor_version; authorization_protocol_name; authorization_protocol_data }, at);;
let encode_setup_request buf (v : setup_request) ~at : int option = let orig = at in let* at = encode_uint8 buf v.byte_order ~at in let at = at + 1 in let* at = encode_uint16 buf v.protocol_major_version ~at in let* at = encode_uint16 buf v.protocol_minor_version ~at in let* at = encode_uint16 buf (identity (String.length v.authorization_protocol_name)) ~at in let* at = encode_uint16 buf (identity (String.length v.authorization_protocol_data)) ~at in let at = at + 2 in let* at = encode_string buf v.authorization_protocol_name ~at in let at = at + ((at - orig) mod 4) in let* at = encode_string buf v.authorization_protocol_data ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type setup_failed = { status : int; protocol_major_version : int; protocol_minor_version : int; length : int; reason : string; } [@@deriving sexp];;
let decode_setup_failed buf ~at : (setup_failed * int) option = let orig = at in let* status, at = decode_uint8 buf ~at in
let* reason_len, at = decode_uint8 buf ~at in let reason_len = reason_len in
let* protocol_major_version, at = decode_uint16 buf ~at in
let* protocol_minor_version, at = decode_uint16 buf ~at in
let* length, at = decode_uint16 buf ~at in
let* reason, at = decode_string reason_len buf ~at in
ignore orig;
Some ({ status; protocol_major_version; protocol_minor_version; length; reason }, at);;
let encode_setup_failed buf (v : setup_failed) ~at : int option = let orig = at in let* at = encode_uint8 buf v.status ~at in let* at = encode_uint8 buf (identity (String.length v.reason)) ~at in let* at = encode_uint16 buf v.protocol_major_version ~at in let* at = encode_uint16 buf v.protocol_minor_version ~at in let* at = encode_uint16 buf v.length ~at in let* at = encode_string buf v.reason ~at in ignore orig; Some at;;

type setup_authenticate = { status : int; reason : string; } [@@deriving sexp];;
let decode_setup_authenticate buf ~at : (setup_authenticate * int) option = let orig = at in let* status, at = decode_uint8 buf ~at in
let at = at + 5 in
let* length, at = decode_uint16 buf ~at in let length = (length) / (4) in
let* reason, at = decode_string length buf ~at in
ignore orig;
Some ({ status; reason }, at);;
let encode_setup_authenticate buf (v : setup_authenticate) ~at : int option = let orig = at in let* at = encode_uint8 buf v.status ~at in let at = at + 5 in let* at = encode_uint16 buf (identity (String.length v.reason)) ~at in let* at = encode_string buf v.reason ~at in ignore orig; Some at;;

type image_order_enum = [ `Lsb_first | `Msb_first ] [@@deriving sexp];;
let image_order_enum_of_int : int -> [> image_order_enum ] option = function 0 -> Some `Lsb_first | 1 -> Some `Msb_first | n -> Printf.printf "unknown image_order_enum: %d\n" n; None;;
let image_order_int_of_enum : image_order_enum -> int = function `Lsb_first -> 0 | `Msb_first -> 1;;
type setup = { status : int; protocol_major_version : int; protocol_minor_version : int; length : int; release_number : int; resource_id_base : int; resource_id_mask : int; motion_buffer_size : int; maximum_request_length : int; image_byte_order : image_order_enum; bitmap_format_bit_order : image_order_enum; bitmap_format_scanline_unit : int; bitmap_format_scanline_pad : int; min_keycode : keycode; max_keycode : keycode; vendor : string; pixmap_formats : format list; roots : screen list; } [@@deriving sexp];;
let decode_setup buf ~at : (setup * int) option = let orig = at in let* status, at = decode_uint8 buf ~at in
let at = at + 1 in
let* protocol_major_version, at = decode_uint16 buf ~at in
let* protocol_minor_version, at = decode_uint16 buf ~at in
let* length, at = decode_uint16 buf ~at in
let* release_number, at = decode_int32 buf ~at in
let* resource_id_base, at = decode_int32 buf ~at in
let* resource_id_mask, at = decode_int32 buf ~at in
let* motion_buffer_size, at = decode_int32 buf ~at in
let* vendor_len, at = decode_uint16 buf ~at in let vendor_len = vendor_len in
let* maximum_request_length, at = decode_uint16 buf ~at in
let* roots_len, at = decode_uint8 buf ~at in let roots_len = roots_len in
let* pixmap_formats_len, at = decode_uint8 buf ~at in let pixmap_formats_len = pixmap_formats_len in
let* image_byte_order, at = decode_enum decode_uint8 identity image_order_enum_of_int buf ~at in
let* bitmap_format_bit_order, at = decode_enum decode_uint8 identity image_order_enum_of_int buf ~at in
let* bitmap_format_scanline_unit, at = decode_uint8 buf ~at in
let* bitmap_format_scanline_pad, at = decode_uint8 buf ~at in
let* min_keycode, at = decode_keycode buf ~at in
let* max_keycode, at = decode_keycode buf ~at in
let at = at + 4 in
let* vendor, at = decode_string vendor_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* pixmap_formats, at = decode_list (decode_format) pixmap_formats_len buf ~at in
let* roots, at = decode_list (decode_screen) roots_len buf ~at in
ignore orig;
Some ({ status; protocol_major_version; protocol_minor_version; length; release_number; resource_id_base; resource_id_mask; motion_buffer_size; maximum_request_length; image_byte_order; bitmap_format_bit_order; bitmap_format_scanline_unit; bitmap_format_scanline_pad; min_keycode; max_keycode; vendor; pixmap_formats; roots }, at);;
let encode_setup buf (v : setup) ~at : int option = let orig = at in let* at = encode_uint8 buf v.status ~at in let at = at + 1 in let* at = encode_uint16 buf v.protocol_major_version ~at in let* at = encode_uint16 buf v.protocol_minor_version ~at in let* at = encode_uint16 buf v.length ~at in let* at = encode_int32 buf v.release_number ~at in let* at = encode_int32 buf v.resource_id_base ~at in let* at = encode_int32 buf v.resource_id_mask ~at in let* at = encode_int32 buf v.motion_buffer_size ~at in let* at = encode_uint16 buf (identity (String.length v.vendor)) ~at in let* at = encode_uint16 buf v.maximum_request_length ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.roots)) ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.pixmap_formats)) ~at in let* at = encode_enum encode_uint8 identity image_order_int_of_enum buf v.image_byte_order ~at in let* at = encode_enum encode_uint8 identity image_order_int_of_enum buf v.bitmap_format_bit_order ~at in let* at = encode_uint8 buf v.bitmap_format_scanline_unit ~at in let* at = encode_uint8 buf v.bitmap_format_scanline_pad ~at in let* at = encode_keycode buf v.min_keycode ~at in let* at = encode_keycode buf v.max_keycode ~at in let at = at + 4 in let* at = encode_string buf v.vendor ~at in let at = at + ((at - orig) mod 4) in let* at = encode_list encode_format buf v.pixmap_formats ~at in let* at = encode_list encode_screen buf v.roots ~at in ignore orig; Some at;;

type mod_mask = [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list [@@deriving sexp];;
let mod_mask_mask_of_int64 mask : mod_mask option = let of_int = function 0 -> Some `Shift | 1 -> Some `Lock | 2 -> Some `Control | 3 -> Some `D1 | 4 -> Some `D2 | 5 -> Some `D3 | 6 -> Some `D4 | 7 -> Some `D5 | 15 -> Some `Any | _ -> None in mask_of_int of_int mask;;
let mod_mask_int_of_mask : mod_mask -> int = let to_bit = function `Shift -> 0 | `Lock -> 1 | `Control -> 2 | `D1 -> 3 | `D2 -> 4 | `D3 -> 5 | `D4 -> 6 | `D5 -> 7 | `Any -> 15 in int_of_mask to_bit;;
type key_but_mask = [ `Shift | `Lock | `Control | `Mod1 | `Mod2 | `Mod3 | `Mod4 | `Mod5 | `Button1 | `Button2 | `Button3 | `Button4 | `Button5 ] list [@@deriving sexp];;
let key_but_mask_mask_of_int64 mask : key_but_mask option = let of_int = function 0 -> Some `Shift | 1 -> Some `Lock | 2 -> Some `Control | 3 -> Some `Mod1 | 4 -> Some `Mod2 | 5 -> Some `Mod3 | 6 -> Some `Mod4 | 7 -> Some `Mod5 | 8 -> Some `Button1 | 9 -> Some `Button2 | 10 -> Some `Button3 | 11 -> Some `Button4 | 12 -> Some `Button5 | _ -> None in mask_of_int of_int mask;;
let key_but_mask_int_of_mask : key_but_mask -> int = let to_bit = function `Shift -> 0 | `Lock -> 1 | `Control -> 2 | `Mod1 -> 3 | `Mod2 -> 4 | `Mod3 -> 5 | `Mod4 -> 6 | `Mod5 -> 7 | `Button1 -> 8 | `Button2 -> 9 | `Button3 -> 10 | `Button4 -> 11 | `Button5 -> 12 in int_of_mask to_bit;;
type window_enum = [ `None ] [@@deriving sexp];;
let window_enum_of_int : int -> [> window_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown window_enum: %d\n" n; None;;
let window_int_of_enum : window_enum -> int = function `None -> 0;;
type key_press_event = { detail : keycode; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; same_screen : bool; } [@@deriving sexp];;
type key_release_event = key_press_event [@@deriving sexp];;
type button_mask = [ `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list [@@deriving sexp];;
let button_mask_mask_of_int64 mask : button_mask option = let of_int = function 8 -> Some `D1 | 9 -> Some `D2 | 10 -> Some `D3 | 11 -> Some `D4 | 12 -> Some `D5 | 15 -> Some `Any | _ -> None in mask_of_int of_int mask;;
let button_mask_int_of_mask : button_mask -> int = let to_bit = function `D1 -> 8 | `D2 -> 9 | `D3 -> 10 | `D4 -> 11 | `D5 -> 12 | `Any -> 15 in int_of_mask to_bit;;
type button_press_event = { detail : button; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; same_screen : bool; } [@@deriving sexp];;
type button_release_event = button_press_event [@@deriving sexp];;
type motion_enum = [ `Normal | `Hint ] [@@deriving sexp];;
let motion_enum_of_int : int -> [> motion_enum ] option = function 0 -> Some `Normal | 1 -> Some `Hint | n -> Printf.printf "unknown motion_enum: %d\n" n; None;;
let motion_int_of_enum : motion_enum -> int = function `Normal -> 0 | `Hint -> 1;;
type motion_notify_event = { detail : motion_enum; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; same_screen : bool; } [@@deriving sexp];;
type notify_detail_enum = [ `Ancestor | `Virtual | `Inferior | `Nonlinear | `Nonlinear_virtual | `Pointer | `Pointer_root | `None ] [@@deriving sexp];;
let notify_detail_enum_of_int : int -> [> notify_detail_enum ] option = function 0 -> Some `Ancestor | 1 -> Some `Virtual | 2 -> Some `Inferior | 3 -> Some `Nonlinear | 4 -> Some `Nonlinear_virtual | 5 -> Some `Pointer | 6 -> Some `Pointer_root | 7 -> Some `None | n -> Printf.printf "unknown notify_detail_enum: %d\n" n; None;;
let notify_detail_int_of_enum : notify_detail_enum -> int = function `Ancestor -> 0 | `Virtual -> 1 | `Inferior -> 2 | `Nonlinear -> 3 | `Nonlinear_virtual -> 4 | `Pointer -> 5 | `Pointer_root -> 6 | `None -> 7;;
type notify_mode_enum = [ `Normal | `Grab | `Ungrab | `While_grabbed ] [@@deriving sexp];;
let notify_mode_enum_of_int : int -> [> notify_mode_enum ] option = function 0 -> Some `Normal | 1 -> Some `Grab | 2 -> Some `Ungrab | 3 -> Some `While_grabbed | n -> Printf.printf "unknown notify_mode_enum: %d\n" n; None;;
let notify_mode_int_of_enum : notify_mode_enum -> int = function `Normal -> 0 | `Grab -> 1 | `Ungrab -> 2 | `While_grabbed -> 3;;
type enter_notify_event = { detail : notify_detail_enum; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; mode : notify_mode_enum; same_screen_focus : char; } [@@deriving sexp];;
type leave_notify_event = enter_notify_event [@@deriving sexp];;
type focus_in_event = { detail : notify_detail_enum; event : window; mode : notify_mode_enum; } [@@deriving sexp];;
type focus_out_event = focus_in_event [@@deriving sexp];;
type keymap_notify_event = { keys : int list; } [@@deriving sexp];;
type expose_event = { window : window; x : int; y : int; width : int; height : int; count : int; } [@@deriving sexp];;
type graphics_exposure_event = { drawable : drawable; x : int; y : int; width : int; height : int; minor_opcode : int; count : int; major_opcode : int; } [@@deriving sexp];;
type no_exposure_event = { drawable : drawable; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type visibility_enum = [ `Unobscured | `Partially_obscured | `Fully_obscured ] [@@deriving sexp];;
let visibility_enum_of_int : int -> [> visibility_enum ] option = function 0 -> Some `Unobscured | 1 -> Some `Partially_obscured | 2 -> Some `Fully_obscured | n -> Printf.printf "unknown visibility_enum: %d\n" n; None;;
let visibility_int_of_enum : visibility_enum -> int = function `Unobscured -> 0 | `Partially_obscured -> 1 | `Fully_obscured -> 2;;
type visibility_notify_event = { window : window; state : visibility_enum; } [@@deriving sexp];;
type create_notify_event = { parent : window; window : window; x : int; y : int; width : int; height : int; border_width : int; override_redirect : bool; } [@@deriving sexp];;
type destroy_notify_event = { event : window; window : window; } [@@deriving sexp];;
type unmap_notify_event = { event : window; window : window; from_configure : bool; } [@@deriving sexp];;
type map_notify_event = { event : window; window : window; override_redirect : bool; } [@@deriving sexp];;
type map_request_event = { parent : window; window : window; } [@@deriving sexp];;
type reparent_notify_event = { event : window; window : window; parent : window; x : int; y : int; override_redirect : bool; } [@@deriving sexp];;
type configure_notify_event = { event : window; window : window; above_sibling : window_enum alt_enum; x : int; y : int; width : int; height : int; border_width : int; override_redirect : bool; } [@@deriving sexp];;
type stack_mode_enum = [ `Above | `Below | `Top_if | `Bottom_if | `Opposite ] [@@deriving sexp];;
let stack_mode_enum_of_int : int -> [> stack_mode_enum ] option = function 0 -> Some `Above | 1 -> Some `Below | 2 -> Some `Top_if | 3 -> Some `Bottom_if | 4 -> Some `Opposite | n -> Printf.printf "unknown stack_mode_enum: %d\n" n; None;;
let stack_mode_int_of_enum : stack_mode_enum -> int = function `Above -> 0 | `Below -> 1 | `Top_if -> 2 | `Bottom_if -> 3 | `Opposite -> 4;;
type config_window_mask = [ `X | `Y | `Width | `Height | `Border_width | `Sibling | `Stack_mode ] list [@@deriving sexp];;
let config_window_mask_of_int64 mask : config_window_mask option = let of_int = function 0 -> Some `X | 1 -> Some `Y | 2 -> Some `Width | 3 -> Some `Height | 4 -> Some `Border_width | 5 -> Some `Sibling | 6 -> Some `Stack_mode | _ -> None in mask_of_int of_int mask;;
let config_window_int_of_mask : config_window_mask -> int = let to_bit = function `X -> 0 | `Y -> 1 | `Width -> 2 | `Height -> 3 | `Border_width -> 4 | `Sibling -> 5 | `Stack_mode -> 6 in int_of_mask to_bit;;
type configure_request_event = { stack_mode : stack_mode_enum; parent : window; window : window; sibling : window_enum alt_enum; x : int; y : int; width : int; height : int; border_width : int; value_mask : config_window_mask; } [@@deriving sexp];;
type gravity_notify_event = { event : window; window : window; x : int; y : int; } [@@deriving sexp];;
type resize_request_event = { window : window; width : int; height : int; } [@@deriving sexp];;
type place_enum = [ `On_top | `On_bottom ] [@@deriving sexp];;
let place_enum_of_int : int -> [> place_enum ] option = function 0 -> Some `On_top | 1 -> Some `On_bottom | n -> Printf.printf "unknown place_enum: %d\n" n; None;;
let place_int_of_enum : place_enum -> int = function `On_top -> 0 | `On_bottom -> 1;;
type circulate_notify_event = { event : window; window : window; place : place_enum; } [@@deriving sexp];;
type circulate_request_event = circulate_notify_event [@@deriving sexp];;
type property_enum = [ `New_value | `Delete ] [@@deriving sexp];;
let property_enum_of_int : int -> [> property_enum ] option = function 0 -> Some `New_value | 1 -> Some `Delete | n -> Printf.printf "unknown property_enum: %d\n" n; None;;
let property_int_of_enum : property_enum -> int = function `New_value -> 0 | `Delete -> 1;;
type property_notify_event = { window : window; atom : atom; time : timestamp; state : property_enum; } [@@deriving sexp];;
type selection_clear_event = { time : timestamp; owner : window; selection : atom; } [@@deriving sexp];;
type time_enum = [ `Current_time ] [@@deriving sexp];;
let time_enum_of_int : int -> [> time_enum ] option = function 0 -> Some `Current_time | n -> Printf.printf "unknown time_enum: %d\n" n; None;;
let time_int_of_enum : time_enum -> int = function `Current_time -> 0;;
type atom_enum = [ `None | `Any | `Primary | `Secondary | `Arc | `Atom | `Bitmap | `Cardinal | `Colormap | `Cursor | `Cut_buffer0 | `Cut_buffer1 | `Cut_buffer2 | `Cut_buffer3 | `Cut_buffer4 | `Cut_buffer5 | `Cut_buffer6 | `Cut_buffer7 | `Drawable | `Font | `Integer | `Pixmap | `Point | `Rectangle | `Resource_manager | `Rgb_color_map | `Rgb_best_map | `Rgb_blue_map | `Rgb_default_map | `Rgb_gray_map | `Rgb_green_map | `Rgb_red_map | `String | `Visualid | `Window | `Wm_command | `Wm_hints | `Wm_client_machine | `Wm_icon_name | `Wm_icon_size | `Wm_name | `Wm_normal_hints | `Wm_size_hints | `Wm_zoom_hints | `Min_space | `Norm_space | `Max_space | `End_space | `Superscript_x | `Superscript_y | `Subscript_x | `Subscript_y | `Underline_position | `Underline_thickness | `Strikeout_ascent | `Strikeout_descent | `Italic_angle | `X_height | `Quad_width | `Weight | `Point_size | `Resolution | `Copyright | `Notice | `Font_name | `Family_name | `Full_name | `Cap_height | `Wm_class | `Wm_transient_for ] [@@deriving sexp];;
let atom_enum_of_int : int -> [> atom_enum ] option = function 0 -> Some `None | 0 -> Some `Any | 1 -> Some `Primary | 2 -> Some `Secondary | 3 -> Some `Arc | 4 -> Some `Atom | 5 -> Some `Bitmap | 6 -> Some `Cardinal | 7 -> Some `Colormap | 8 -> Some `Cursor | 9 -> Some `Cut_buffer0 | 10 -> Some `Cut_buffer1 | 11 -> Some `Cut_buffer2 | 12 -> Some `Cut_buffer3 | 13 -> Some `Cut_buffer4 | 14 -> Some `Cut_buffer5 | 15 -> Some `Cut_buffer6 | 16 -> Some `Cut_buffer7 | 17 -> Some `Drawable | 18 -> Some `Font | 19 -> Some `Integer | 20 -> Some `Pixmap | 21 -> Some `Point | 22 -> Some `Rectangle | 23 -> Some `Resource_manager | 24 -> Some `Rgb_color_map | 25 -> Some `Rgb_best_map | 26 -> Some `Rgb_blue_map | 27 -> Some `Rgb_default_map | 28 -> Some `Rgb_gray_map | 29 -> Some `Rgb_green_map | 30 -> Some `Rgb_red_map | 31 -> Some `String | 32 -> Some `Visualid | 33 -> Some `Window | 34 -> Some `Wm_command | 35 -> Some `Wm_hints | 36 -> Some `Wm_client_machine | 37 -> Some `Wm_icon_name | 38 -> Some `Wm_icon_size | 39 -> Some `Wm_name | 40 -> Some `Wm_normal_hints | 41 -> Some `Wm_size_hints | 42 -> Some `Wm_zoom_hints | 43 -> Some `Min_space | 44 -> Some `Norm_space | 45 -> Some `Max_space | 46 -> Some `End_space | 47 -> Some `Superscript_x | 48 -> Some `Superscript_y | 49 -> Some `Subscript_x | 50 -> Some `Subscript_y | 51 -> Some `Underline_position | 52 -> Some `Underline_thickness | 53 -> Some `Strikeout_ascent | 54 -> Some `Strikeout_descent | 55 -> Some `Italic_angle | 56 -> Some `X_height | 57 -> Some `Quad_width | 58 -> Some `Weight | 59 -> Some `Point_size | 60 -> Some `Resolution | 61 -> Some `Copyright | 62 -> Some `Notice | 63 -> Some `Font_name | 64 -> Some `Family_name | 65 -> Some `Full_name | 66 -> Some `Cap_height | 67 -> Some `Wm_class | 68 -> Some `Wm_transient_for | n -> Printf.printf "unknown atom_enum: %d\n" n; None;;
let atom_int_of_enum : atom_enum -> int = function `None -> 0 | `Any -> 0 | `Primary -> 1 | `Secondary -> 2 | `Arc -> 3 | `Atom -> 4 | `Bitmap -> 5 | `Cardinal -> 6 | `Colormap -> 7 | `Cursor -> 8 | `Cut_buffer0 -> 9 | `Cut_buffer1 -> 10 | `Cut_buffer2 -> 11 | `Cut_buffer3 -> 12 | `Cut_buffer4 -> 13 | `Cut_buffer5 -> 14 | `Cut_buffer6 -> 15 | `Cut_buffer7 -> 16 | `Drawable -> 17 | `Font -> 18 | `Integer -> 19 | `Pixmap -> 20 | `Point -> 21 | `Rectangle -> 22 | `Resource_manager -> 23 | `Rgb_color_map -> 24 | `Rgb_best_map -> 25 | `Rgb_blue_map -> 26 | `Rgb_default_map -> 27 | `Rgb_gray_map -> 28 | `Rgb_green_map -> 29 | `Rgb_red_map -> 30 | `String -> 31 | `Visualid -> 32 | `Window -> 33 | `Wm_command -> 34 | `Wm_hints -> 35 | `Wm_client_machine -> 36 | `Wm_icon_name -> 37 | `Wm_icon_size -> 38 | `Wm_name -> 39 | `Wm_normal_hints -> 40 | `Wm_size_hints -> 41 | `Wm_zoom_hints -> 42 | `Min_space -> 43 | `Norm_space -> 44 | `Max_space -> 45 | `End_space -> 46 | `Superscript_x -> 47 | `Superscript_y -> 48 | `Subscript_x -> 49 | `Subscript_y -> 50 | `Underline_position -> 51 | `Underline_thickness -> 52 | `Strikeout_ascent -> 53 | `Strikeout_descent -> 54 | `Italic_angle -> 55 | `X_height -> 56 | `Quad_width -> 57 | `Weight -> 58 | `Point_size -> 59 | `Resolution -> 60 | `Copyright -> 61 | `Notice -> 62 | `Font_name -> 63 | `Family_name -> 64 | `Full_name -> 65 | `Cap_height -> 66 | `Wm_class -> 67 | `Wm_transient_for -> 68;;
type selection_request_event = { time : time_enum alt_enum; owner : window; requestor : window; selection : atom; target : atom; property : atom_enum alt_enum; } [@@deriving sexp];;
type selection_notify_event = { time : time_enum alt_enum; requestor : window; selection : atom; target : atom; property : atom_enum alt_enum; } [@@deriving sexp];;
type colormap_state_enum = [ `Uninstalled | `Installed ] [@@deriving sexp];;
let colormap_state_enum_of_int : int -> [> colormap_state_enum ] option = function 0 -> Some `Uninstalled | 1 -> Some `Installed | n -> Printf.printf "unknown colormap_state_enum: %d\n" n; None;;
let colormap_state_int_of_enum : colormap_state_enum -> int = function `Uninstalled -> 0 | `Installed -> 1;;
type colormap_enum = [ `None ] [@@deriving sexp];;
let colormap_enum_of_int : int -> [> colormap_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown colormap_enum: %d\n" n; None;;
let colormap_int_of_enum : colormap_enum -> int = function `None -> 0;;
type colormap_notify_event = { window : window; colormap : colormap_enum alt_enum; new_ : bool; state : colormap_state_enum; } [@@deriving sexp];;
type client_message_data_format_enum = [ `Data8 | `Data16 | `Data32 ] [@@deriving sexp];;
let client_message_data_format_enum_of_int : int -> [> client_message_data_format_enum ] option = function 8 -> Some `Data8 | 16 -> Some `Data16 | 32 -> Some `Data32 | n -> Printf.printf "unknown client_message_data_format_enum: %d\n" n; None;;
let client_message_data_format_int_of_enum : client_message_data_format_enum -> int = function `Data8 -> 8 | `Data16 -> 16 | `Data32 -> 32;;
type client_message_data_format_variant = Data8 of { data8 : int list; } | Data16 of { data16 : int list; } | Data32 of { data32 : int list; } [@@deriving sexp];;
type client_message_event = { window : window; type_ : atom; data : client_message_data_format_variant; } [@@deriving sexp];;
type mapping_enum = [ `Modifier | `Keyboard | `Pointer ] [@@deriving sexp];;
let mapping_enum_of_int : int -> [> mapping_enum ] option = function 0 -> Some `Modifier | 1 -> Some `Keyboard | 2 -> Some `Pointer | n -> Printf.printf "unknown mapping_enum: %d\n" n; None;;
let mapping_int_of_enum : mapping_enum -> int = function `Modifier -> 0 | `Keyboard -> 1 | `Pointer -> 2;;
type mapping_notify_event = { request : mapping_enum; first_keycode : keycode; count : int; } [@@deriving sexp];;
type ge_generic_event = unit [@@deriving sexp];;
type request_error = { bad_value : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type value_error = { bad_value : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type window_error = value_error [@@deriving sexp];;
type pixmap_error = value_error [@@deriving sexp];;
type atom_error = value_error [@@deriving sexp];;
type cursor_error = value_error [@@deriving sexp];;
type font_error = value_error [@@deriving sexp];;
type match_error = request_error [@@deriving sexp];;
type drawable_error = value_error [@@deriving sexp];;
type access_error = request_error [@@deriving sexp];;
type alloc_error = request_error [@@deriving sexp];;
type colormap_error = value_error [@@deriving sexp];;
type g_context_error = value_error [@@deriving sexp];;
type id_choice_error = value_error [@@deriving sexp];;
type name_error = request_error [@@deriving sexp];;
type length_error = request_error [@@deriving sexp];;
type implementation_error = request_error [@@deriving sexp];;
type window_class_enum = [ `Copy_from_parent | `Input_output | `Input_only ] [@@deriving sexp];;
let window_class_enum_of_int : int -> [> window_class_enum ] option = function 0 -> Some `Copy_from_parent | 1 -> Some `Input_output | 2 -> Some `Input_only | n -> Printf.printf "unknown window_class_enum: %d\n" n; None;;
let window_class_int_of_enum : window_class_enum -> int = function `Copy_from_parent -> 0 | `Input_output -> 1 | `Input_only -> 2;;
type cw_mask = [ `Back_pixmap | `Back_pixel | `Border_pixmap | `Border_pixel | `Bit_gravity | `Win_gravity | `Backing_store | `Backing_planes | `Backing_pixel | `Override_redirect | `Save_under | `Event_mask | `Dont_propagate | `Colormap | `Cursor ] list [@@deriving sexp];;
let cw_mask_of_int64 mask : cw_mask option = let of_int = function 0 -> Some `Back_pixmap | 1 -> Some `Back_pixel | 2 -> Some `Border_pixmap | 3 -> Some `Border_pixel | 4 -> Some `Bit_gravity | 5 -> Some `Win_gravity | 6 -> Some `Backing_store | 7 -> Some `Backing_planes | 8 -> Some `Backing_pixel | 9 -> Some `Override_redirect | 10 -> Some `Save_under | 11 -> Some `Event_mask | 12 -> Some `Dont_propagate | 13 -> Some `Colormap | 14 -> Some `Cursor | _ -> None in mask_of_int of_int mask;;
let cw_int_of_mask : cw_mask -> int = let to_bit = function `Back_pixmap -> 0 | `Back_pixel -> 1 | `Border_pixmap -> 2 | `Border_pixel -> 3 | `Bit_gravity -> 4 | `Win_gravity -> 5 | `Backing_store -> 6 | `Backing_planes -> 7 | `Backing_pixel -> 8 | `Override_redirect -> 9 | `Save_under -> 10 | `Event_mask -> 11 | `Dont_propagate -> 12 | `Colormap -> 13 | `Cursor -> 14 in int_of_mask to_bit;;
type back_pixmap_enum = [ `None | `Parent_relative ] [@@deriving sexp];;
let back_pixmap_enum_of_int : int -> [> back_pixmap_enum ] option = function 0 -> Some `None | 1 -> Some `Parent_relative | n -> Printf.printf "unknown back_pixmap_enum: %d\n" n; None;;
let back_pixmap_int_of_enum : back_pixmap_enum -> int = function `None -> 0 | `Parent_relative -> 1;;
type gravity_enum = [ `Bit_forget | `Win_unmap | `North_west | `North | `North_east | `West | `Center | `East | `South_west | `South | `South_east | `Static ] [@@deriving sexp];;
let gravity_enum_of_int : int -> [> gravity_enum ] option = function 0 -> Some `Bit_forget | 0 -> Some `Win_unmap | 1 -> Some `North_west | 2 -> Some `North | 3 -> Some `North_east | 4 -> Some `West | 5 -> Some `Center | 6 -> Some `East | 7 -> Some `South_west | 8 -> Some `South | 9 -> Some `South_east | 10 -> Some `Static | n -> Printf.printf "unknown gravity_enum: %d\n" n; None;;
let gravity_int_of_enum : gravity_enum -> int = function `Bit_forget -> 0 | `Win_unmap -> 0 | `North_west -> 1 | `North -> 2 | `North_east -> 3 | `West -> 4 | `Center -> 5 | `East -> 6 | `South_west -> 7 | `South -> 8 | `South_east -> 9 | `Static -> 10;;
type pixmap_enum = [ `None ] [@@deriving sexp];;
let pixmap_enum_of_int : int -> [> pixmap_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown pixmap_enum: %d\n" n; None;;
let pixmap_int_of_enum : pixmap_enum -> int = function `None -> 0;;
type cursor_enum = [ `None ] [@@deriving sexp];;
let cursor_enum_of_int : int -> [> cursor_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown cursor_enum: %d\n" n; None;;
let cursor_int_of_enum : cursor_enum -> int = function `None -> 0;;
let encode_create_window ~(depth : int) ~(wid : window) ~(parent : window) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(border_width : int) ~(class_ : window_class_enum) ~(visual : visualid) ?(background_pixmap : back_pixmap_enum alt_enum option) ?(background_pixel : int option) ?(border_pixmap : pixmap_enum alt_enum option) ?(border_pixel : int option) ?(bit_gravity : gravity_enum option) ?(win_gravity : gravity_enum option) ?(backing_store : backing_store_enum option) ?(backing_planes : int option) ?(backing_pixel : int option) ?(override_redirect : bool32 option) ?(save_under : bool32 option) ?(event_mask : event_mask option) ?(do_not_propogate_mask : event_mask option) ?(colormap : colormap_enum alt_enum option) ?(cursor : cursor_enum alt_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_uint8 buf depth ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf wid ~at in
let* at = encode_window buf parent ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint16 buf border_width ~at in
let* at = encode_enum encode_uint16 identity window_class_int_of_enum buf class_ ~at in
let* at = encode_visualid buf visual ~at in
(* field_optional_mask *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_change_window_attributes ~(window : window) ?(background_pixmap : back_pixmap_enum alt_enum option) ?(background_pixel : int option) ?(border_pixmap : pixmap_enum alt_enum option) ?(border_pixel : int option) ?(bit_gravity : gravity_enum option) ?(win_gravity : gravity_enum option) ?(backing_store : backing_store_enum option) ?(backing_planes : int option) ?(backing_pixel : int option) ?(override_redirect : bool32 option) ?(save_under : bool32 option) ?(event_mask : event_mask option) ?(do_not_propogate_mask : event_mask option) ?(colormap : colormap_enum alt_enum option) ?(cursor : cursor_enum alt_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* field_optional_mask *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type map_state_enum = [ `Unmapped | `Unviewable | `Viewable ] [@@deriving sexp];;
let map_state_enum_of_int : int -> [> map_state_enum ] option = function 0 -> Some `Unmapped | 1 -> Some `Unviewable | 2 -> Some `Viewable | n -> Printf.printf "unknown map_state_enum: %d\n" n; None;;
let map_state_int_of_enum : map_state_enum -> int = function `Unmapped -> 0 | `Unviewable -> 1 | `Viewable -> 2;;
type get_window_attributes_reply = { backing_store : backing_store_enum; visual : visualid; class_ : window_class_enum; bit_gravity : gravity_enum; win_gravity : gravity_enum; backing_planes : int; backing_pixel : int; save_under : bool; map_is_installed : bool; map_state : map_state_enum; override_redirect : bool; colormap : colormap_enum alt_enum; all_event_masks : event_mask; your_event_mask : event_mask; do_not_propagate_mask : event_mask; } [@@deriving sexp];;
let encode_get_window_attributes ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_window_attributes_reply length buf ~at : (get_window_attributes_reply * int) option = let orig = at in let at = at + 1 in
let* backing_store, at = decode_enum decode_uint8 identity backing_store_enum_of_int buf ~at in
let at = at + 6 in
let* visual, at = decode_visualid buf ~at in
let* class_, at = decode_enum decode_uint16 identity window_class_enum_of_int buf ~at in
let* bit_gravity, at = decode_enum decode_uint8 identity gravity_enum_of_int buf ~at in
let* win_gravity, at = decode_enum decode_uint8 identity gravity_enum_of_int buf ~at in
let* backing_planes, at = decode_int32 buf ~at in
let* backing_pixel, at = decode_int32 buf ~at in
let* save_under, at = decode_bool buf ~at in
let* map_is_installed, at = decode_bool buf ~at in
let* map_state, at = decode_enum decode_uint8 identity map_state_enum_of_int buf ~at in
let* override_redirect, at = decode_bool buf ~at in
let* colormap, at = decode_alt_enum decode_colormap identity colormap_enum_of_int buf ~at in
let* all_event_masks, at = decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at in
let* your_event_mask, at = decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at in
let* do_not_propagate_mask, at = decode_mask decode_uint16 Int64.of_int event_mask_mask_of_int64 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ backing_store; visual; class_; bit_gravity; win_gravity; backing_planes; backing_pixel; save_under; map_is_installed; map_state; override_redirect; colormap; all_event_masks; your_event_mask; do_not_propagate_mask }, at);;
let encode_destroy_window ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_destroy_subwindows ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type set_mode_enum = [ `Insert | `Delete ] [@@deriving sexp];;
let set_mode_enum_of_int : int -> [> set_mode_enum ] option = function 0 -> Some `Insert | 1 -> Some `Delete | n -> Printf.printf "unknown set_mode_enum: %d\n" n; None;;
let set_mode_int_of_enum : set_mode_enum -> int = function `Insert -> 0 | `Delete -> 1;;
let encode_change_save_set ~(mode : set_mode_enum) ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_enum encode_char Char.chr set_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_reparent_window ~(window : window) ~(parent : window) ~(x : int) ~(y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_window buf parent ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_map_window ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_map_subwindows ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_unmap_window ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_unmap_subwindows ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_configure_window ~(window : window) ?(x : int option) ?(y : int option) ?(width : int option) ?(height : int option) ?(border_width : int option) ?(sibling : window_enum alt_enum option) ?(stack_mode : stack_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* field_optional_mask *)
let at = at + 2 in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type circulate_enum = [ `Raise_lowest | `Lower_highest ] [@@deriving sexp];;
let circulate_enum_of_int : int -> [> circulate_enum ] option = function 0 -> Some `Raise_lowest | 1 -> Some `Lower_highest | n -> Printf.printf "unknown circulate_enum: %d\n" n; None;;
let circulate_int_of_enum : circulate_enum -> int = function `Raise_lowest -> 0 | `Lower_highest -> 1;;
let encode_circulate_window ~(direction : circulate_enum) ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_enum encode_uint8 identity circulate_int_of_enum buf direction ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_geometry_reply = { depth : int; root : window; x : int; y : int; width : int; height : int; border_width : int; } [@@deriving sexp];;
let encode_get_geometry ~(drawable : drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_geometry_reply length buf ~at : (get_geometry_reply * int) option = let orig = at in let at = at + 1 in
let* depth, at = decode_uint8 buf ~at in
let at = at + 6 in
let* root, at = decode_window buf ~at in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* border_width, at = decode_uint16 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ depth; root; x; y; width; height; border_width }, at);;
type query_tree_reply = { root : window; parent : window_enum alt_enum; children : window list; } [@@deriving sexp];;
let encode_query_tree ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_tree_reply length buf ~at : (query_tree_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* root, at = decode_window buf ~at in
let* parent, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
let* children_len, at = decode_uint16 buf ~at in let children_len = children_len in
let at = at + 14 in
let* children, at = decode_list (decode_window) children_len buf ~at in
ignore orig;
Some ({ root; parent; children }, at);;
type intern_atom_reply = { atom : atom_enum alt_enum; } [@@deriving sexp];;
let encode_intern_atom ~(only_if_exists : bool) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_bool buf only_if_exists ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_intern_atom_reply length buf ~at : (intern_atom_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* atom, at = decode_alt_enum decode_atom identity atom_enum_of_int buf ~at in
ignore orig;
Some ({ atom }, at);;
type get_atom_name_reply = { name : string; } [@@deriving sexp];;
let encode_get_atom_name ~(atom : atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_atom buf atom ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_atom_name_reply length buf ~at : (get_atom_name_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let at = at + 22 in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ name }, at);;
type prop_mode_enum = [ `Replace | `Prepend | `Append ] [@@deriving sexp];;
let prop_mode_enum_of_int : int -> [> prop_mode_enum ] option = function 0 -> Some `Replace | 1 -> Some `Prepend | 2 -> Some `Append | n -> Printf.printf "unknown prop_mode_enum: %d\n" n; None;;
let prop_mode_int_of_enum : prop_mode_enum -> int = function `Replace -> 0 | `Prepend -> 1 | `Append -> 2;;
let encode_change_property ~(mode : prop_mode_enum) ~(window : window) ~(property : atom) ~(type_ : atom) ~(format : int) ~(data_len : int) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_enum encode_uint8 identity prop_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_atom buf property ~at in
let* at = encode_atom buf type_ ~at in
let* at = encode_uint8 buf format ~at in
let at = at + 3 in
let* at = encode_int32 buf data_len ~at in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_delete_property ~(window : window) ~(property : atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_property_type_enum = [ `Any ] [@@deriving sexp];;
let get_property_type_enum_of_int : int -> [> get_property_type_enum ] option = function 0 -> Some `Any | n -> Printf.printf "unknown get_property_type_enum: %d\n" n; None;;
let get_property_type_int_of_enum : get_property_type_enum -> int = function `Any -> 0;;
type get_property_reply = { format : int; type_ : atom; bytes_after : int; value_len : int; value : char list; } [@@deriving sexp];;
let encode_get_property ~(delete : bool) ~(window : window) ~(property : atom) ~(type_ : get_property_type_enum alt_enum) ~(long_offset : int) ~(long_length : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_bool buf delete ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_atom buf property ~at in
let* at = encode_alt_enum encode_atom identity get_property_type_int_of_enum buf type_ ~at in
let* at = encode_int32 buf long_offset ~at in
let* at = encode_int32 buf long_length ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_property_reply length buf ~at : (get_property_reply * int) option = let orig = at in let at = at + 1 in
let* format, at = decode_uint8 buf ~at in
let at = at + 6 in
let* type_, at = decode_atom buf ~at in
let* bytes_after, at = decode_int32 buf ~at in
let* value_len, at = decode_int32 buf ~at in
let at = at + 12 in
let* value, at = let length = (value_len) * ((format) / (8)) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ format; type_; bytes_after; value_len; value }, at);;
type list_properties_reply = { atoms : atom list; } [@@deriving sexp];;
let encode_list_properties ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_list_properties_reply length buf ~at : (list_properties_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* atoms_len, at = decode_uint16 buf ~at in let atoms_len = atoms_len in
let at = at + 22 in
let* atoms, at = decode_list (decode_atom) atoms_len buf ~at in
ignore orig;
Some ({ atoms }, at);;
let encode_set_selection_owner ~(owner : window_enum alt_enum) ~(selection : atom) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf owner ~at in
let* at = encode_atom buf selection ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_selection_owner_reply = { owner : window_enum alt_enum; } [@@deriving sexp];;
let encode_get_selection_owner ~(selection : atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_atom buf selection ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_selection_owner_reply length buf ~at : (get_selection_owner_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* owner, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
ignore orig;
Some ({ owner }, at);;
let encode_convert_selection ~(requestor : window) ~(selection : atom) ~(target : atom) ~(property : atom_enum alt_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf requestor ~at in
let* at = encode_atom buf selection ~at in
let* at = encode_atom buf target ~at in
let* at = encode_alt_enum encode_atom identity atom_int_of_enum buf property ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type send_event_dest_enum = [ `Pointer_window | `Item_focus ] [@@deriving sexp];;
let send_event_dest_enum_of_int : int -> [> send_event_dest_enum ] option = function 0 -> Some `Pointer_window | 1 -> Some `Item_focus | n -> Printf.printf "unknown send_event_dest_enum: %d\n" n; None;;
let send_event_dest_int_of_enum : send_event_dest_enum -> int = function `Pointer_window -> 0 | `Item_focus -> 1;;
let encode_send_event ~(propagate : bool) ~(destination : send_event_dest_enum alt_enum) ~(event_mask : event_mask) ~(event : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in
let* at = encode_bool buf propagate ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity send_event_dest_int_of_enum buf destination ~at in
let* at = encode_mask encode_int32 identity event_mask_int_of_mask buf event_mask ~at in
let* at = encode_string buf event ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type grab_mode_enum = [ `Sync | `Async ] [@@deriving sexp];;
let grab_mode_enum_of_int : int -> [> grab_mode_enum ] option = function 0 -> Some `Sync | 1 -> Some `Async | n -> Printf.printf "unknown grab_mode_enum: %d\n" n; None;;
let grab_mode_int_of_enum : grab_mode_enum -> int = function `Sync -> 0 | `Async -> 1;;
type grab_status_enum = [ `Success | `Already_grabbed | `Invalid_time | `Not_viewable | `Frozen ] [@@deriving sexp];;
let grab_status_enum_of_int : int -> [> grab_status_enum ] option = function 0 -> Some `Success | 1 -> Some `Already_grabbed | 2 -> Some `Invalid_time | 3 -> Some `Not_viewable | 4 -> Some `Frozen | n -> Printf.printf "unknown grab_status_enum: %d\n" n; None;;
let grab_status_int_of_enum : grab_status_enum -> int = function `Success -> 0 | `Already_grabbed -> 1 | `Invalid_time -> 2 | `Not_viewable -> 3 | `Frozen -> 4;;
type grab_pointer_reply = { status : grab_status_enum; } [@@deriving sexp];;
let encode_grab_pointer ~(owner_events : bool) ~(grab_window : window) ~(event_mask : event_mask) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) ~(confine_to : window_enum alt_enum) ~(cursor : cursor_enum alt_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf keyboard_mode ~at in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf confine_to ~at in
let* at = encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_grab_pointer_reply length buf ~at : (grab_pointer_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code grab_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
let encode_ungrab_pointer ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type button_index_enum = [ `Any | `D1 | `D2 | `D3 | `D4 | `D5 ] [@@deriving sexp];;
let button_index_enum_of_int : int -> [> button_index_enum ] option = function 0 -> Some `Any | 1 -> Some `D1 | 2 -> Some `D2 | 3 -> Some `D3 | 4 -> Some `D4 | 5 -> Some `D5 | n -> Printf.printf "unknown button_index_enum: %d\n" n; None;;
let button_index_int_of_enum : button_index_enum -> int = function `Any -> 0 | `D1 -> 1 | `D2 -> 2 | `D3 -> 3 | `D4 -> 4 | `D5 -> 5;;
let encode_grab_button ~(owner_events : bool) ~(grab_window : window) ~(event_mask : event_mask) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) ~(confine_to : window_enum alt_enum) ~(cursor : cursor_enum alt_enum) ~(button : button_index_enum) ~(modifiers : mod_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf keyboard_mode ~at in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf confine_to ~at in
let* at = encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor ~at in
let* at = encode_enum encode_uint8 identity button_index_int_of_enum buf button ~at in
let at = at + 1 in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_ungrab_button ~(button : button_index_enum) ~(grab_window : window) ~(modifiers : mod_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = encode_enum encode_uint8 identity button_index_int_of_enum buf button ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_change_active_pointer_grab ~(cursor : cursor_enum alt_enum) ~(time : time_enum alt_enum) ~(event_mask : event_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
let* at = encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type grab_keyboard_reply = { status : grab_status_enum; } [@@deriving sexp];;
let encode_grab_keyboard ~(owner_events : bool) ~(grab_window : window) ~(time : time_enum alt_enum) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf keyboard_mode ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_grab_keyboard_reply length buf ~at : (grab_keyboard_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code grab_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
let encode_ungrab_keyboard ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type grab_enum = [ `Any ] [@@deriving sexp];;
let grab_enum_of_int : int -> [> grab_enum ] option = function 0 -> Some `Any | n -> Printf.printf "unknown grab_enum: %d\n" n; None;;
let grab_int_of_enum : grab_enum -> int = function `Any -> 0;;
let encode_grab_key ~(owner_events : bool) ~(grab_window : window) ~(modifiers : mod_mask) ~(key : grab_enum alt_enum) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 33 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
let* at = encode_alt_enum encode_keycode identity grab_int_of_enum buf key ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf keyboard_mode ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_ungrab_key ~(key : grab_enum alt_enum) ~(grab_window : window) ~(modifiers : mod_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 34 ~at in
let* at = encode_alt_enum encode_keycode identity grab_int_of_enum buf key ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type allow_enum = [ `Async_pointer | `Sync_pointer | `Replay_pointer | `Async_keyboard | `Sync_keyboard | `Replay_keyboard | `Async_both | `Sync_both ] [@@deriving sexp];;
let allow_enum_of_int : int -> [> allow_enum ] option = function 0 -> Some `Async_pointer | 1 -> Some `Sync_pointer | 2 -> Some `Replay_pointer | 3 -> Some `Async_keyboard | 4 -> Some `Sync_keyboard | 5 -> Some `Replay_keyboard | 6 -> Some `Async_both | 7 -> Some `Sync_both | n -> Printf.printf "unknown allow_enum: %d\n" n; None;;
let allow_int_of_enum : allow_enum -> int = function `Async_pointer -> 0 | `Sync_pointer -> 1 | `Replay_pointer -> 2 | `Async_keyboard -> 3 | `Sync_keyboard -> 4 | `Replay_keyboard -> 5 | `Async_both -> 6 | `Sync_both -> 7;;
let encode_allow_events ~(mode : allow_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 35 ~at in
let* at = encode_enum encode_uint8 identity allow_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_grab_server  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 36 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_ungrab_server  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 37 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type query_pointer_reply = { same_screen : bool; root : window; child : window_enum alt_enum; root_x : int; root_y : int; win_x : int; win_y : int; mask : key_but_mask; } [@@deriving sexp];;
let encode_query_pointer ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 38 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_pointer_reply length buf ~at : (query_pointer_reply * int) option = let orig = at in let at = at + 1 in
let* same_screen, at = decode_bool buf ~at in
let at = at + 6 in
let* root, at = decode_window buf ~at in
let* child, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
let* root_x, at = decode_int16 buf ~at in
let* root_y, at = decode_int16 buf ~at in
let* win_x, at = decode_int16 buf ~at in
let* win_y, at = decode_int16 buf ~at in
let* mask, at = decode_mask decode_uint16 Int64.of_int key_but_mask_mask_of_int64 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ same_screen; root; child; root_x; root_y; win_x; win_y; mask }, at);;
type timecoord = { time : timestamp; x : int; y : int; } [@@deriving sexp];;
let decode_timecoord buf ~at : (timecoord * int) option = let orig = at in let* time, at = decode_timestamp buf ~at in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
ignore orig;
Some ({ time; x; y }, at);;
let encode_timecoord buf (v : timecoord) ~at : int option = let orig = at in let* at = encode_timestamp buf v.time ~at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in ignore orig; Some at;;

type get_motion_events_reply = { events : timecoord list; } [@@deriving sexp];;
let encode_get_motion_events ~(window : window) ~(start : time_enum alt_enum) ~(stop : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 39 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf start ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf stop ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_motion_events_reply length buf ~at : (get_motion_events_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* events_len, at = decode_int32 buf ~at in let events_len = events_len in
let at = at + 20 in
let* events, at = decode_list (decode_timecoord) events_len buf ~at in
ignore orig;
Some ({ events }, at);;
type translate_coordinates_reply = { same_screen : bool; child : window_enum alt_enum; dst_x : int; dst_y : int; } [@@deriving sexp];;
let encode_translate_coordinates ~(src_window : window) ~(dst_window : window) ~(src_x : int) ~(src_y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 40 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf src_window ~at in
let* at = encode_window buf dst_window ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_translate_coordinates_reply length buf ~at : (translate_coordinates_reply * int) option = let orig = at in let at = at + 1 in
let* same_screen, at = decode_bool buf ~at in
let at = at + 6 in
let* child, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
let* dst_x, at = decode_int16 buf ~at in
let* dst_y, at = decode_int16 buf ~at in
ignore orig;
Some ({ same_screen; child; dst_x; dst_y }, at);;
let encode_warp_pointer ~(src_window : window_enum alt_enum) ~(dst_window : window_enum alt_enum) ~(src_x : int) ~(src_y : int) ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 41 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf src_window ~at in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf dst_window ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_uint16 buf src_width ~at in
let* at = encode_uint16 buf src_height ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type input_focus_enum = [ `None | `Pointer_root | `Parent | `Follow_keyboard ] [@@deriving sexp];;
let input_focus_enum_of_int : int -> [> input_focus_enum ] option = function 0 -> Some `None | 1 -> Some `Pointer_root | 2 -> Some `Parent | 3 -> Some `Follow_keyboard | n -> Printf.printf "unknown input_focus_enum: %d\n" n; None;;
let input_focus_int_of_enum : input_focus_enum -> int = function `None -> 0 | `Pointer_root -> 1 | `Parent -> 2 | `Follow_keyboard -> 3;;
let encode_set_input_focus ~(revert_to : input_focus_enum) ~(focus : input_focus_enum alt_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 42 ~at in
let* at = encode_enum encode_uint8 identity input_focus_int_of_enum buf revert_to ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity input_focus_int_of_enum buf focus ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_input_focus_reply = { revert_to : input_focus_enum; focus : input_focus_enum alt_enum; } [@@deriving sexp];;
let encode_get_input_focus  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 43 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_input_focus_reply length buf ~at : (get_input_focus_reply * int) option = let orig = at in let at = at + 1 in
let* revert_to, at = decode_enum decode_uint8 identity input_focus_enum_of_int buf ~at in
let at = at + 6 in
let* focus, at = decode_alt_enum decode_window identity input_focus_enum_of_int buf ~at in
ignore orig;
Some ({ revert_to; focus }, at);;
type query_keymap_reply = { keys : int list; } [@@deriving sexp];;
let encode_query_keymap  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 44 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_keymap_reply length buf ~at : (query_keymap_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* keys, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ keys }, at);;
let encode_open_font ~(fid : font) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 45 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_font buf fid ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_close_font ~(font : font)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 46 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_font buf font ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type font_draw_enum = [ `Left_to_right | `Right_to_left ] [@@deriving sexp];;
let font_draw_enum_of_int : int -> [> font_draw_enum ] option = function 0 -> Some `Left_to_right | 1 -> Some `Right_to_left | n -> Printf.printf "unknown font_draw_enum: %d\n" n; None;;
let font_draw_int_of_enum : font_draw_enum -> int = function `Left_to_right -> 0 | `Right_to_left -> 1;;
type fontprop = { name : atom; value : int; } [@@deriving sexp];;
let decode_fontprop buf ~at : (fontprop * int) option = let orig = at in let* name, at = decode_atom buf ~at in
let* value, at = decode_int32 buf ~at in
ignore orig;
Some ({ name; value }, at);;
let encode_fontprop buf (v : fontprop) ~at : int option = let orig = at in let* at = encode_atom buf v.name ~at in let* at = encode_int32 buf v.value ~at in ignore orig; Some at;;

type charinfo = { left_side_bearing : int; right_side_bearing : int; character_width : int; ascent : int; descent : int; attributes : int; } [@@deriving sexp];;
let decode_charinfo buf ~at : (charinfo * int) option = let orig = at in let* left_side_bearing, at = decode_int16 buf ~at in
let* right_side_bearing, at = decode_int16 buf ~at in
let* character_width, at = decode_int16 buf ~at in
let* ascent, at = decode_int16 buf ~at in
let* descent, at = decode_int16 buf ~at in
let* attributes, at = decode_uint16 buf ~at in
ignore orig;
Some ({ left_side_bearing; right_side_bearing; character_width; ascent; descent; attributes }, at);;
let encode_charinfo buf (v : charinfo) ~at : int option = let orig = at in let* at = encode_int16 buf v.left_side_bearing ~at in let* at = encode_int16 buf v.right_side_bearing ~at in let* at = encode_int16 buf v.character_width ~at in let* at = encode_int16 buf v.ascent ~at in let* at = encode_int16 buf v.descent ~at in let* at = encode_uint16 buf v.attributes ~at in ignore orig; Some at;;

type query_font_reply = { min_bounds : charinfo; max_bounds : charinfo; min_char_or_byte2 : int; max_char_or_byte2 : int; default_char : int; draw_direction : font_draw_enum; min_byte1 : int; max_byte1 : int; all_chars_exist : bool; font_ascent : int; font_descent : int; properties : fontprop list; char_infos : charinfo list; } [@@deriving sexp];;
let encode_query_font ~(font : fontable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 47 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fontable buf font ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_font_reply length buf ~at : (query_font_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* min_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* max_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* min_char_or_byte2, at = decode_uint16 buf ~at in
let* max_char_or_byte2, at = decode_uint16 buf ~at in
let* default_char, at = decode_uint16 buf ~at in
let* properties_len, at = decode_uint16 buf ~at in let properties_len = properties_len in
let* draw_direction, at = decode_enum decode_char Char.code font_draw_enum_of_int buf ~at in
let* min_byte1, at = decode_uint8 buf ~at in
let* max_byte1, at = decode_uint8 buf ~at in
let* all_chars_exist, at = decode_bool buf ~at in
let* font_ascent, at = decode_int16 buf ~at in
let* font_descent, at = decode_int16 buf ~at in
let* char_infos_len, at = decode_int32 buf ~at in let char_infos_len = char_infos_len in
let* properties, at = decode_list (decode_fontprop) properties_len buf ~at in
let* char_infos, at = decode_list (decode_charinfo) char_infos_len buf ~at in
ignore orig;
Some ({ min_bounds; max_bounds; min_char_or_byte2; max_char_or_byte2; default_char; draw_direction; min_byte1; max_byte1; all_chars_exist; font_ascent; font_descent; properties; char_infos }, at);;

type str = { name : string; } [@@deriving sexp];;
let decode_str buf ~at : (str * int) option = let orig = at in let* name_len, at = decode_uint8 buf ~at in let name_len = name_len in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ name }, at);;
let encode_str buf (v : str) ~at : int option = let orig = at in let* at = encode_uint8 buf (identity (String.length v.name)) ~at in let* at = encode_string buf v.name ~at in ignore orig; Some at;;

type list_fonts_reply = { names : str list; } [@@deriving sexp];;
let encode_list_fonts ~(max_names : int) ~(pattern : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 49 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf max_names ~at in
let* at = encode_uint16 buf (identity (String.length pattern)) ~at in
let* at = encode_string buf pattern ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_list_fonts_reply length buf ~at : (list_fonts_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* names_len, at = decode_uint16 buf ~at in let names_len = names_len in
let at = at + 22 in
let* names, at = decode_list (decode_str) names_len buf ~at in
ignore orig;
Some ({ names }, at);;
type list_fonts_with_info_reply = { min_bounds : charinfo; max_bounds : charinfo; min_char_or_byte2 : int; max_char_or_byte2 : int; default_char : int; draw_direction : font_draw_enum; min_byte1 : int; max_byte1 : int; all_chars_exist : bool; font_ascent : int; font_descent : int; replies_hint : int; properties : fontprop list; name : string; } [@@deriving sexp];;
let encode_list_fonts_with_info ~(max_names : int) ~(pattern : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 50 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf max_names ~at in
let* at = encode_uint16 buf (identity (String.length pattern)) ~at in
let* at = encode_string buf pattern ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_list_fonts_with_info_reply length buf ~at : (list_fonts_with_info_reply * int) option = let orig = at in let at = at + 1 in
let* name_len, at = decode_uint8 buf ~at in let name_len = name_len in
let at = at + 6 in
let* min_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* max_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* min_char_or_byte2, at = decode_uint16 buf ~at in
let* max_char_or_byte2, at = decode_uint16 buf ~at in
let* default_char, at = decode_uint16 buf ~at in
let* properties_len, at = decode_uint16 buf ~at in let properties_len = properties_len in
let* draw_direction, at = decode_enum decode_char Char.code font_draw_enum_of_int buf ~at in
let* min_byte1, at = decode_uint8 buf ~at in
let* max_byte1, at = decode_uint8 buf ~at in
let* all_chars_exist, at = decode_bool buf ~at in
let* font_ascent, at = decode_int16 buf ~at in
let* font_descent, at = decode_int16 buf ~at in
let* replies_hint, at = decode_int32 buf ~at in
let* properties, at = decode_list (decode_fontprop) properties_len buf ~at in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ min_bounds; max_bounds; min_char_or_byte2; max_char_or_byte2; default_char; draw_direction; min_byte1; max_byte1; all_chars_exist; font_ascent; font_descent; replies_hint; properties; name }, at);;
let encode_set_font_path ~(font : str list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 51 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length font)) ~at in
let at = at + 2 in
let* at = encode_list encode_str buf font ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_font_path_reply = { path : str list; } [@@deriving sexp];;
let encode_get_font_path  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 52 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_font_path_reply length buf ~at : (get_font_path_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* path_len, at = decode_uint16 buf ~at in let path_len = path_len in
let at = at + 22 in
let* path, at = decode_list (decode_str) path_len buf ~at in
ignore orig;
Some ({ path }, at);;
let encode_create_pixmap ~(depth : int) ~(pid : pixmap) ~(drawable : drawable) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 53 ~at in
let* at = encode_uint8 buf depth ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pixmap buf pid ~at in
let* at = encode_drawable buf drawable ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_free_pixmap ~(pixmap : pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 54 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pixmap buf pixmap ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type gc_mask = [ `Function | `Plane_mask | `Foreground | `Background | `Line_width | `Line_style | `Cap_style | `Join_style | `Fill_style | `Fill_rule | `Tile | `Stipple | `Tile_stipple_origin_x | `Tile_stipple_origin_y | `Font | `Subwindow_mode | `Graphics_exposures | `Clip_origin_x | `Clip_origin_y | `Clip_mask | `Dash_offset | `Dash_list | `Arc_mode ] list [@@deriving sexp];;
let gc_mask_of_int64 mask : gc_mask option = let of_int = function 0 -> Some `Function | 1 -> Some `Plane_mask | 2 -> Some `Foreground | 3 -> Some `Background | 4 -> Some `Line_width | 5 -> Some `Line_style | 6 -> Some `Cap_style | 7 -> Some `Join_style | 8 -> Some `Fill_style | 9 -> Some `Fill_rule | 10 -> Some `Tile | 11 -> Some `Stipple | 12 -> Some `Tile_stipple_origin_x | 13 -> Some `Tile_stipple_origin_y | 14 -> Some `Font | 15 -> Some `Subwindow_mode | 16 -> Some `Graphics_exposures | 17 -> Some `Clip_origin_x | 18 -> Some `Clip_origin_y | 19 -> Some `Clip_mask | 20 -> Some `Dash_offset | 21 -> Some `Dash_list | 22 -> Some `Arc_mode | _ -> None in mask_of_int of_int mask;;
let gc_int_of_mask : gc_mask -> int = let to_bit = function `Function -> 0 | `Plane_mask -> 1 | `Foreground -> 2 | `Background -> 3 | `Line_width -> 4 | `Line_style -> 5 | `Cap_style -> 6 | `Join_style -> 7 | `Fill_style -> 8 | `Fill_rule -> 9 | `Tile -> 10 | `Stipple -> 11 | `Tile_stipple_origin_x -> 12 | `Tile_stipple_origin_y -> 13 | `Font -> 14 | `Subwindow_mode -> 15 | `Graphics_exposures -> 16 | `Clip_origin_x -> 17 | `Clip_origin_y -> 18 | `Clip_mask -> 19 | `Dash_offset -> 20 | `Dash_list -> 21 | `Arc_mode -> 22 in int_of_mask to_bit;;
type gx_enum = [ `Clear | `And | `And_reverse | `Copy | `And_inverted | `Noop | `Xor | `Or | `Nor | `Equiv | `Invert | `Or_reverse | `Copy_inverted | `Or_inverted | `Nand | `Set ] [@@deriving sexp];;
let gx_enum_of_int : int -> [> gx_enum ] option = function 0 -> Some `Clear | 1 -> Some `And | 2 -> Some `And_reverse | 3 -> Some `Copy | 4 -> Some `And_inverted | 5 -> Some `Noop | 6 -> Some `Xor | 7 -> Some `Or | 8 -> Some `Nor | 9 -> Some `Equiv | 10 -> Some `Invert | 11 -> Some `Or_reverse | 12 -> Some `Copy_inverted | 13 -> Some `Or_inverted | 14 -> Some `Nand | 15 -> Some `Set | n -> Printf.printf "unknown gx_enum: %d\n" n; None;;
let gx_int_of_enum : gx_enum -> int = function `Clear -> 0 | `And -> 1 | `And_reverse -> 2 | `Copy -> 3 | `And_inverted -> 4 | `Noop -> 5 | `Xor -> 6 | `Or -> 7 | `Nor -> 8 | `Equiv -> 9 | `Invert -> 10 | `Or_reverse -> 11 | `Copy_inverted -> 12 | `Or_inverted -> 13 | `Nand -> 14 | `Set -> 15;;
type line_style_enum = [ `Solid | `On_off_dash | `Double_dash ] [@@deriving sexp];;
let line_style_enum_of_int : int -> [> line_style_enum ] option = function 0 -> Some `Solid | 1 -> Some `On_off_dash | 2 -> Some `Double_dash | n -> Printf.printf "unknown line_style_enum: %d\n" n; None;;
let line_style_int_of_enum : line_style_enum -> int = function `Solid -> 0 | `On_off_dash -> 1 | `Double_dash -> 2;;
type cap_style_enum = [ `Not_last | `Butt | `Round | `Projecting ] [@@deriving sexp];;
let cap_style_enum_of_int : int -> [> cap_style_enum ] option = function 0 -> Some `Not_last | 1 -> Some `Butt | 2 -> Some `Round | 3 -> Some `Projecting | n -> Printf.printf "unknown cap_style_enum: %d\n" n; None;;
let cap_style_int_of_enum : cap_style_enum -> int = function `Not_last -> 0 | `Butt -> 1 | `Round -> 2 | `Projecting -> 3;;
type join_style_enum = [ `Miter | `Round | `Bevel ] [@@deriving sexp];;
let join_style_enum_of_int : int -> [> join_style_enum ] option = function 0 -> Some `Miter | 1 -> Some `Round | 2 -> Some `Bevel | n -> Printf.printf "unknown join_style_enum: %d\n" n; None;;
let join_style_int_of_enum : join_style_enum -> int = function `Miter -> 0 | `Round -> 1 | `Bevel -> 2;;
type fill_style_enum = [ `Solid | `Tiled | `Stippled | `Opaque_stippled ] [@@deriving sexp];;
let fill_style_enum_of_int : int -> [> fill_style_enum ] option = function 0 -> Some `Solid | 1 -> Some `Tiled | 2 -> Some `Stippled | 3 -> Some `Opaque_stippled | n -> Printf.printf "unknown fill_style_enum: %d\n" n; None;;
let fill_style_int_of_enum : fill_style_enum -> int = function `Solid -> 0 | `Tiled -> 1 | `Stippled -> 2 | `Opaque_stippled -> 3;;
type fill_rule_enum = [ `Even_odd | `Winding ] [@@deriving sexp];;
let fill_rule_enum_of_int : int -> [> fill_rule_enum ] option = function 0 -> Some `Even_odd | 1 -> Some `Winding | n -> Printf.printf "unknown fill_rule_enum: %d\n" n; None;;
let fill_rule_int_of_enum : fill_rule_enum -> int = function `Even_odd -> 0 | `Winding -> 1;;
type subwindow_mode_enum = [ `Clip_by_children | `Include_inferiors ] [@@deriving sexp];;
let subwindow_mode_enum_of_int : int -> [> subwindow_mode_enum ] option = function 0 -> Some `Clip_by_children | 1 -> Some `Include_inferiors | n -> Printf.printf "unknown subwindow_mode_enum: %d\n" n; None;;
let subwindow_mode_int_of_enum : subwindow_mode_enum -> int = function `Clip_by_children -> 0 | `Include_inferiors -> 1;;
type arc_mode_enum = [ `Chord | `Pie_slice ] [@@deriving sexp];;
let arc_mode_enum_of_int : int -> [> arc_mode_enum ] option = function 0 -> Some `Chord | 1 -> Some `Pie_slice | n -> Printf.printf "unknown arc_mode_enum: %d\n" n; None;;
let arc_mode_int_of_enum : arc_mode_enum -> int = function `Chord -> 0 | `Pie_slice -> 1;;
type font_enum = [ `None ] [@@deriving sexp];;
let font_enum_of_int : int -> [> font_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown font_enum: %d\n" n; None;;
let font_int_of_enum : font_enum -> int = function `None -> 0;;
let encode_create_gc ~(cid : gcontext) ~(drawable : drawable) ?(function_ : gx_enum option) ?(plane_mask : int option) ?(foreground : int option) ?(background : int option) ?(line_width : int option) ?(line_style : line_style_enum option) ?(cap_style : cap_style_enum option) ?(join_style : join_style_enum option) ?(fill_style : fill_style_enum option) ?(fill_rule : fill_rule_enum option) ?(tile : pixmap_enum alt_enum option) ?(stipple : pixmap_enum alt_enum option) ?(tile_stipple_x_origin : int option) ?(tile_stipple_y_origin : int option) ?(font : font_enum alt_enum option) ?(subwindow_mode : subwindow_mode_enum option) ?(graphics_exposures : bool32 option) ?(clip_x_origin : int option) ?(clip_y_origin : int option) ?(clip_mask : pixmap_enum alt_enum option) ?(dash_offset : int option) ?(dashes : int option) ?(arc_mode : arc_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 55 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf cid ~at in
let* at = encode_drawable buf drawable ~at in
(* field_optional_mask *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_change_gc ~(gc : gcontext) ?(function_ : gx_enum option) ?(plane_mask : int option) ?(foreground : int option) ?(background : int option) ?(line_width : int option) ?(line_style : line_style_enum option) ?(cap_style : cap_style_enum option) ?(join_style : join_style_enum option) ?(fill_style : fill_style_enum option) ?(fill_rule : fill_rule_enum option) ?(tile : pixmap_enum alt_enum option) ?(stipple : pixmap_enum alt_enum option) ?(tile_stipple_x_origin : int option) ?(tile_stipple_y_origin : int option) ?(font : font_enum alt_enum option) ?(subwindow_mode : subwindow_mode_enum option) ?(graphics_exposures : bool32 option) ?(clip_x_origin : int option) ?(clip_y_origin : int option) ?(clip_mask : pixmap_enum alt_enum option) ?(dash_offset : int option) ?(dashes : int option) ?(arc_mode : arc_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 56 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
(* field_optional_mask *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_copy_gc ~(src_gc : gcontext) ~(dst_gc : gcontext) ~(value_mask : gc_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 57 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf src_gc ~at in
let* at = encode_gcontext buf dst_gc ~at in
let* at = encode_mask encode_int32 identity gc_int_of_mask buf value_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_set_dashes ~(gc : gcontext) ~(dash_offset : int) ~(dashes : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 58 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
let* at = encode_uint16 buf dash_offset ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card8 *) List.length dashes)) ~at in
let* at = encode_list encode_uint8 buf dashes ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type clip_ordering_enum = [ `Unsorted | `Y_sorted | `Yx_sorted | `Yx_banded ] [@@deriving sexp];;
let clip_ordering_enum_of_int : int -> [> clip_ordering_enum ] option = function 0 -> Some `Unsorted | 1 -> Some `Y_sorted | 2 -> Some `Yx_sorted | 3 -> Some `Yx_banded | n -> Printf.printf "unknown clip_ordering_enum: %d\n" n; None;;
let clip_ordering_int_of_enum : clip_ordering_enum -> int = function `Unsorted -> 0 | `Y_sorted -> 1 | `Yx_sorted -> 2 | `Yx_banded -> 3;;
let encode_set_clip_rectangles ~(ordering : clip_ordering_enum) ~(gc : gcontext) ~(clip_x_origin : int) ~(clip_y_origin : int) ~(rectangles : rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 59 ~at in
let* at = encode_enum encode_char Char.chr clip_ordering_int_of_enum buf ordering ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf clip_x_origin ~at in
let* at = encode_int16 buf clip_y_origin ~at in
let* at = encode_list encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_free_gc ~(gc : gcontext)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 60 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_clear_area ~(exposures : bool) ~(window : window) ~(x : int) ~(y : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 61 ~at in
let* at = encode_bool buf exposures ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_copy_area ~(src_drawable : drawable) ~(dst_drawable : drawable) ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 62 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf src_drawable ~at in
let* at = encode_drawable buf dst_drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_copy_plane ~(src_drawable : drawable) ~(dst_drawable : drawable) ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int) ~(bit_plane : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 63 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf src_drawable ~at in
let* at = encode_drawable buf dst_drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf bit_plane ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type coord_mode_enum = [ `Origin | `Previous ] [@@deriving sexp];;
let coord_mode_enum_of_int : int -> [> coord_mode_enum ] option = function 0 -> Some `Origin | 1 -> Some `Previous | n -> Printf.printf "unknown coord_mode_enum: %d\n" n; None;;
let coord_mode_int_of_enum : coord_mode_enum -> int = function `Origin -> 0 | `Previous -> 1;;
let encode_poly_point ~(coordinate_mode : coord_mode_enum) ~(drawable : drawable) ~(gc : gcontext) ~(points : point list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 64 ~at in
let* at = encode_enum encode_char Char.chr coord_mode_int_of_enum buf coordinate_mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_point buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_poly_line ~(coordinate_mode : coord_mode_enum) ~(drawable : drawable) ~(gc : gcontext) ~(points : point list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 65 ~at in
let* at = encode_enum encode_char Char.chr coord_mode_int_of_enum buf coordinate_mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_point buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type segment = { x1 : int; y1 : int; x2 : int; y2 : int; } [@@deriving sexp];;
let decode_segment buf ~at : (segment * int) option = let orig = at in let* x1, at = decode_int16 buf ~at in
let* y1, at = decode_int16 buf ~at in
let* x2, at = decode_int16 buf ~at in
let* y2, at = decode_int16 buf ~at in
ignore orig;
Some ({ x1; y1; x2; y2 }, at);;
let encode_segment buf (v : segment) ~at : int option = let orig = at in let* at = encode_int16 buf v.x1 ~at in let* at = encode_int16 buf v.y1 ~at in let* at = encode_int16 buf v.x2 ~at in let* at = encode_int16 buf v.y2 ~at in ignore orig; Some at;;

let encode_poly_segment ~(drawable : drawable) ~(gc : gcontext) ~(segments : segment list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 66 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_segment buf segments ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_poly_rectangle ~(drawable : drawable) ~(gc : gcontext) ~(rectangles : rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 67 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_poly_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 68 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_arc buf arcs ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type poly_shape_enum = [ `Complex | `Nonconvex | `Convex ] [@@deriving sexp];;
let poly_shape_enum_of_int : int -> [> poly_shape_enum ] option = function 0 -> Some `Complex | 1 -> Some `Nonconvex | 2 -> Some `Convex | n -> Printf.printf "unknown poly_shape_enum: %d\n" n; None;;
let poly_shape_int_of_enum : poly_shape_enum -> int = function `Complex -> 0 | `Nonconvex -> 1 | `Convex -> 2;;
let encode_fill_poly ~(drawable : drawable) ~(gc : gcontext) ~(shape : poly_shape_enum) ~(coordinate_mode : coord_mode_enum) ~(points : point list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 69 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_enum encode_uint8 identity poly_shape_int_of_enum buf shape ~at in
let* at = encode_enum encode_uint8 identity coord_mode_int_of_enum buf coordinate_mode ~at in
let at = at + 2 in
let* at = encode_list encode_point buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_poly_fill_rectangle ~(drawable : drawable) ~(gc : gcontext) ~(rectangles : rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 70 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_poly_fill_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 71 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_arc buf arcs ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type image_format_enum = [ `Xy_bitmap | `Xy_pixmap | `Z_pixmap ] [@@deriving sexp];;
let image_format_enum_of_int : int -> [> image_format_enum ] option = function 0 -> Some `Xy_bitmap | 1 -> Some `Xy_pixmap | 2 -> Some `Z_pixmap | n -> Printf.printf "unknown image_format_enum: %d\n" n; None;;
let image_format_int_of_enum : image_format_enum -> int = function `Xy_bitmap -> 0 | `Xy_pixmap -> 1 | `Z_pixmap -> 2;;
let encode_put_image ~(format : image_format_enum) ~(drawable : drawable) ~(gc : gcontext) ~(width : int) ~(height : int) ~(dst_x : int) ~(dst_y : int) ~(left_pad : int) ~(depth : int) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 72 ~at in
let* at = encode_enum encode_uint8 identity image_format_int_of_enum buf format ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint8 buf left_pad ~at in
let* at = encode_uint8 buf depth ~at in
let at = at + 2 in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_image_reply = { depth : int; visual : visualid; data : char list; } [@@deriving sexp];;
let encode_get_image ~(format : image_format_enum) ~(drawable : drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(plane_mask : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 73 ~at in
let* at = encode_enum encode_uint8 identity image_format_int_of_enum buf format ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf plane_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_image_reply length buf ~at : (get_image_reply * int) option = let orig = at in let at = at + 1 in
let* depth, at = decode_uint8 buf ~at in
let at = at + 6 in
let* visual, at = decode_visualid buf ~at in
let at = at + 20 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ depth; visual; data }, at);;
let encode_poly_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(items : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 74 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_list encode_char buf items ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_poly_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(items : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 75 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_list encode_char buf items ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_image_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(string : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 76 ~at in
let* at = encode_char buf (Char.chr (String.length string)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_string buf string ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_image_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(string : char2b list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 77 ~at in
let* at = encode_char buf (Char.chr ((* invalid_argument *) List.length string)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_list encode_char2b buf string ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type colormap_alloc_enum = [ `None | `All ] [@@deriving sexp];;
let colormap_alloc_enum_of_int : int -> [> colormap_alloc_enum ] option = function 0 -> Some `None | 1 -> Some `All | n -> Printf.printf "unknown colormap_alloc_enum: %d\n" n; None;;
let colormap_alloc_int_of_enum : colormap_alloc_enum -> int = function `None -> 0 | `All -> 1;;
let encode_create_colormap ~(alloc : colormap_alloc_enum) ~(mid : colormap) ~(window : window) ~(visual : visualid)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 78 ~at in
let* at = encode_enum encode_char Char.chr colormap_alloc_int_of_enum buf alloc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf mid ~at in
let* at = encode_window buf window ~at in
let* at = encode_visualid buf visual ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_free_colormap ~(cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 79 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_copy_colormap_and_free ~(mid : colormap) ~(src_cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 80 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf mid ~at in
let* at = encode_colormap buf src_cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_install_colormap ~(cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 81 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_uninstall_colormap ~(cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 82 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type list_installed_colormaps_reply = { cmaps : colormap list; } [@@deriving sexp];;
let encode_list_installed_colormaps ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 83 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_list_installed_colormaps_reply length buf ~at : (list_installed_colormaps_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* cmaps_len, at = decode_uint16 buf ~at in let cmaps_len = cmaps_len in
let at = at + 22 in
let* cmaps, at = decode_list (decode_colormap) cmaps_len buf ~at in
ignore orig;
Some ({ cmaps }, at);;
type alloc_color_reply = { red : int; green : int; blue : int; pixel : int; } [@@deriving sexp];;
let encode_alloc_color ~(cmap : colormap) ~(red : int) ~(green : int) ~(blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 84 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf red ~at in
let* at = encode_uint16 buf green ~at in
let* at = encode_uint16 buf blue ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_alloc_color_reply length buf ~at : (alloc_color_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let at = at + 2 in
let* pixel, at = decode_int32 buf ~at in
ignore orig;
Some ({ red; green; blue; pixel }, at);;
type alloc_named_color_reply = { pixel : int; exact_red : int; exact_green : int; exact_blue : int; visual_red : int; visual_green : int; visual_blue : int; } [@@deriving sexp];;
let encode_alloc_named_color ~(cmap : colormap) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 85 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_alloc_named_color_reply length buf ~at : (alloc_named_color_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pixel, at = decode_int32 buf ~at in
let* exact_red, at = decode_uint16 buf ~at in
let* exact_green, at = decode_uint16 buf ~at in
let* exact_blue, at = decode_uint16 buf ~at in
let* visual_red, at = decode_uint16 buf ~at in
let* visual_green, at = decode_uint16 buf ~at in
let* visual_blue, at = decode_uint16 buf ~at in
ignore orig;
Some ({ pixel; exact_red; exact_green; exact_blue; visual_red; visual_green; visual_blue }, at);;
type alloc_color_cells_reply = { pixels : int list; masks : int list; } [@@deriving sexp];;
let encode_alloc_color_cells ~(contiguous : bool) ~(cmap : colormap) ~(colors : int) ~(planes : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 86 ~at in
let* at = encode_bool buf contiguous ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf colors ~at in
let* at = encode_uint16 buf planes ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_alloc_color_cells_reply length buf ~at : (alloc_color_cells_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pixels_len, at = decode_uint16 buf ~at in let pixels_len = pixels_len in
let* masks_len, at = decode_uint16 buf ~at in let masks_len = masks_len in
let at = at + 20 in
let* pixels, at = decode_list (decode_int32) pixels_len buf ~at in
let* masks, at = decode_list (decode_int32) masks_len buf ~at in
ignore orig;
Some ({ pixels; masks }, at);;
type alloc_color_planes_reply = { red_mask : int; green_mask : int; blue_mask : int; pixels : int list; } [@@deriving sexp];;
let encode_alloc_color_planes ~(contiguous : bool) ~(cmap : colormap) ~(colors : int) ~(reds : int) ~(greens : int) ~(blues : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 87 ~at in
let* at = encode_bool buf contiguous ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf colors ~at in
let* at = encode_uint16 buf reds ~at in
let* at = encode_uint16 buf greens ~at in
let* at = encode_uint16 buf blues ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_alloc_color_planes_reply length buf ~at : (alloc_color_planes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pixels_len, at = decode_uint16 buf ~at in let pixels_len = pixels_len in
let at = at + 2 in
let* red_mask, at = decode_int32 buf ~at in
let* green_mask, at = decode_int32 buf ~at in
let* blue_mask, at = decode_int32 buf ~at in
let at = at + 8 in
let* pixels, at = decode_list (decode_int32) pixels_len buf ~at in
ignore orig;
Some ({ red_mask; green_mask; blue_mask; pixels }, at);;
let encode_free_colors ~(cmap : colormap) ~(plane_mask : int) ~(pixels : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 88 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_int32 buf plane_mask ~at in
let* at = encode_list encode_int32 buf pixels ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type color_flag_mask = [ `Red | `Green | `Blue ] list [@@deriving sexp];;
let color_flag_mask_of_int64 mask : color_flag_mask option = let of_int = function 0 -> Some `Red | 1 -> Some `Green | 2 -> Some `Blue | _ -> None in mask_of_int of_int mask;;
let color_flag_int_of_mask : color_flag_mask -> int = let to_bit = function `Red -> 0 | `Green -> 1 | `Blue -> 2 in int_of_mask to_bit;;
type coloritem = { pixel : int; red : int; green : int; blue : int; flags : color_flag_mask; } [@@deriving sexp];;
let decode_coloritem buf ~at : (coloritem * int) option = let orig = at in let* pixel, at = decode_int32 buf ~at in
let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let* flags, at = decode_mask decode_char char_to_int64 color_flag_mask_of_int64 buf ~at in
let at = at + 1 in
ignore orig;
Some ({ pixel; red; green; blue; flags }, at);;
let encode_coloritem buf (v : coloritem) ~at : int option = let orig = at in let* at = encode_int32 buf v.pixel ~at in let* at = encode_uint16 buf v.red ~at in let* at = encode_uint16 buf v.green ~at in let* at = encode_uint16 buf v.blue ~at in let* at = encode_mask encode_char Char.chr color_flag_int_of_mask buf v.flags ~at in let at = at + 1 in ignore orig; Some at;;

let encode_store_colors ~(cmap : colormap) ~(items : coloritem list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 89 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_list encode_coloritem buf items ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_store_named_color ~(flags : color_flag_mask) ~(cmap : colormap) ~(pixel : int) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 90 ~at in
let* at = encode_mask encode_uint8 identity color_flag_int_of_mask buf flags ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_int32 buf pixel ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type rgb = { red : int; green : int; blue : int; } [@@deriving sexp];;
let decode_rgb buf ~at : (rgb * int) option = let orig = at in let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ red; green; blue }, at);;
let encode_rgb buf (v : rgb) ~at : int option = let orig = at in let* at = encode_uint16 buf v.red ~at in let* at = encode_uint16 buf v.green ~at in let* at = encode_uint16 buf v.blue ~at in let at = at + 2 in ignore orig; Some at;;

type query_colors_reply = { colors : rgb list; } [@@deriving sexp];;
let encode_query_colors ~(cmap : colormap) ~(pixels : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 91 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_list encode_int32 buf pixels ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_colors_reply length buf ~at : (query_colors_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* colors_len, at = decode_uint16 buf ~at in let colors_len = colors_len in
let at = at + 22 in
let* colors, at = decode_list (decode_rgb) colors_len buf ~at in
ignore orig;
Some ({ colors }, at);;
type lookup_color_reply = { exact_red : int; exact_green : int; exact_blue : int; visual_red : int; visual_green : int; visual_blue : int; } [@@deriving sexp];;
let encode_lookup_color ~(cmap : colormap) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 92 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_lookup_color_reply length buf ~at : (lookup_color_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* exact_red, at = decode_uint16 buf ~at in
let* exact_green, at = decode_uint16 buf ~at in
let* exact_blue, at = decode_uint16 buf ~at in
let* visual_red, at = decode_uint16 buf ~at in
let* visual_green, at = decode_uint16 buf ~at in
let* visual_blue, at = decode_uint16 buf ~at in
ignore orig;
Some ({ exact_red; exact_green; exact_blue; visual_red; visual_green; visual_blue }, at);;
let encode_create_cursor ~(cid : cursor) ~(source : pixmap) ~(mask : pixmap_enum alt_enum) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int) ~(x : int) ~(y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 93 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cid ~at in
let* at = encode_pixmap buf source ~at in
let* at = encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf mask ~at in
let* at = encode_uint16 buf fore_red ~at in
let* at = encode_uint16 buf fore_green ~at in
let* at = encode_uint16 buf fore_blue ~at in
let* at = encode_uint16 buf back_red ~at in
let* at = encode_uint16 buf back_green ~at in
let* at = encode_uint16 buf back_blue ~at in
let* at = encode_uint16 buf x ~at in
let* at = encode_uint16 buf y ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_create_glyph_cursor ~(cid : cursor) ~(source_font : font) ~(mask_font : font_enum alt_enum) ~(source_char : int) ~(mask_char : int) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 94 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cid ~at in
let* at = encode_font buf source_font ~at in
let* at = encode_alt_enum encode_font identity font_int_of_enum buf mask_font ~at in
let* at = encode_uint16 buf source_char ~at in
let* at = encode_uint16 buf mask_char ~at in
let* at = encode_uint16 buf fore_red ~at in
let* at = encode_uint16 buf fore_green ~at in
let* at = encode_uint16 buf fore_blue ~at in
let* at = encode_uint16 buf back_red ~at in
let* at = encode_uint16 buf back_green ~at in
let* at = encode_uint16 buf back_blue ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_free_cursor ~(cursor : cursor)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 95 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cursor ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_recolor_cursor ~(cursor : cursor) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 96 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cursor ~at in
let* at = encode_uint16 buf fore_red ~at in
let* at = encode_uint16 buf fore_green ~at in
let* at = encode_uint16 buf fore_blue ~at in
let* at = encode_uint16 buf back_red ~at in
let* at = encode_uint16 buf back_green ~at in
let* at = encode_uint16 buf back_blue ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type query_shape_of_enum = [ `Largest_cursor | `Fastest_tile | `Fastest_stipple ] [@@deriving sexp];;
let query_shape_of_enum_of_int : int -> [> query_shape_of_enum ] option = function 0 -> Some `Largest_cursor | 1 -> Some `Fastest_tile | 2 -> Some `Fastest_stipple | n -> Printf.printf "unknown query_shape_of_enum: %d\n" n; None;;
let query_shape_of_int_of_enum : query_shape_of_enum -> int = function `Largest_cursor -> 0 | `Fastest_tile -> 1 | `Fastest_stipple -> 2;;
type query_best_size_reply = { width : int; height : int; } [@@deriving sexp];;
let encode_query_best_size ~(class_ : query_shape_of_enum) ~(drawable : drawable) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 97 ~at in
let* at = encode_enum encode_uint8 identity query_shape_of_int_of_enum buf class_ ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_best_size_reply length buf ~at : (query_best_size_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ width; height }, at);;
type query_extension_reply = { present : bool; major_opcode : int; first_event : int; first_error : int; } [@@deriving sexp];;
let encode_query_extension ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 98 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_query_extension_reply length buf ~at : (query_extension_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* present, at = decode_bool buf ~at in
let* major_opcode, at = decode_uint8 buf ~at in
let* first_event, at = decode_uint8 buf ~at in
let* first_error, at = decode_uint8 buf ~at in
ignore orig;
Some ({ present; major_opcode; first_event; first_error }, at);;
type list_extensions_reply = { names : str list; } [@@deriving sexp];;
let encode_list_extensions  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 99 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_list_extensions_reply length buf ~at : (list_extensions_reply * int) option = let orig = at in let at = at + 1 in
let* names_len, at = decode_uint8 buf ~at in let names_len = names_len in
let at = at + 6 in
let at = at + 24 in
let* names, at = decode_list (decode_str) names_len buf ~at in
ignore orig;
Some ({ names }, at);;
let encode_change_keyboard_mapping ~(keycode_count : int) ~(first_keycode : keycode) ~(keysyms_per_keycode : int) ~(keysyms : keysym list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 100 ~at in
let* at = encode_uint8 buf keycode_count ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_keycode buf first_keycode ~at in
let* at = encode_uint8 buf keysyms_per_keycode ~at in
let at = at + 2 in
let* at = encode_list encode_keysym buf keysyms ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_keyboard_mapping_reply = { keysyms_per_keycode : char; keysyms : keysym list; } [@@deriving sexp];;
let encode_get_keyboard_mapping ~(first_keycode : keycode) ~(count : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 101 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_keycode buf first_keycode ~at in
let* at = encode_uint8 buf count ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_keyboard_mapping_reply length buf ~at : (get_keyboard_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* keysyms_per_keycode, at = decode_char buf ~at in
let at = at + 6 in
let at = at + 24 in
let* keysyms, at = let length = length in decode_list (decode_keysym) length buf ~at in
ignore orig;
Some ({ keysyms_per_keycode; keysyms }, at);;
type kb_mask = [ `Key_click_percent | `Bell_percent | `Bell_pitch | `Bell_duration | `Led | `Led_mode | `Key | `Auto_repeat_mode ] list [@@deriving sexp];;
let kb_mask_of_int64 mask : kb_mask option = let of_int = function 0 -> Some `Key_click_percent | 1 -> Some `Bell_percent | 2 -> Some `Bell_pitch | 3 -> Some `Bell_duration | 4 -> Some `Led | 5 -> Some `Led_mode | 6 -> Some `Key | 7 -> Some `Auto_repeat_mode | _ -> None in mask_of_int of_int mask;;
let kb_int_of_mask : kb_mask -> int = let to_bit = function `Key_click_percent -> 0 | `Bell_percent -> 1 | `Bell_pitch -> 2 | `Bell_duration -> 3 | `Led -> 4 | `Led_mode -> 5 | `Key -> 6 | `Auto_repeat_mode -> 7 in int_of_mask to_bit;;
type led_mode_enum = [ `Off | `On ] [@@deriving sexp];;
let led_mode_enum_of_int : int -> [> led_mode_enum ] option = function 0 -> Some `Off | 1 -> Some `On | n -> Printf.printf "unknown led_mode_enum: %d\n" n; None;;
let led_mode_int_of_enum : led_mode_enum -> int = function `Off -> 0 | `On -> 1;;
type auto_repeat_mode_enum = [ `Off | `On | `Default ] [@@deriving sexp];;
let auto_repeat_mode_enum_of_int : int -> [> auto_repeat_mode_enum ] option = function 0 -> Some `Off | 1 -> Some `On | 2 -> Some `Default | n -> Printf.printf "unknown auto_repeat_mode_enum: %d\n" n; None;;
let auto_repeat_mode_int_of_enum : auto_repeat_mode_enum -> int = function `Off -> 0 | `On -> 1 | `Default -> 2;;
let encode_change_keyboard_control ?(key_click_percent : int option) ?(bell_percent : int option) ?(bell_pitch : int option) ?(bell_duration : int option) ?(led : int option) ?(led_mode : led_mode_enum option) ?(key : keycode32 option) ?(auto_repeat_mode : auto_repeat_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 102 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
(* field_optional_mask *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_keyboard_control_reply = { global_auto_repeat : auto_repeat_mode_enum; led_mask : int; key_click_percent : int; bell_percent : int; bell_pitch : int; bell_duration : int; auto_repeats : int list; } [@@deriving sexp];;
let encode_get_keyboard_control  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 103 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_keyboard_control_reply length buf ~at : (get_keyboard_control_reply * int) option = let orig = at in let at = at + 1 in
let* global_auto_repeat, at = decode_enum decode_char Char.code auto_repeat_mode_enum_of_int buf ~at in
let at = at + 6 in
let* led_mask, at = decode_int32 buf ~at in
let* key_click_percent, at = decode_uint8 buf ~at in
let* bell_percent, at = decode_uint8 buf ~at in
let* bell_pitch, at = decode_uint16 buf ~at in
let* bell_duration, at = decode_uint16 buf ~at in
let at = at + 2 in
let* auto_repeats, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ global_auto_repeat; led_mask; key_click_percent; bell_percent; bell_pitch; bell_duration; auto_repeats }, at);;
let encode_bell ~(percent : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 104 ~at in
let* at = encode_int8 buf percent ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_change_pointer_control ~(acceleration_numerator : int) ~(acceleration_denominator : int) ~(threshold : int) ~(do_acceleration : bool) ~(do_threshold : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 105 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf acceleration_numerator ~at in
let* at = encode_int16 buf acceleration_denominator ~at in
let* at = encode_int16 buf threshold ~at in
let* at = encode_bool buf do_acceleration ~at in
let* at = encode_bool buf do_threshold ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_pointer_control_reply = { acceleration_numerator : int; acceleration_denominator : int; threshold : int; } [@@deriving sexp];;
let encode_get_pointer_control  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 106 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_pointer_control_reply length buf ~at : (get_pointer_control_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* acceleration_numerator, at = decode_uint16 buf ~at in
let* acceleration_denominator, at = decode_uint16 buf ~at in
let* threshold, at = decode_uint16 buf ~at in
let at = at + 18 in
ignore orig;
Some ({ acceleration_numerator; acceleration_denominator; threshold }, at);;
type blanking_enum = [ `Not_preferred | `Preferred | `Default ] [@@deriving sexp];;
let blanking_enum_of_int : int -> [> blanking_enum ] option = function 0 -> Some `Not_preferred | 1 -> Some `Preferred | 2 -> Some `Default | n -> Printf.printf "unknown blanking_enum: %d\n" n; None;;
let blanking_int_of_enum : blanking_enum -> int = function `Not_preferred -> 0 | `Preferred -> 1 | `Default -> 2;;
type exposures_enum = [ `Not_allowed | `Allowed | `Default ] [@@deriving sexp];;
let exposures_enum_of_int : int -> [> exposures_enum ] option = function 0 -> Some `Not_allowed | 1 -> Some `Allowed | 2 -> Some `Default | n -> Printf.printf "unknown exposures_enum: %d\n" n; None;;
let exposures_int_of_enum : exposures_enum -> int = function `Not_allowed -> 0 | `Allowed -> 1 | `Default -> 2;;
let encode_set_screen_saver ~(timeout : int) ~(interval : int) ~(prefer_blanking : blanking_enum) ~(allow_exposures : exposures_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 107 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf timeout ~at in
let* at = encode_int16 buf interval ~at in
let* at = encode_enum encode_uint8 identity blanking_int_of_enum buf prefer_blanking ~at in
let* at = encode_enum encode_uint8 identity exposures_int_of_enum buf allow_exposures ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type get_screen_saver_reply = { timeout : int; interval : int; prefer_blanking : blanking_enum; allow_exposures : exposures_enum; } [@@deriving sexp];;
let encode_get_screen_saver  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 108 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_screen_saver_reply length buf ~at : (get_screen_saver_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* timeout, at = decode_uint16 buf ~at in
let* interval, at = decode_uint16 buf ~at in
let* prefer_blanking, at = decode_enum decode_char Char.code blanking_enum_of_int buf ~at in
let* allow_exposures, at = decode_enum decode_char Char.code exposures_enum_of_int buf ~at in
let at = at + 18 in
ignore orig;
Some ({ timeout; interval; prefer_blanking; allow_exposures }, at);;
type host_mode_enum = [ `Insert | `Delete ] [@@deriving sexp];;
let host_mode_enum_of_int : int -> [> host_mode_enum ] option = function 0 -> Some `Insert | 1 -> Some `Delete | n -> Printf.printf "unknown host_mode_enum: %d\n" n; None;;
let host_mode_int_of_enum : host_mode_enum -> int = function `Insert -> 0 | `Delete -> 1;;
type family_enum = [ `Internet | `Decnet | `Chaos | `Server_interpreted | `Internet6 ] [@@deriving sexp];;
let family_enum_of_int : int -> [> family_enum ] option = function 0 -> Some `Internet | 1 -> Some `Decnet | 2 -> Some `Chaos | 5 -> Some `Server_interpreted | 6 -> Some `Internet6 | n -> Printf.printf "unknown family_enum: %d\n" n; None;;
let family_int_of_enum : family_enum -> int = function `Internet -> 0 | `Decnet -> 1 | `Chaos -> 2 | `Server_interpreted -> 5 | `Internet6 -> 6;;
let encode_change_hosts ~(mode : host_mode_enum) ~(family : family_enum) ~(address : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 109 ~at in
let* at = encode_enum encode_uint8 identity host_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity family_int_of_enum buf family ~at in
let at = at + 1 in
let* at = encode_uint16 buf (identity ((* Parsetree.Byte *) List.length address)) ~at in
let* at = encode_list encode_char buf address ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type host = { family : family_enum; address : char list; } [@@deriving sexp];;
let decode_host buf ~at : (host * int) option = let orig = at in let* family, at = decode_enum decode_uint8 identity family_enum_of_int buf ~at in
let at = at + 1 in
let* address_len, at = decode_uint16 buf ~at in let address_len = address_len in
let* address, at = decode_list (decode_char) address_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ family; address }, at);;
let encode_host buf (v : host) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity family_int_of_enum buf v.family ~at in let at = at + 1 in let* at = encode_uint16 buf (identity ((* Parsetree.Byte *) List.length v.address)) ~at in let* at = encode_list encode_char buf v.address ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type access_control_enum = [ `Disable | `Enable ] [@@deriving sexp];;
let access_control_enum_of_int : int -> [> access_control_enum ] option = function 0 -> Some `Disable | 1 -> Some `Enable | n -> Printf.printf "unknown access_control_enum: %d\n" n; None;;
let access_control_int_of_enum : access_control_enum -> int = function `Disable -> 0 | `Enable -> 1;;
type list_hosts_reply = { mode : access_control_enum; hosts : host list; } [@@deriving sexp];;
let encode_list_hosts  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 110 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_list_hosts_reply length buf ~at : (list_hosts_reply * int) option = let orig = at in let at = at + 1 in
let* mode, at = decode_enum decode_char Char.code access_control_enum_of_int buf ~at in
let at = at + 6 in
let* hosts_len, at = decode_uint16 buf ~at in let hosts_len = hosts_len in
let at = at + 22 in
let* hosts, at = decode_list (decode_host) hosts_len buf ~at in
ignore orig;
Some ({ mode; hosts }, at);;
let encode_set_access_control ~(mode : access_control_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 111 ~at in
let* at = encode_enum encode_uint8 identity access_control_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type close_down_enum = [ `Destroy_all | `Retain_permanent | `Retain_temporary ] [@@deriving sexp];;
let close_down_enum_of_int : int -> [> close_down_enum ] option = function 0 -> Some `Destroy_all | 1 -> Some `Retain_permanent | 2 -> Some `Retain_temporary | n -> Printf.printf "unknown close_down_enum: %d\n" n; None;;
let close_down_int_of_enum : close_down_enum -> int = function `Destroy_all -> 0 | `Retain_permanent -> 1 | `Retain_temporary -> 2;;
let encode_set_close_down_mode ~(mode : close_down_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 112 ~at in
let* at = encode_enum encode_uint8 identity close_down_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type kill_enum = [ `All_temporary ] [@@deriving sexp];;
let kill_enum_of_int : int -> [> kill_enum ] option = function 0 -> Some `All_temporary | n -> Printf.printf "unknown kill_enum: %d\n" n; None;;
let kill_int_of_enum : kill_enum -> int = function `All_temporary -> 0;;
let encode_kill_client ~(resource : kill_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 113 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_int32 identity kill_int_of_enum buf resource ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let encode_rotate_properties ~(window : window) ~(delta : int) ~(atoms : atom list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 114 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Xid *) List.length atoms)) ~at in
let* at = encode_int16 buf delta ~at in
let* at = encode_list encode_atom buf atoms ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type screen_saver_enum = [ `Reset | `Active ] [@@deriving sexp];;
let screen_saver_enum_of_int : int -> [> screen_saver_enum ] option = function 0 -> Some `Reset | 1 -> Some `Active | n -> Printf.printf "unknown screen_saver_enum: %d\n" n; None;;
let screen_saver_int_of_enum : screen_saver_enum -> int = function `Reset -> 0 | `Active -> 1;;
let encode_force_screen_saver ~(mode : screen_saver_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 115 ~at in
let* at = encode_enum encode_uint8 identity screen_saver_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
type mapping_status_enum = [ `Success | `Busy | `Failure ] [@@deriving sexp];;
let mapping_status_enum_of_int : int -> [> mapping_status_enum ] option = function 0 -> Some `Success | 1 -> Some `Busy | 2 -> Some `Failure | n -> Printf.printf "unknown mapping_status_enum: %d\n" n; None;;
let mapping_status_int_of_enum : mapping_status_enum -> int = function `Success -> 0 | `Busy -> 1 | `Failure -> 2;;
type set_pointer_mapping_reply = { status : mapping_status_enum; } [@@deriving sexp];;
let encode_set_pointer_mapping ~(map : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 116 ~at in
let* at = encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length map)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_uint8 buf map ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_set_pointer_mapping_reply length buf ~at : (set_pointer_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code mapping_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
type get_pointer_mapping_reply = { map : int list; } [@@deriving sexp];;
let encode_get_pointer_mapping  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 117 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_pointer_mapping_reply length buf ~at : (get_pointer_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* map_len, at = decode_uint8 buf ~at in let map_len = map_len in
let at = at + 6 in
let at = at + 24 in
let* map, at = decode_list (decode_uint8) map_len buf ~at in
ignore orig;
Some ({ map }, at);;
type map_index_enum = [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 ] [@@deriving sexp];;
let map_index_enum_of_int : int -> [> map_index_enum ] option = function 0 -> Some `Shift | 1 -> Some `Lock | 2 -> Some `Control | 3 -> Some `D1 | 4 -> Some `D2 | 5 -> Some `D3 | 6 -> Some `D4 | 7 -> Some `D5 | n -> Printf.printf "unknown map_index_enum: %d\n" n; None;;
let map_index_int_of_enum : map_index_enum -> int = function `Shift -> 0 | `Lock -> 1 | `Control -> 2 | `D1 -> 3 | `D2 -> 4 | `D3 -> 5 | `D4 -> 6 | `D5 -> 7;;
type set_modifier_mapping_reply = { status : mapping_status_enum; } [@@deriving sexp];;
let encode_set_modifier_mapping ~(keycodes : keycode list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 118 ~at in
let* at = encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length keycodes)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_keycode buf keycodes ~at in
(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_set_modifier_mapping_reply length buf ~at : (set_modifier_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code mapping_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
type get_modifier_mapping_reply = { keycodes : keycode list; } [@@deriving sexp];;
let encode_get_modifier_mapping  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 119 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;
let decode_get_modifier_mapping_reply length buf ~at : (get_modifier_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* keycodes_per_modifier, at = decode_uint8 buf ~at in let keycodes_per_modifier = (keycodes_per_modifier) / (8) in
let at = at + 6 in
let at = at + 24 in
let* keycodes, at = decode_list (decode_keycode) keycodes_per_modifier buf ~at in
ignore orig;
Some ({ keycodes }, at);;
let encode_no_operation  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 127 ~at in

(* write request length *)
let* _ = encode_uint16 buf at ~at:(orig + 2) in
Some at;;