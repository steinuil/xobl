type xid = int
type file_descr = int
type ('flags, 'vals) mask = F of 'flags | V of 'vals
type 't alt_enum = E of 't | Custom of int
let (let*) = Option.bind

let identity x = x

let char_to_int64 c = Char.code c |> Int64.of_int

let bool_to_int64 b = Bool.to_int b |> Int64.of_int

let bool_of_int b = if b then 1 else 0

let decode f buf ~at ~size =
  if Bytes.length buf < at + size - 1 then None else Some (f buf at, at + size)

let decode_char buf ~at = decode Bytes.get buf ~at ~size:1

let decode_uint8 buf ~at = decode Bytes.get_uint8 buf ~at ~size:1

let decode_int8 buf ~at = decode Bytes.get_int8 buf ~at ~size:1

let decode_bool buf ~at =
  decode_uint8 buf ~at |> Option.map (fun (n, at) -> (n <> 0, at))

let decode_uint16 buf ~at = decode Bytes.get_uint16_le buf ~at ~size:2

let decode_int16 buf ~at = decode Bytes.get_int16_le buf ~at ~size:2

let decode_int32 buf ~at = decode Bytes.get_int32_le buf ~at ~size:4 |> Option.map (fun (n, at) -> (Int32.to_int n, at))

let decode_int64 buf ~at = decode Bytes.get_int64_le buf ~at ~size:8

let decode_float buf ~at =
  decode_int64 buf ~at
  |> Option.map (fun (n, at) -> (Int64.float_of_bits n, at))

let decode_file_descr buf ~at =
  decode Bytes.get_int16_le buf ~at ~size:2
  |> Option.map (fun (n, at) -> ((Obj.magic n : Unix.file_descr), at))

let decode_xid = decode_int16

let decode_enum decode to_int of_int buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int (to_int n) with
    | None -> None
    | Some e -> Some (e, at)

let decode_alt_enum decode to_int of_int buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    let n = to_int n in
    match of_int n with
    | Some e -> Some (E e, at)
    | None -> Some (Custom n, at)

let decode_list decode_item len buf ~at =
  let rec loop items at len =
    if len = 0 then Some ((List.rev items), at)
    else
      match decode_item buf ~at with
      | None -> None
      | Some (item, at) ->
        loop (item :: items) at (len - 1)
  in
  loop [] at len

let mask_of_int of_bit mask =
  let rec iter mask pos acc =
    if mask = 0L then Some acc
    else if Int64.logand mask 1L <> 0L then
      match of_bit pos with
      | Some item -> iter Int64.(shift_right mask 1) Int64.(pos + 1) (item :: acc)
      | None -> None
    else iter Int64.(shift_right mask 1) Int64.(pos + 1) acc
  in
  iter mask 0 []

let mask_value_of_int of_bit of_value mask =
  match of_value mask with
  | Some v -> Some (V v)
  | None ->
    match mask_of_int of_bit mask with
    | Some f -> Some (F f)
    | None -> None

let decode_mask decode to_int64 of_int64 buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int64 (to_int64 n) with
    | None -> None
    | Some e -> Some (e, at)

let decode_alt_mask decode to_int64 of_int64 buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int64 (to_int64 n) with
    | Some e -> Some (F e, at)
    | None -> Some (V n, at)

let encode f buf v ~at ~size =
  if Bytes.length buf < at + size then None else (
    f buf at v;
    Some (at + size)
  )

let encode_char buf v ~at = encode Bytes.set buf  v ~at ~size:1

let encode_uint8 buf v ~at = encode Bytes.set_uint8 buf v ~at ~size:1

let encode_int8 buf v ~at = encode Bytes.set_int8 buf v ~at ~size:1

let encode_bool buf v ~at = encode_uint8 buf (if v then 1 else 0) ~at

let encode_uint16 buf v ~at = encode Bytes.set_uint16_le buf v ~at ~size:2

let encode_int16 buf v ~at = encode Bytes.set_int16_le buf v ~at ~size:2

let encode_int32 buf v ~at = encode Bytes.set_int32_le buf (Int32.of_int v) ~at ~size:4

let encode_int64 buf v ~at = encode Bytes.set_int64_le buf v ~at ~size:8

let encode_float buf v ~at =
  encode_int64 buf (Int64.bits_of_float v) ~at

let encode_file_descr buf (v : Unix.file_descr) ~at =
  encode_int16 buf (Obj.magic v) ~at

let encode_xid = encode_int16

let encode_list encode_item buf ls ~at =
  let rec loop at = function
    | [] -> Some at
    | item :: rest -> (
      match encode_item buf item ~at with
      | Some at -> loop at rest
      | None -> None )
  in
  loop at ls

let encode_enum decode to_int of_int buf ~at =
  match decode buf ~at with
  | None -> None
  | Some (n, at) ->
    match of_int (to_int n) with
    | None -> None
    | Some e -> Some (e, at)

let encode_enum encode of_int to_int buf v ~at =
  let v = to_int v in
  encode buf (of_int v) ~at

let encode_mask encode of_int to_int buf v ~at =
  let v = to_int v in
  encode buf (of_int v) ~at

let int_of_mask to_bit mask =
  List.fold_left (fun mask v -> mask lor (to_bit v)) 0 mask

let mask_value_to_int to_mask to_enum = function
  | F f -> int_of_mask to_mask f
  | V v -> to_enum v

let encode_alt_enum encode of_int to_int buf v ~at =
  match v with
  | E v -> encode_enum encode of_int to_int buf v ~at
  | Custom v -> encode buf v ~at

module[@warning "-27"] Bigreq = struct
type enable_reply = { maximum_request_length : int; } [@@deriving sexp];;
let encode_enable  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_enable_reply length buf ~at : (enable_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* maximum_request_length, at = decode_int32 buf ~at in
ignore orig;
Some ({ maximum_request_length }, at);;
end
open Sexplib.Conv

type char2b = { byte1 : int; byte2 : int; } [@@deriving sexp];;
let decode_char2b buf ~at : (char2b * int) option = let orig = at in let* byte1, at = decode_uint8 buf ~at in
let* byte2, at = decode_uint8 buf ~at in
ignore orig;
Some ({ byte1; byte2 }, at);;
let encode_char2b buf (v : char2b) ~at : int option = let orig = at in let* at = encode_uint8 buf v.byte1 ~at in let* at = encode_uint8 buf v.byte2 ~at in ignore orig; Some at;;

type window = xid [@@deriving sexp];;
let decode_window = decode_xid;;
let encode_window = encode_xid;;

type pixmap = xid [@@deriving sexp];;
let decode_pixmap = decode_xid;;
let encode_pixmap = encode_xid;;

type cursor = xid [@@deriving sexp];;
let decode_cursor = decode_xid;;
let encode_cursor = encode_xid;;

type font = xid [@@deriving sexp];;
let decode_font = decode_xid;;
let encode_font = encode_xid;;

type gcontext = xid [@@deriving sexp];;
let decode_gcontext = decode_xid;;
let encode_gcontext = encode_xid;;

type colormap = xid [@@deriving sexp];;
let decode_colormap = decode_xid;;
let encode_colormap = encode_xid;;

type atom = xid [@@deriving sexp];;
let decode_atom = decode_xid;;
let encode_atom = encode_xid;;

type drawable = xid [@@deriving sexp];;
let decode_drawable = decode_xid;;
let encode_drawable = encode_xid;;

type fontable = xid [@@deriving sexp];;
let decode_fontable = decode_xid;;
let encode_fontable = encode_xid;;

type bool32 = int [@@deriving sexp];;
let decode_bool32 = decode_int32;;
let encode_bool32 = encode_int32;;

type visualid = int [@@deriving sexp];;
let decode_visualid = decode_int32;;
let encode_visualid = encode_int32;;

type timestamp = int [@@deriving sexp];;
let decode_timestamp = decode_int32;;
let encode_timestamp = encode_int32;;

type keysym = int [@@deriving sexp];;
let decode_keysym = decode_int32;;
let encode_keysym = encode_int32;;

type keycode = int [@@deriving sexp];;
let decode_keycode = decode_uint8;;
let encode_keycode = encode_uint8;;

type keycode32 = int [@@deriving sexp];;
let decode_keycode32 = decode_int32;;
let encode_keycode32 = encode_int32;;

type button = int [@@deriving sexp];;
let decode_button = decode_uint8;;
let encode_button = encode_uint8;;

type point = { x : int; y : int; } [@@deriving sexp];;
let decode_point buf ~at : (point * int) option = let orig = at in let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
ignore orig;
Some ({ x; y }, at);;
let encode_point buf (v : point) ~at : int option = let orig = at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in ignore orig; Some at;;

type rectangle = { x : int; y : int; width : int; height : int; } [@@deriving sexp];;
let decode_rectangle buf ~at : (rectangle * int) option = let orig = at in let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ x; y; width; height }, at);;
let encode_rectangle buf (v : rectangle) ~at : int option = let orig = at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in ignore orig; Some at;;

type arc = { x : int; y : int; width : int; height : int; angle1 : int; angle2 : int; } [@@deriving sexp];;
let decode_arc buf ~at : (arc * int) option = let orig = at in let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* angle1, at = decode_int16 buf ~at in
let* angle2, at = decode_int16 buf ~at in
ignore orig;
Some ({ x; y; width; height; angle1; angle2 }, at);;
let encode_arc buf (v : arc) ~at : int option = let orig = at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_int16 buf v.angle1 ~at in let* at = encode_int16 buf v.angle2 ~at in ignore orig; Some at;;

type format = { depth : int; bits_per_pixel : int; scanline_pad : int; } [@@deriving sexp];;
let decode_format buf ~at : (format * int) option = let orig = at in let* depth, at = decode_uint8 buf ~at in
let* bits_per_pixel, at = decode_uint8 buf ~at in
let* scanline_pad, at = decode_uint8 buf ~at in
let at = at + 5 in
ignore orig;
Some ({ depth; bits_per_pixel; scanline_pad }, at);;
let encode_format buf (v : format) ~at : int option = let orig = at in let* at = encode_uint8 buf v.depth ~at in let* at = encode_uint8 buf v.bits_per_pixel ~at in let* at = encode_uint8 buf v.scanline_pad ~at in let at = at + 5 in ignore orig; Some at;;

type visual_class_enum = [ `Static_gray | `Gray_scale | `Static_color | `Pseudo_color | `True_color | `Direct_color ] [@@deriving sexp];;
let visual_class_enum_of_int : int -> [> visual_class_enum ] option = function 0 -> Some `Static_gray | 1 -> Some `Gray_scale | 2 -> Some `Static_color | 3 -> Some `Pseudo_color | 4 -> Some `True_color | 5 -> Some `Direct_color | n -> Printf.printf "unknown visual_class_enum: %d\n" n; None;;
let visual_class_int_of_enum : visual_class_enum -> int = function `Static_gray -> 0 | `Gray_scale -> 1 | `Static_color -> 2 | `Pseudo_color -> 3 | `True_color -> 4 | `Direct_color -> 5;;
type visualtype = { visual_id : visualid; class_ : visual_class_enum; bits_per_rgb_value : int; colormap_entries : int; red_mask : int; green_mask : int; blue_mask : int; } [@@deriving sexp];;
let decode_visualtype buf ~at : (visualtype * int) option = let orig = at in let* visual_id, at = decode_visualid buf ~at in
let* class_, at = decode_enum decode_uint8 identity visual_class_enum_of_int buf ~at in
let* bits_per_rgb_value, at = decode_uint8 buf ~at in
let* colormap_entries, at = decode_uint16 buf ~at in
let* red_mask, at = decode_int32 buf ~at in
let* green_mask, at = decode_int32 buf ~at in
let* blue_mask, at = decode_int32 buf ~at in
let at = at + 4 in
ignore orig;
Some ({ visual_id; class_; bits_per_rgb_value; colormap_entries; red_mask; green_mask; blue_mask }, at);;
let encode_visualtype buf (v : visualtype) ~at : int option = let orig = at in let* at = encode_visualid buf v.visual_id ~at in let* at = encode_enum encode_uint8 identity visual_class_int_of_enum buf v.class_ ~at in let* at = encode_uint8 buf v.bits_per_rgb_value ~at in let* at = encode_uint16 buf v.colormap_entries ~at in let* at = encode_int32 buf v.red_mask ~at in let* at = encode_int32 buf v.green_mask ~at in let* at = encode_int32 buf v.blue_mask ~at in let at = at + 4 in ignore orig; Some at;;

type depth = { depth : int; visuals : visualtype list; } [@@deriving sexp];;
let decode_depth buf ~at : (depth * int) option = let orig = at in let* depth, at = decode_uint8 buf ~at in
let at = at + 1 in
let* visuals_len, at = decode_uint16 buf ~at in let visuals_len = visuals_len in
let at = at + 4 in
let* visuals, at = decode_list (decode_visualtype) visuals_len buf ~at in
ignore orig;
Some ({ depth; visuals }, at);;
let encode_depth buf (v : depth) ~at : int option = let orig = at in let* at = encode_uint8 buf v.depth ~at in let at = at + 1 in let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length v.visuals)) ~at in let at = at + 4 in let* at = encode_list encode_visualtype buf v.visuals ~at in ignore orig; Some at;;

type event_mask = ([ `Key_press | `Key_release | `Button_press | `Button_release | `Enter_window | `Leave_window | `Pointer_motion | `Pointer_motion_hint | `Button1_motion | `Button2_motion | `Button3_motion | `Button4_motion | `Button5_motion | `Button_motion | `Keymap_state | `Exposure | `Visibility_change | `Structure_notify | `Resize_redirect | `Substructure_notify | `Substructure_redirect | `Focus_change | `Property_change | `Color_map_change | `Owner_grab_button ] list, [ `No_event ]) mask [@@deriving sexp];;let event_mask_mask_of_int64 mask : event_mask option = let of_enum = function 0L -> Some `No_event | _ -> None in let of_mask = function 0 -> Some `Key_press | 1 -> Some `Key_release | 2 -> Some `Button_press | 3 -> Some `Button_release | 4 -> Some `Enter_window | 5 -> Some `Leave_window | 6 -> Some `Pointer_motion | 7 -> Some `Pointer_motion_hint | 8 -> Some `Button1_motion | 9 -> Some `Button2_motion | 10 -> Some `Button3_motion | 11 -> Some `Button4_motion | 12 -> Some `Button5_motion | 13 -> Some `Button_motion | 14 -> Some `Keymap_state | 15 -> Some `Exposure | 16 -> Some `Visibility_change | 17 -> Some `Structure_notify | 18 -> Some `Resize_redirect | 19 -> Some `Substructure_notify | 20 -> Some `Substructure_redirect | 21 -> Some `Focus_change | 22 -> Some `Property_change | 23 -> Some `Color_map_change | 24 -> Some `Owner_grab_button | _ -> None in mask_value_of_int of_mask of_enum mask;;
let event_mask_int_of_mask (mask : event_mask) : int = let to_enum = function `No_event -> 0 in let to_mask = function `Key_press -> 0 | `Key_release -> 1 | `Button_press -> 2 | `Button_release -> 3 | `Enter_window -> 4 | `Leave_window -> 5 | `Pointer_motion -> 6 | `Pointer_motion_hint -> 7 | `Button1_motion -> 8 | `Button2_motion -> 9 | `Button3_motion -> 10 | `Button4_motion -> 11 | `Button5_motion -> 12 | `Button_motion -> 13 | `Keymap_state -> 14 | `Exposure -> 15 | `Visibility_change -> 16 | `Structure_notify -> 17 | `Resize_redirect -> 18 | `Substructure_notify -> 19 | `Substructure_redirect -> 20 | `Focus_change -> 21 | `Property_change -> 22 | `Color_map_change -> 23 | `Owner_grab_button -> 24 in mask_value_to_int to_mask to_enum mask;;
type backing_store_enum = [ `Not_useful | `When_mapped | `Always ] [@@deriving sexp];;
let backing_store_enum_of_int : int -> [> backing_store_enum ] option = function 0 -> Some `Not_useful | 1 -> Some `When_mapped | 2 -> Some `Always | n -> Printf.printf "unknown backing_store_enum: %d\n" n; None;;
let backing_store_int_of_enum : backing_store_enum -> int = function `Not_useful -> 0 | `When_mapped -> 1 | `Always -> 2;;
type screen = { root : window; default_colormap : colormap; white_pixel : int; black_pixel : int; current_input_masks : event_mask; width_in_pixels : int; height_in_pixels : int; width_in_millimeters : int; height_in_millimeters : int; min_installed_maps : int; max_installed_maps : int; root_visual : visualid; backing_stores : backing_store_enum; save_unders : bool; root_depth : int; allowed_depths : depth list; } [@@deriving sexp];;
let decode_screen buf ~at : (screen * int) option = let orig = at in let* root, at = decode_window buf ~at in
let* default_colormap, at = decode_colormap buf ~at in
let* white_pixel, at = decode_int32 buf ~at in
let* black_pixel, at = decode_int32 buf ~at in
let* current_input_masks, at = decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at in
let* width_in_pixels, at = decode_uint16 buf ~at in
let* height_in_pixels, at = decode_uint16 buf ~at in
let* width_in_millimeters, at = decode_uint16 buf ~at in
let* height_in_millimeters, at = decode_uint16 buf ~at in
let* min_installed_maps, at = decode_uint16 buf ~at in
let* max_installed_maps, at = decode_uint16 buf ~at in
let* root_visual, at = decode_visualid buf ~at in
let* backing_stores, at = decode_enum decode_char Char.code backing_store_enum_of_int buf ~at in
let* save_unders, at = decode_bool buf ~at in
let* root_depth, at = decode_uint8 buf ~at in
let* allowed_depths_len, at = decode_uint8 buf ~at in let allowed_depths_len = allowed_depths_len in
let* allowed_depths, at = decode_list (decode_depth) allowed_depths_len buf ~at in
ignore orig;
Some ({ root; default_colormap; white_pixel; black_pixel; current_input_masks; width_in_pixels; height_in_pixels; width_in_millimeters; height_in_millimeters; min_installed_maps; max_installed_maps; root_visual; backing_stores; save_unders; root_depth; allowed_depths }, at);;
let encode_screen buf (v : screen) ~at : int option = let orig = at in let* at = encode_window buf v.root ~at in let* at = encode_colormap buf v.default_colormap ~at in let* at = encode_int32 buf v.white_pixel ~at in let* at = encode_int32 buf v.black_pixel ~at in let* at = encode_mask encode_int32 identity event_mask_int_of_mask buf v.current_input_masks ~at in let* at = encode_uint16 buf v.width_in_pixels ~at in let* at = encode_uint16 buf v.height_in_pixels ~at in let* at = encode_uint16 buf v.width_in_millimeters ~at in let* at = encode_uint16 buf v.height_in_millimeters ~at in let* at = encode_uint16 buf v.min_installed_maps ~at in let* at = encode_uint16 buf v.max_installed_maps ~at in let* at = encode_visualid buf v.root_visual ~at in let* at = encode_enum encode_char Char.chr backing_store_int_of_enum buf v.backing_stores ~at in let* at = encode_bool buf v.save_unders ~at in let* at = encode_uint8 buf v.root_depth ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.allowed_depths)) ~at in let* at = encode_list encode_depth buf v.allowed_depths ~at in ignore orig; Some at;;

type setup_request = { byte_order : int; protocol_major_version : int; protocol_minor_version : int; authorization_protocol_name : string; authorization_protocol_data : string; } [@@deriving sexp];;
let decode_setup_request buf ~at : (setup_request * int) option = let orig = at in let* byte_order, at = decode_uint8 buf ~at in
let at = at + 1 in
let* protocol_major_version, at = decode_uint16 buf ~at in
let* protocol_minor_version, at = decode_uint16 buf ~at in
let* authorization_protocol_name_len, at = decode_uint16 buf ~at in let authorization_protocol_name_len = authorization_protocol_name_len in
let* authorization_protocol_data_len, at = decode_uint16 buf ~at in let authorization_protocol_data_len = authorization_protocol_data_len in
let at = at + 2 in
let* authorization_protocol_name, at = decode_string authorization_protocol_name_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* authorization_protocol_data, at = decode_string authorization_protocol_data_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ byte_order; protocol_major_version; protocol_minor_version; authorization_protocol_name; authorization_protocol_data }, at);;
let encode_setup_request buf (v : setup_request) ~at : int option = let orig = at in let* at = encode_uint8 buf v.byte_order ~at in let at = at + 1 in let* at = encode_uint16 buf v.protocol_major_version ~at in let* at = encode_uint16 buf v.protocol_minor_version ~at in let* at = encode_uint16 buf (identity (String.length v.authorization_protocol_name)) ~at in let* at = encode_uint16 buf (identity (String.length v.authorization_protocol_data)) ~at in let at = at + 2 in let* at = encode_string buf v.authorization_protocol_name ~at in let at = at + ((at - orig) mod 4) in let* at = encode_string buf v.authorization_protocol_data ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type setup_failed = { status : int; protocol_major_version : int; protocol_minor_version : int; length : int; reason : string; } [@@deriving sexp];;
let decode_setup_failed buf ~at : (setup_failed * int) option = let orig = at in let* status, at = decode_uint8 buf ~at in
let* reason_len, at = decode_uint8 buf ~at in let reason_len = reason_len in
let* protocol_major_version, at = decode_uint16 buf ~at in
let* protocol_minor_version, at = decode_uint16 buf ~at in
let* length, at = decode_uint16 buf ~at in
let* reason, at = decode_string reason_len buf ~at in
ignore orig;
Some ({ status; protocol_major_version; protocol_minor_version; length; reason }, at);;
let encode_setup_failed buf (v : setup_failed) ~at : int option = let orig = at in let* at = encode_uint8 buf v.status ~at in let* at = encode_uint8 buf (identity (String.length v.reason)) ~at in let* at = encode_uint16 buf v.protocol_major_version ~at in let* at = encode_uint16 buf v.protocol_minor_version ~at in let* at = encode_uint16 buf v.length ~at in let* at = encode_string buf v.reason ~at in ignore orig; Some at;;

type setup_authenticate = { status : int; reason : string; } [@@deriving sexp];;
let decode_setup_authenticate buf ~at : (setup_authenticate * int) option = let orig = at in let* status, at = decode_uint8 buf ~at in
let at = at + 5 in
let* length, at = decode_uint16 buf ~at in let length = (length) / (4) in
let* reason, at = decode_string length buf ~at in
ignore orig;
Some ({ status; reason }, at);;
let encode_setup_authenticate buf (v : setup_authenticate) ~at : int option = let orig = at in let* at = encode_uint8 buf v.status ~at in let at = at + 5 in let* at = encode_uint16 buf (identity (String.length v.reason)) ~at in let* at = encode_string buf v.reason ~at in ignore orig; Some at;;

type image_order_enum = [ `Lsb_first | `Msb_first ] [@@deriving sexp];;
let image_order_enum_of_int : int -> [> image_order_enum ] option = function 0 -> Some `Lsb_first | 1 -> Some `Msb_first | n -> Printf.printf "unknown image_order_enum: %d\n" n; None;;
let image_order_int_of_enum : image_order_enum -> int = function `Lsb_first -> 0 | `Msb_first -> 1;;
type setup = { status : int; protocol_major_version : int; protocol_minor_version : int; length : int; release_number : int; resource_id_base : int; resource_id_mask : int; motion_buffer_size : int; maximum_request_length : int; image_byte_order : image_order_enum; bitmap_format_bit_order : image_order_enum; bitmap_format_scanline_unit : int; bitmap_format_scanline_pad : int; min_keycode : keycode; max_keycode : keycode; vendor : string; pixmap_formats : format list; roots : screen list; } [@@deriving sexp];;
let decode_setup buf ~at : (setup * int) option = let orig = at in let* status, at = decode_uint8 buf ~at in
let at = at + 1 in
let* protocol_major_version, at = decode_uint16 buf ~at in
let* protocol_minor_version, at = decode_uint16 buf ~at in
let* length, at = decode_uint16 buf ~at in
let* release_number, at = decode_int32 buf ~at in
let* resource_id_base, at = decode_int32 buf ~at in
let* resource_id_mask, at = decode_int32 buf ~at in
let* motion_buffer_size, at = decode_int32 buf ~at in
let* vendor_len, at = decode_uint16 buf ~at in let vendor_len = vendor_len in
let* maximum_request_length, at = decode_uint16 buf ~at in
let* roots_len, at = decode_uint8 buf ~at in let roots_len = roots_len in
let* pixmap_formats_len, at = decode_uint8 buf ~at in let pixmap_formats_len = pixmap_formats_len in
let* image_byte_order, at = decode_enum decode_uint8 identity image_order_enum_of_int buf ~at in
let* bitmap_format_bit_order, at = decode_enum decode_uint8 identity image_order_enum_of_int buf ~at in
let* bitmap_format_scanline_unit, at = decode_uint8 buf ~at in
let* bitmap_format_scanline_pad, at = decode_uint8 buf ~at in
let* min_keycode, at = decode_keycode buf ~at in
let* max_keycode, at = decode_keycode buf ~at in
let at = at + 4 in
let* vendor, at = decode_string vendor_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* pixmap_formats, at = decode_list (decode_format) pixmap_formats_len buf ~at in
let* roots, at = decode_list (decode_screen) roots_len buf ~at in
ignore orig;
Some ({ status; protocol_major_version; protocol_minor_version; length; release_number; resource_id_base; resource_id_mask; motion_buffer_size; maximum_request_length; image_byte_order; bitmap_format_bit_order; bitmap_format_scanline_unit; bitmap_format_scanline_pad; min_keycode; max_keycode; vendor; pixmap_formats; roots }, at);;
let encode_setup buf (v : setup) ~at : int option = let orig = at in let* at = encode_uint8 buf v.status ~at in let at = at + 1 in let* at = encode_uint16 buf v.protocol_major_version ~at in let* at = encode_uint16 buf v.protocol_minor_version ~at in let* at = encode_uint16 buf v.length ~at in let* at = encode_int32 buf v.release_number ~at in let* at = encode_int32 buf v.resource_id_base ~at in let* at = encode_int32 buf v.resource_id_mask ~at in let* at = encode_int32 buf v.motion_buffer_size ~at in let* at = encode_uint16 buf (identity (String.length v.vendor)) ~at in let* at = encode_uint16 buf v.maximum_request_length ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.roots)) ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.pixmap_formats)) ~at in let* at = encode_enum encode_uint8 identity image_order_int_of_enum buf v.image_byte_order ~at in let* at = encode_enum encode_uint8 identity image_order_int_of_enum buf v.bitmap_format_bit_order ~at in let* at = encode_uint8 buf v.bitmap_format_scanline_unit ~at in let* at = encode_uint8 buf v.bitmap_format_scanline_pad ~at in let* at = encode_keycode buf v.min_keycode ~at in let* at = encode_keycode buf v.max_keycode ~at in let at = at + 4 in let* at = encode_string buf v.vendor ~at in let at = at + ((at - orig) mod 4) in let* at = encode_list encode_format buf v.pixmap_formats ~at in let* at = encode_list encode_screen buf v.roots ~at in ignore orig; Some at;;

type mod_mask = [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list [@@deriving sexp];;
let mod_mask_mask_of_int64 mask : mod_mask option = let of_int = function 0 -> Some `Shift | 1 -> Some `Lock | 2 -> Some `Control | 3 -> Some `D1 | 4 -> Some `D2 | 5 -> Some `D3 | 6 -> Some `D4 | 7 -> Some `D5 | 15 -> Some `Any | _ -> None in mask_of_int of_int mask;;
let mod_mask_int_of_mask : mod_mask -> int = let to_bit = function `Shift -> 0 | `Lock -> 1 | `Control -> 2 | `D1 -> 3 | `D2 -> 4 | `D3 -> 5 | `D4 -> 6 | `D5 -> 7 | `Any -> 15 in int_of_mask to_bit;;
type key_but_mask = [ `Shift | `Lock | `Control | `Mod1 | `Mod2 | `Mod3 | `Mod4 | `Mod5 | `Button1 | `Button2 | `Button3 | `Button4 | `Button5 ] list [@@deriving sexp];;
let key_but_mask_mask_of_int64 mask : key_but_mask option = let of_int = function 0 -> Some `Shift | 1 -> Some `Lock | 2 -> Some `Control | 3 -> Some `Mod1 | 4 -> Some `Mod2 | 5 -> Some `Mod3 | 6 -> Some `Mod4 | 7 -> Some `Mod5 | 8 -> Some `Button1 | 9 -> Some `Button2 | 10 -> Some `Button3 | 11 -> Some `Button4 | 12 -> Some `Button5 | _ -> None in mask_of_int of_int mask;;
let key_but_mask_int_of_mask : key_but_mask -> int = let to_bit = function `Shift -> 0 | `Lock -> 1 | `Control -> 2 | `Mod1 -> 3 | `Mod2 -> 4 | `Mod3 -> 5 | `Mod4 -> 6 | `Mod5 -> 7 | `Button1 -> 8 | `Button2 -> 9 | `Button3 -> 10 | `Button4 -> 11 | `Button5 -> 12 in int_of_mask to_bit;;
type window_enum = [ `None ] [@@deriving sexp];;
let window_enum_of_int : int -> [> window_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown window_enum: %d\n" n; None;;
let window_int_of_enum : window_enum -> int = function `None -> 0;;
type key_press_event = { detail : keycode; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; same_screen : bool; } [@@deriving sexp];;
type key_release_event = key_press_event [@@deriving sexp];;
type button_mask = [ `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list [@@deriving sexp];;
let button_mask_mask_of_int64 mask : button_mask option = let of_int = function 8 -> Some `D1 | 9 -> Some `D2 | 10 -> Some `D3 | 11 -> Some `D4 | 12 -> Some `D5 | 15 -> Some `Any | _ -> None in mask_of_int of_int mask;;
let button_mask_int_of_mask : button_mask -> int = let to_bit = function `D1 -> 8 | `D2 -> 9 | `D3 -> 10 | `D4 -> 11 | `D5 -> 12 | `Any -> 15 in int_of_mask to_bit;;
type button_press_event = { detail : button; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; same_screen : bool; } [@@deriving sexp];;
type button_release_event = button_press_event [@@deriving sexp];;
type motion_enum = [ `Normal | `Hint ] [@@deriving sexp];;
let motion_enum_of_int : int -> [> motion_enum ] option = function 0 -> Some `Normal | 1 -> Some `Hint | n -> Printf.printf "unknown motion_enum: %d\n" n; None;;
let motion_int_of_enum : motion_enum -> int = function `Normal -> 0 | `Hint -> 1;;
type motion_notify_event = { detail : motion_enum; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; same_screen : bool; } [@@deriving sexp];;
type notify_detail_enum = [ `Ancestor | `Virtual | `Inferior | `Nonlinear | `Nonlinear_virtual | `Pointer | `Pointer_root | `None ] [@@deriving sexp];;
let notify_detail_enum_of_int : int -> [> notify_detail_enum ] option = function 0 -> Some `Ancestor | 1 -> Some `Virtual | 2 -> Some `Inferior | 3 -> Some `Nonlinear | 4 -> Some `Nonlinear_virtual | 5 -> Some `Pointer | 6 -> Some `Pointer_root | 7 -> Some `None | n -> Printf.printf "unknown notify_detail_enum: %d\n" n; None;;
let notify_detail_int_of_enum : notify_detail_enum -> int = function `Ancestor -> 0 | `Virtual -> 1 | `Inferior -> 2 | `Nonlinear -> 3 | `Nonlinear_virtual -> 4 | `Pointer -> 5 | `Pointer_root -> 6 | `None -> 7;;
type notify_mode_enum = [ `Normal | `Grab | `Ungrab | `While_grabbed ] [@@deriving sexp];;
let notify_mode_enum_of_int : int -> [> notify_mode_enum ] option = function 0 -> Some `Normal | 1 -> Some `Grab | 2 -> Some `Ungrab | 3 -> Some `While_grabbed | n -> Printf.printf "unknown notify_mode_enum: %d\n" n; None;;
let notify_mode_int_of_enum : notify_mode_enum -> int = function `Normal -> 0 | `Grab -> 1 | `Ungrab -> 2 | `While_grabbed -> 3;;
type enter_notify_event = { detail : notify_detail_enum; time : timestamp; root : window; event : window; child : window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : key_but_mask; mode : notify_mode_enum; same_screen_focus : char; } [@@deriving sexp];;
type leave_notify_event = enter_notify_event [@@deriving sexp];;
type focus_in_event = { detail : notify_detail_enum; event : window; mode : notify_mode_enum; } [@@deriving sexp];;
type focus_out_event = focus_in_event [@@deriving sexp];;
type keymap_notify_event = { keys : int list; } [@@deriving sexp];;
type expose_event = { window : window; x : int; y : int; width : int; height : int; count : int; } [@@deriving sexp];;
type graphics_exposure_event = { drawable : drawable; x : int; y : int; width : int; height : int; minor_opcode : int; count : int; major_opcode : int; } [@@deriving sexp];;
type no_exposure_event = { drawable : drawable; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type visibility_enum = [ `Unobscured | `Partially_obscured | `Fully_obscured ] [@@deriving sexp];;
let visibility_enum_of_int : int -> [> visibility_enum ] option = function 0 -> Some `Unobscured | 1 -> Some `Partially_obscured | 2 -> Some `Fully_obscured | n -> Printf.printf "unknown visibility_enum: %d\n" n; None;;
let visibility_int_of_enum : visibility_enum -> int = function `Unobscured -> 0 | `Partially_obscured -> 1 | `Fully_obscured -> 2;;
type visibility_notify_event = { window : window; state : visibility_enum; } [@@deriving sexp];;
type create_notify_event = { parent : window; window : window; x : int; y : int; width : int; height : int; border_width : int; override_redirect : bool; } [@@deriving sexp];;
type destroy_notify_event = { event : window; window : window; } [@@deriving sexp];;
type unmap_notify_event = { event : window; window : window; from_configure : bool; } [@@deriving sexp];;
type map_notify_event = { event : window; window : window; override_redirect : bool; } [@@deriving sexp];;
type map_request_event = { parent : window; window : window; } [@@deriving sexp];;
type reparent_notify_event = { event : window; window : window; parent : window; x : int; y : int; override_redirect : bool; } [@@deriving sexp];;
type configure_notify_event = { event : window; window : window; above_sibling : window_enum alt_enum; x : int; y : int; width : int; height : int; border_width : int; override_redirect : bool; } [@@deriving sexp];;
type stack_mode_enum = [ `Above | `Below | `Top_if | `Bottom_if | `Opposite ] [@@deriving sexp];;
let stack_mode_enum_of_int : int -> [> stack_mode_enum ] option = function 0 -> Some `Above | 1 -> Some `Below | 2 -> Some `Top_if | 3 -> Some `Bottom_if | 4 -> Some `Opposite | n -> Printf.printf "unknown stack_mode_enum: %d\n" n; None;;
let stack_mode_int_of_enum : stack_mode_enum -> int = function `Above -> 0 | `Below -> 1 | `Top_if -> 2 | `Bottom_if -> 3 | `Opposite -> 4;;
type config_window_mask = [ `X | `Y | `Width | `Height | `Border_width | `Sibling | `Stack_mode ] list [@@deriving sexp];;
let config_window_mask_of_int64 mask : config_window_mask option = let of_int = function 0 -> Some `X | 1 -> Some `Y | 2 -> Some `Width | 3 -> Some `Height | 4 -> Some `Border_width | 5 -> Some `Sibling | 6 -> Some `Stack_mode | _ -> None in mask_of_int of_int mask;;
let config_window_int_of_mask : config_window_mask -> int = let to_bit = function `X -> 0 | `Y -> 1 | `Width -> 2 | `Height -> 3 | `Border_width -> 4 | `Sibling -> 5 | `Stack_mode -> 6 in int_of_mask to_bit;;
type configure_request_event = { stack_mode : stack_mode_enum; parent : window; window : window; sibling : window_enum alt_enum; x : int; y : int; width : int; height : int; border_width : int; value_mask : config_window_mask; } [@@deriving sexp];;
type gravity_notify_event = { event : window; window : window; x : int; y : int; } [@@deriving sexp];;
type resize_request_event = { window : window; width : int; height : int; } [@@deriving sexp];;
type place_enum = [ `On_top | `On_bottom ] [@@deriving sexp];;
let place_enum_of_int : int -> [> place_enum ] option = function 0 -> Some `On_top | 1 -> Some `On_bottom | n -> Printf.printf "unknown place_enum: %d\n" n; None;;
let place_int_of_enum : place_enum -> int = function `On_top -> 0 | `On_bottom -> 1;;
type circulate_notify_event = { event : window; window : window; place : place_enum; } [@@deriving sexp];;
type circulate_request_event = circulate_notify_event [@@deriving sexp];;
type property_enum = [ `New_value | `Delete ] [@@deriving sexp];;
let property_enum_of_int : int -> [> property_enum ] option = function 0 -> Some `New_value | 1 -> Some `Delete | n -> Printf.printf "unknown property_enum: %d\n" n; None;;
let property_int_of_enum : property_enum -> int = function `New_value -> 0 | `Delete -> 1;;
type property_notify_event = { window : window; atom : atom; time : timestamp; state : property_enum; } [@@deriving sexp];;
type selection_clear_event = { time : timestamp; owner : window; selection : atom; } [@@deriving sexp];;
type time_enum = [ `Current_time ] [@@deriving sexp];;
let time_enum_of_int : int -> [> time_enum ] option = function 0 -> Some `Current_time | n -> Printf.printf "unknown time_enum: %d\n" n; None;;
let time_int_of_enum : time_enum -> int = function `Current_time -> 0;;
type atom_enum = [ `None | `Any | `Primary | `Secondary | `Arc | `Atom | `Bitmap | `Cardinal | `Colormap | `Cursor | `Cut_buffer0 | `Cut_buffer1 | `Cut_buffer2 | `Cut_buffer3 | `Cut_buffer4 | `Cut_buffer5 | `Cut_buffer6 | `Cut_buffer7 | `Drawable | `Font | `Integer | `Pixmap | `Point | `Rectangle | `Resource_manager | `Rgb_color_map | `Rgb_best_map | `Rgb_blue_map | `Rgb_default_map | `Rgb_gray_map | `Rgb_green_map | `Rgb_red_map | `String | `Visualid | `Window | `Wm_command | `Wm_hints | `Wm_client_machine | `Wm_icon_name | `Wm_icon_size | `Wm_name | `Wm_normal_hints | `Wm_size_hints | `Wm_zoom_hints | `Min_space | `Norm_space | `Max_space | `End_space | `Superscript_x | `Superscript_y | `Subscript_x | `Subscript_y | `Underline_position | `Underline_thickness | `Strikeout_ascent | `Strikeout_descent | `Italic_angle | `X_height | `Quad_width | `Weight | `Point_size | `Resolution | `Copyright | `Notice | `Font_name | `Family_name | `Full_name | `Cap_height | `Wm_class | `Wm_transient_for ] [@@deriving sexp];;
let atom_enum_of_int : int -> [> atom_enum ] option = function 0 -> Some `None | 0 -> Some `Any | 1 -> Some `Primary | 2 -> Some `Secondary | 3 -> Some `Arc | 4 -> Some `Atom | 5 -> Some `Bitmap | 6 -> Some `Cardinal | 7 -> Some `Colormap | 8 -> Some `Cursor | 9 -> Some `Cut_buffer0 | 10 -> Some `Cut_buffer1 | 11 -> Some `Cut_buffer2 | 12 -> Some `Cut_buffer3 | 13 -> Some `Cut_buffer4 | 14 -> Some `Cut_buffer5 | 15 -> Some `Cut_buffer6 | 16 -> Some `Cut_buffer7 | 17 -> Some `Drawable | 18 -> Some `Font | 19 -> Some `Integer | 20 -> Some `Pixmap | 21 -> Some `Point | 22 -> Some `Rectangle | 23 -> Some `Resource_manager | 24 -> Some `Rgb_color_map | 25 -> Some `Rgb_best_map | 26 -> Some `Rgb_blue_map | 27 -> Some `Rgb_default_map | 28 -> Some `Rgb_gray_map | 29 -> Some `Rgb_green_map | 30 -> Some `Rgb_red_map | 31 -> Some `String | 32 -> Some `Visualid | 33 -> Some `Window | 34 -> Some `Wm_command | 35 -> Some `Wm_hints | 36 -> Some `Wm_client_machine | 37 -> Some `Wm_icon_name | 38 -> Some `Wm_icon_size | 39 -> Some `Wm_name | 40 -> Some `Wm_normal_hints | 41 -> Some `Wm_size_hints | 42 -> Some `Wm_zoom_hints | 43 -> Some `Min_space | 44 -> Some `Norm_space | 45 -> Some `Max_space | 46 -> Some `End_space | 47 -> Some `Superscript_x | 48 -> Some `Superscript_y | 49 -> Some `Subscript_x | 50 -> Some `Subscript_y | 51 -> Some `Underline_position | 52 -> Some `Underline_thickness | 53 -> Some `Strikeout_ascent | 54 -> Some `Strikeout_descent | 55 -> Some `Italic_angle | 56 -> Some `X_height | 57 -> Some `Quad_width | 58 -> Some `Weight | 59 -> Some `Point_size | 60 -> Some `Resolution | 61 -> Some `Copyright | 62 -> Some `Notice | 63 -> Some `Font_name | 64 -> Some `Family_name | 65 -> Some `Full_name | 66 -> Some `Cap_height | 67 -> Some `Wm_class | 68 -> Some `Wm_transient_for | n -> Printf.printf "unknown atom_enum: %d\n" n; None;;
let atom_int_of_enum : atom_enum -> int = function `None -> 0 | `Any -> 0 | `Primary -> 1 | `Secondary -> 2 | `Arc -> 3 | `Atom -> 4 | `Bitmap -> 5 | `Cardinal -> 6 | `Colormap -> 7 | `Cursor -> 8 | `Cut_buffer0 -> 9 | `Cut_buffer1 -> 10 | `Cut_buffer2 -> 11 | `Cut_buffer3 -> 12 | `Cut_buffer4 -> 13 | `Cut_buffer5 -> 14 | `Cut_buffer6 -> 15 | `Cut_buffer7 -> 16 | `Drawable -> 17 | `Font -> 18 | `Integer -> 19 | `Pixmap -> 20 | `Point -> 21 | `Rectangle -> 22 | `Resource_manager -> 23 | `Rgb_color_map -> 24 | `Rgb_best_map -> 25 | `Rgb_blue_map -> 26 | `Rgb_default_map -> 27 | `Rgb_gray_map -> 28 | `Rgb_green_map -> 29 | `Rgb_red_map -> 30 | `String -> 31 | `Visualid -> 32 | `Window -> 33 | `Wm_command -> 34 | `Wm_hints -> 35 | `Wm_client_machine -> 36 | `Wm_icon_name -> 37 | `Wm_icon_size -> 38 | `Wm_name -> 39 | `Wm_normal_hints -> 40 | `Wm_size_hints -> 41 | `Wm_zoom_hints -> 42 | `Min_space -> 43 | `Norm_space -> 44 | `Max_space -> 45 | `End_space -> 46 | `Superscript_x -> 47 | `Superscript_y -> 48 | `Subscript_x -> 49 | `Subscript_y -> 50 | `Underline_position -> 51 | `Underline_thickness -> 52 | `Strikeout_ascent -> 53 | `Strikeout_descent -> 54 | `Italic_angle -> 55 | `X_height -> 56 | `Quad_width -> 57 | `Weight -> 58 | `Point_size -> 59 | `Resolution -> 60 | `Copyright -> 61 | `Notice -> 62 | `Font_name -> 63 | `Family_name -> 64 | `Full_name -> 65 | `Cap_height -> 66 | `Wm_class -> 67 | `Wm_transient_for -> 68;;
type selection_request_event = { time : time_enum alt_enum; owner : window; requestor : window; selection : atom; target : atom; property : atom_enum alt_enum; } [@@deriving sexp];;
type selection_notify_event = { time : time_enum alt_enum; requestor : window; selection : atom; target : atom; property : atom_enum alt_enum; } [@@deriving sexp];;
type colormap_state_enum = [ `Uninstalled | `Installed ] [@@deriving sexp];;
let colormap_state_enum_of_int : int -> [> colormap_state_enum ] option = function 0 -> Some `Uninstalled | 1 -> Some `Installed | n -> Printf.printf "unknown colormap_state_enum: %d\n" n; None;;
let colormap_state_int_of_enum : colormap_state_enum -> int = function `Uninstalled -> 0 | `Installed -> 1;;
type colormap_enum = [ `None ] [@@deriving sexp];;
let colormap_enum_of_int : int -> [> colormap_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown colormap_enum: %d\n" n; None;;
let colormap_int_of_enum : colormap_enum -> int = function `None -> 0;;
type colormap_notify_event = { window : window; colormap : colormap_enum alt_enum; new_ : bool; state : colormap_state_enum; } [@@deriving sexp];;
type client_message_data_format_enum = [ `Data8 | `Data16 | `Data32 ] [@@deriving sexp];;
let client_message_data_format_enum_of_int : int -> [> client_message_data_format_enum ] option = function 8 -> Some `Data8 | 16 -> Some `Data16 | 32 -> Some `Data32 | n -> Printf.printf "unknown client_message_data_format_enum: %d\n" n; None;;
let client_message_data_format_int_of_enum : client_message_data_format_enum -> int = function `Data8 -> 8 | `Data16 -> 16 | `Data32 -> 32;;
type client_message_data_format_variant = Data8 of { data8 : int list; } | Data16 of { data16 : int list; } | Data32 of { data32 : int list; } [@@deriving sexp];;
type client_message_event = { window : window; type_ : atom; data : client_message_data_format_variant; } [@@deriving sexp];;
type mapping_enum = [ `Modifier | `Keyboard | `Pointer ] [@@deriving sexp];;
let mapping_enum_of_int : int -> [> mapping_enum ] option = function 0 -> Some `Modifier | 1 -> Some `Keyboard | 2 -> Some `Pointer | n -> Printf.printf "unknown mapping_enum: %d\n" n; None;;
let mapping_int_of_enum : mapping_enum -> int = function `Modifier -> 0 | `Keyboard -> 1 | `Pointer -> 2;;
type mapping_notify_event = { request : mapping_enum; first_keycode : keycode; count : int; } [@@deriving sexp];;
type ge_generic_event = unit [@@deriving sexp];;
type request_error = { bad_value : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type value_error = { bad_value : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type window_error = value_error [@@deriving sexp];;
type pixmap_error = value_error [@@deriving sexp];;
type atom_error = value_error [@@deriving sexp];;
type cursor_error = value_error [@@deriving sexp];;
type font_error = value_error [@@deriving sexp];;
type match_error = request_error [@@deriving sexp];;
type drawable_error = value_error [@@deriving sexp];;
type access_error = request_error [@@deriving sexp];;
type alloc_error = request_error [@@deriving sexp];;
type colormap_error = value_error [@@deriving sexp];;
type g_context_error = value_error [@@deriving sexp];;
type id_choice_error = value_error [@@deriving sexp];;
type name_error = request_error [@@deriving sexp];;
type length_error = request_error [@@deriving sexp];;
type implementation_error = request_error [@@deriving sexp];;
type window_class_enum = [ `Copy_from_parent | `Input_output | `Input_only ] [@@deriving sexp];;
let window_class_enum_of_int : int -> [> window_class_enum ] option = function 0 -> Some `Copy_from_parent | 1 -> Some `Input_output | 2 -> Some `Input_only | n -> Printf.printf "unknown window_class_enum: %d\n" n; None;;
let window_class_int_of_enum : window_class_enum -> int = function `Copy_from_parent -> 0 | `Input_output -> 1 | `Input_only -> 2;;
type cw_mask = [ `Back_pixmap | `Back_pixel | `Border_pixmap | `Border_pixel | `Bit_gravity | `Win_gravity | `Backing_store | `Backing_planes | `Backing_pixel | `Override_redirect | `Save_under | `Event_mask | `Dont_propagate | `Colormap | `Cursor ] list [@@deriving sexp];;
let cw_mask_of_int64 mask : cw_mask option = let of_int = function 0 -> Some `Back_pixmap | 1 -> Some `Back_pixel | 2 -> Some `Border_pixmap | 3 -> Some `Border_pixel | 4 -> Some `Bit_gravity | 5 -> Some `Win_gravity | 6 -> Some `Backing_store | 7 -> Some `Backing_planes | 8 -> Some `Backing_pixel | 9 -> Some `Override_redirect | 10 -> Some `Save_under | 11 -> Some `Event_mask | 12 -> Some `Dont_propagate | 13 -> Some `Colormap | 14 -> Some `Cursor | _ -> None in mask_of_int of_int mask;;
let cw_int_of_mask : cw_mask -> int = let to_bit = function `Back_pixmap -> 0 | `Back_pixel -> 1 | `Border_pixmap -> 2 | `Border_pixel -> 3 | `Bit_gravity -> 4 | `Win_gravity -> 5 | `Backing_store -> 6 | `Backing_planes -> 7 | `Backing_pixel -> 8 | `Override_redirect -> 9 | `Save_under -> 10 | `Event_mask -> 11 | `Dont_propagate -> 12 | `Colormap -> 13 | `Cursor -> 14 in int_of_mask to_bit;;
type back_pixmap_enum = [ `None | `Parent_relative ] [@@deriving sexp];;
let back_pixmap_enum_of_int : int -> [> back_pixmap_enum ] option = function 0 -> Some `None | 1 -> Some `Parent_relative | n -> Printf.printf "unknown back_pixmap_enum: %d\n" n; None;;
let back_pixmap_int_of_enum : back_pixmap_enum -> int = function `None -> 0 | `Parent_relative -> 1;;
type gravity_enum = [ `Bit_forget | `Win_unmap | `North_west | `North | `North_east | `West | `Center | `East | `South_west | `South | `South_east | `Static ] [@@deriving sexp];;
let gravity_enum_of_int : int -> [> gravity_enum ] option = function 0 -> Some `Bit_forget | 0 -> Some `Win_unmap | 1 -> Some `North_west | 2 -> Some `North | 3 -> Some `North_east | 4 -> Some `West | 5 -> Some `Center | 6 -> Some `East | 7 -> Some `South_west | 8 -> Some `South | 9 -> Some `South_east | 10 -> Some `Static | n -> Printf.printf "unknown gravity_enum: %d\n" n; None;;
let gravity_int_of_enum : gravity_enum -> int = function `Bit_forget -> 0 | `Win_unmap -> 0 | `North_west -> 1 | `North -> 2 | `North_east -> 3 | `West -> 4 | `Center -> 5 | `East -> 6 | `South_west -> 7 | `South -> 8 | `South_east -> 9 | `Static -> 10;;
type pixmap_enum = [ `None ] [@@deriving sexp];;
let pixmap_enum_of_int : int -> [> pixmap_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown pixmap_enum: %d\n" n; None;;
let pixmap_int_of_enum : pixmap_enum -> int = function `None -> 0;;
type cursor_enum = [ `None ] [@@deriving sexp];;
let cursor_enum_of_int : int -> [> cursor_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown cursor_enum: %d\n" n; None;;
let cursor_int_of_enum : cursor_enum -> int = function `None -> 0;;
let encode_create_window ~(depth : int) ~(wid : window) ~(parent : window) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(border_width : int) ~(class_ : window_class_enum) ~(visual : visualid) ?(background_pixmap : back_pixmap_enum alt_enum option) ?(background_pixel : int option) ?(border_pixmap : pixmap_enum alt_enum option) ?(border_pixel : int option) ?(bit_gravity : gravity_enum option) ?(win_gravity : gravity_enum option) ?(backing_store : backing_store_enum option) ?(backing_planes : int option) ?(backing_pixel : int option) ?(override_redirect : bool32 option) ?(save_under : bool32 option) ?(event_mask : event_mask option) ?(do_not_propogate_mask : event_mask option) ?(colormap : colormap_enum alt_enum option) ?(cursor : cursor_enum alt_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_uint8 buf depth ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf wid ~at in
let* at = encode_window buf parent ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint16 buf border_width ~at in
let* at = encode_enum encode_uint16 identity window_class_int_of_enum buf class_ ~at in
let* at = encode_visualid buf visual ~at in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_window_attributes ~(window : window) ?(background_pixmap : back_pixmap_enum alt_enum option) ?(background_pixel : int option) ?(border_pixmap : pixmap_enum alt_enum option) ?(border_pixel : int option) ?(bit_gravity : gravity_enum option) ?(win_gravity : gravity_enum option) ?(backing_store : backing_store_enum option) ?(backing_planes : int option) ?(backing_pixel : int option) ?(override_redirect : bool32 option) ?(save_under : bool32 option) ?(event_mask : event_mask option) ?(do_not_propogate_mask : event_mask option) ?(colormap : colormap_enum alt_enum option) ?(cursor : cursor_enum alt_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type map_state_enum = [ `Unmapped | `Unviewable | `Viewable ] [@@deriving sexp];;
let map_state_enum_of_int : int -> [> map_state_enum ] option = function 0 -> Some `Unmapped | 1 -> Some `Unviewable | 2 -> Some `Viewable | n -> Printf.printf "unknown map_state_enum: %d\n" n; None;;
let map_state_int_of_enum : map_state_enum -> int = function `Unmapped -> 0 | `Unviewable -> 1 | `Viewable -> 2;;
type get_window_attributes_reply = { backing_store : backing_store_enum; visual : visualid; class_ : window_class_enum; bit_gravity : gravity_enum; win_gravity : gravity_enum; backing_planes : int; backing_pixel : int; save_under : bool; map_is_installed : bool; map_state : map_state_enum; override_redirect : bool; colormap : colormap_enum alt_enum; all_event_masks : event_mask; your_event_mask : event_mask; do_not_propagate_mask : event_mask; } [@@deriving sexp];;
let encode_get_window_attributes ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_window_attributes_reply length buf ~at : (get_window_attributes_reply * int) option = let orig = at in let at = at + 1 in
let* backing_store, at = decode_enum decode_uint8 identity backing_store_enum_of_int buf ~at in
let at = at + 6 in
let* visual, at = decode_visualid buf ~at in
let* class_, at = decode_enum decode_uint16 identity window_class_enum_of_int buf ~at in
let* bit_gravity, at = decode_enum decode_uint8 identity gravity_enum_of_int buf ~at in
let* win_gravity, at = decode_enum decode_uint8 identity gravity_enum_of_int buf ~at in
let* backing_planes, at = decode_int32 buf ~at in
let* backing_pixel, at = decode_int32 buf ~at in
let* save_under, at = decode_bool buf ~at in
let* map_is_installed, at = decode_bool buf ~at in
let* map_state, at = decode_enum decode_uint8 identity map_state_enum_of_int buf ~at in
let* override_redirect, at = decode_bool buf ~at in
let* colormap, at = decode_alt_enum decode_colormap identity colormap_enum_of_int buf ~at in
let* all_event_masks, at = decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at in
let* your_event_mask, at = decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at in
let* do_not_propagate_mask, at = decode_mask decode_uint16 Int64.of_int event_mask_mask_of_int64 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ backing_store; visual; class_; bit_gravity; win_gravity; backing_planes; backing_pixel; save_under; map_is_installed; map_state; override_redirect; colormap; all_event_masks; your_event_mask; do_not_propagate_mask }, at);;
let encode_destroy_window ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_subwindows ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type set_mode_enum = [ `Insert | `Delete ] [@@deriving sexp];;
let set_mode_enum_of_int : int -> [> set_mode_enum ] option = function 0 -> Some `Insert | 1 -> Some `Delete | n -> Printf.printf "unknown set_mode_enum: %d\n" n; None;;
let set_mode_int_of_enum : set_mode_enum -> int = function `Insert -> 0 | `Delete -> 1;;
let encode_change_save_set ~(mode : set_mode_enum) ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_enum encode_char Char.chr set_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_reparent_window ~(window : window) ~(parent : window) ~(x : int) ~(y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_window buf parent ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_map_window ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_map_subwindows ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_unmap_window ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_unmap_subwindows ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_configure_window ~(window : window) ?(x : int option) ?(y : int option) ?(width : int option) ?(height : int option) ?(border_width : int option) ?(sibling : window_enum alt_enum option) ?(stack_mode : stack_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* field_optional_mask *)let* at = encode_uint16 buf 0 ~at in
let at = at + 2 in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type circulate_enum = [ `Raise_lowest | `Lower_highest ] [@@deriving sexp];;
let circulate_enum_of_int : int -> [> circulate_enum ] option = function 0 -> Some `Raise_lowest | 1 -> Some `Lower_highest | n -> Printf.printf "unknown circulate_enum: %d\n" n; None;;
let circulate_int_of_enum : circulate_enum -> int = function `Raise_lowest -> 0 | `Lower_highest -> 1;;
let encode_circulate_window ~(direction : circulate_enum) ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_enum encode_uint8 identity circulate_int_of_enum buf direction ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_geometry_reply = { depth : int; root : window; x : int; y : int; width : int; height : int; border_width : int; } [@@deriving sexp];;
let encode_get_geometry ~(drawable : drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_geometry_reply length buf ~at : (get_geometry_reply * int) option = let orig = at in let at = at + 1 in
let* depth, at = decode_uint8 buf ~at in
let at = at + 6 in
let* root, at = decode_window buf ~at in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* border_width, at = decode_uint16 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ depth; root; x; y; width; height; border_width }, at);;
type query_tree_reply = { root : window; parent : window_enum alt_enum; children : window list; } [@@deriving sexp];;
let encode_query_tree ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_tree_reply length buf ~at : (query_tree_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* root, at = decode_window buf ~at in
let* parent, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
let* children_len, at = decode_uint16 buf ~at in let children_len = children_len in
let at = at + 14 in
let* children, at = decode_list (decode_window) children_len buf ~at in
ignore orig;
Some ({ root; parent; children }, at);;
type intern_atom_reply = { atom : atom_enum alt_enum; } [@@deriving sexp];;
let encode_intern_atom ~(only_if_exists : bool) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_bool buf only_if_exists ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_intern_atom_reply length buf ~at : (intern_atom_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* atom, at = decode_alt_enum decode_atom identity atom_enum_of_int buf ~at in
ignore orig;
Some ({ atom }, at);;
type get_atom_name_reply = { name : string; } [@@deriving sexp];;
let encode_get_atom_name ~(atom : atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_atom buf atom ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_atom_name_reply length buf ~at : (get_atom_name_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let at = at + 22 in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ name }, at);;
type prop_mode_enum = [ `Replace | `Prepend | `Append ] [@@deriving sexp];;
let prop_mode_enum_of_int : int -> [> prop_mode_enum ] option = function 0 -> Some `Replace | 1 -> Some `Prepend | 2 -> Some `Append | n -> Printf.printf "unknown prop_mode_enum: %d\n" n; None;;
let prop_mode_int_of_enum : prop_mode_enum -> int = function `Replace -> 0 | `Prepend -> 1 | `Append -> 2;;
let encode_change_property ~(mode : prop_mode_enum) ~(window : window) ~(property : atom) ~(type_ : atom) ~(format : int) ~(data_len : int) ~(data : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_enum encode_uint8 identity prop_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_atom buf property ~at in
let* at = encode_atom buf type_ ~at in
let* at = encode_uint8 buf format ~at in
let at = at + 3 in
let* at = encode_int32 buf data_len ~at in
let* at = encode_string buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_property ~(window : window) ~(property : atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_property_type_enum = [ `Any ] [@@deriving sexp];;
let get_property_type_enum_of_int : int -> [> get_property_type_enum ] option = function 0 -> Some `Any | n -> Printf.printf "unknown get_property_type_enum: %d\n" n; None;;
let get_property_type_int_of_enum : get_property_type_enum -> int = function `Any -> 0;;
type get_property_reply = { format : int; type_ : atom; bytes_after : int; value_len : int; value : string; } [@@deriving sexp];;
let encode_get_property ~(delete : bool) ~(window : window) ~(property : atom) ~(type_ : get_property_type_enum alt_enum) ~(long_offset : int) ~(long_length : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_bool buf delete ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_atom buf property ~at in
let* at = encode_alt_enum encode_atom identity get_property_type_int_of_enum buf type_ ~at in
let* at = encode_int32 buf long_offset ~at in
let* at = encode_int32 buf long_length ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_property_reply length buf ~at : (get_property_reply * int) option = let orig = at in let at = at + 1 in
let* format, at = decode_uint8 buf ~at in
let at = at + 6 in
let* type_, at = decode_atom buf ~at in
let* bytes_after, at = decode_int32 buf ~at in
let* value_len, at = decode_int32 buf ~at in
let at = at + 12 in
let* value, at = let length = (value_len) * ((format) / (8)) in decode_string length buf ~at in
ignore orig;
Some ({ format; type_; bytes_after; value_len; value }, at);;
type list_properties_reply = { atoms : atom list; } [@@deriving sexp];;
let encode_list_properties ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_properties_reply length buf ~at : (list_properties_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* atoms_len, at = decode_uint16 buf ~at in let atoms_len = atoms_len in
let at = at + 22 in
let* atoms, at = decode_list (decode_atom) atoms_len buf ~at in
ignore orig;
Some ({ atoms }, at);;
let encode_set_selection_owner ~(owner : window_enum alt_enum) ~(selection : atom) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf owner ~at in
let* at = encode_atom buf selection ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_selection_owner_reply = { owner : window_enum alt_enum; } [@@deriving sexp];;
let encode_get_selection_owner ~(selection : atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_atom buf selection ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_selection_owner_reply length buf ~at : (get_selection_owner_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* owner, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
ignore orig;
Some ({ owner }, at);;
let encode_convert_selection ~(requestor : window) ~(selection : atom) ~(target : atom) ~(property : atom_enum alt_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf requestor ~at in
let* at = encode_atom buf selection ~at in
let* at = encode_atom buf target ~at in
let* at = encode_alt_enum encode_atom identity atom_int_of_enum buf property ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type send_event_dest_enum = [ `Pointer_window | `Item_focus ] [@@deriving sexp];;
let send_event_dest_enum_of_int : int -> [> send_event_dest_enum ] option = function 0 -> Some `Pointer_window | 1 -> Some `Item_focus | n -> Printf.printf "unknown send_event_dest_enum: %d\n" n; None;;
let send_event_dest_int_of_enum : send_event_dest_enum -> int = function `Pointer_window -> 0 | `Item_focus -> 1;;
let encode_send_event ~(propagate : bool) ~(destination : send_event_dest_enum alt_enum) ~(event_mask : event_mask) ~(event : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in
let* at = encode_bool buf propagate ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity send_event_dest_int_of_enum buf destination ~at in
let* at = encode_mask encode_int32 identity event_mask_int_of_mask buf event_mask ~at in
let* at = encode_string buf event ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type grab_mode_enum = [ `Sync | `Async ] [@@deriving sexp];;
let grab_mode_enum_of_int : int -> [> grab_mode_enum ] option = function 0 -> Some `Sync | 1 -> Some `Async | n -> Printf.printf "unknown grab_mode_enum: %d\n" n; None;;
let grab_mode_int_of_enum : grab_mode_enum -> int = function `Sync -> 0 | `Async -> 1;;
type grab_status_enum = [ `Success | `Already_grabbed | `Invalid_time | `Not_viewable | `Frozen ] [@@deriving sexp];;
let grab_status_enum_of_int : int -> [> grab_status_enum ] option = function 0 -> Some `Success | 1 -> Some `Already_grabbed | 2 -> Some `Invalid_time | 3 -> Some `Not_viewable | 4 -> Some `Frozen | n -> Printf.printf "unknown grab_status_enum: %d\n" n; None;;
let grab_status_int_of_enum : grab_status_enum -> int = function `Success -> 0 | `Already_grabbed -> 1 | `Invalid_time -> 2 | `Not_viewable -> 3 | `Frozen -> 4;;
type grab_pointer_reply = { status : grab_status_enum; } [@@deriving sexp];;
let encode_grab_pointer ~(owner_events : bool) ~(grab_window : window) ~(event_mask : event_mask) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) ~(confine_to : window_enum alt_enum) ~(cursor : cursor_enum alt_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf keyboard_mode ~at in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf confine_to ~at in
let* at = encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_grab_pointer_reply length buf ~at : (grab_pointer_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code grab_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
let encode_ungrab_pointer ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type button_index_enum = [ `Any | `D1 | `D2 | `D3 | `D4 | `D5 ] [@@deriving sexp];;
let button_index_enum_of_int : int -> [> button_index_enum ] option = function 0 -> Some `Any | 1 -> Some `D1 | 2 -> Some `D2 | 3 -> Some `D3 | 4 -> Some `D4 | 5 -> Some `D5 | n -> Printf.printf "unknown button_index_enum: %d\n" n; None;;
let button_index_int_of_enum : button_index_enum -> int = function `Any -> 0 | `D1 -> 1 | `D2 -> 2 | `D3 -> 3 | `D4 -> 4 | `D5 -> 5;;
let encode_grab_button ~(owner_events : bool) ~(grab_window : window) ~(event_mask : event_mask) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) ~(confine_to : window_enum alt_enum) ~(cursor : cursor_enum alt_enum) ~(button : button_index_enum) ~(modifiers : mod_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf keyboard_mode ~at in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf confine_to ~at in
let* at = encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor ~at in
let* at = encode_enum encode_uint8 identity button_index_int_of_enum buf button ~at in
let at = at + 1 in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_ungrab_button ~(button : button_index_enum) ~(grab_window : window) ~(modifiers : mod_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = encode_enum encode_uint8 identity button_index_int_of_enum buf button ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_active_pointer_grab ~(cursor : cursor_enum alt_enum) ~(time : time_enum alt_enum) ~(event_mask : event_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
let* at = encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type grab_keyboard_reply = { status : grab_status_enum; } [@@deriving sexp];;
let encode_grab_keyboard ~(owner_events : bool) ~(grab_window : window) ~(time : time_enum alt_enum) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_char Char.chr grab_mode_int_of_enum buf keyboard_mode ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_grab_keyboard_reply length buf ~at : (grab_keyboard_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code grab_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
let encode_ungrab_keyboard ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type grab_enum = [ `Any ] [@@deriving sexp];;
let grab_enum_of_int : int -> [> grab_enum ] option = function 0 -> Some `Any | n -> Printf.printf "unknown grab_enum: %d\n" n; None;;
let grab_int_of_enum : grab_enum -> int = function `Any -> 0;;
let encode_grab_key ~(owner_events : bool) ~(grab_window : window) ~(modifiers : mod_mask) ~(key : grab_enum alt_enum) ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 33 ~at in
let* at = encode_bool buf owner_events ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
let* at = encode_alt_enum encode_keycode identity grab_int_of_enum buf key ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf pointer_mode ~at in
let* at = encode_enum encode_uint8 identity grab_mode_int_of_enum buf keyboard_mode ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_ungrab_key ~(key : grab_enum alt_enum) ~(grab_window : window) ~(modifiers : mod_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 34 ~at in
let* at = encode_alt_enum encode_keycode identity grab_int_of_enum buf key ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf grab_window ~at in
let* at = encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type allow_enum = [ `Async_pointer | `Sync_pointer | `Replay_pointer | `Async_keyboard | `Sync_keyboard | `Replay_keyboard | `Async_both | `Sync_both ] [@@deriving sexp];;
let allow_enum_of_int : int -> [> allow_enum ] option = function 0 -> Some `Async_pointer | 1 -> Some `Sync_pointer | 2 -> Some `Replay_pointer | 3 -> Some `Async_keyboard | 4 -> Some `Sync_keyboard | 5 -> Some `Replay_keyboard | 6 -> Some `Async_both | 7 -> Some `Sync_both | n -> Printf.printf "unknown allow_enum: %d\n" n; None;;
let allow_int_of_enum : allow_enum -> int = function `Async_pointer -> 0 | `Sync_pointer -> 1 | `Replay_pointer -> 2 | `Async_keyboard -> 3 | `Sync_keyboard -> 4 | `Replay_keyboard -> 5 | `Async_both -> 6 | `Sync_both -> 7;;
let encode_allow_events ~(mode : allow_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 35 ~at in
let* at = encode_enum encode_uint8 identity allow_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_grab_server  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 36 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_ungrab_server  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 37 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_pointer_reply = { same_screen : bool; root : window; child : window_enum alt_enum; root_x : int; root_y : int; win_x : int; win_y : int; mask : key_but_mask; } [@@deriving sexp];;
let encode_query_pointer ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 38 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_pointer_reply length buf ~at : (query_pointer_reply * int) option = let orig = at in let at = at + 1 in
let* same_screen, at = decode_bool buf ~at in
let at = at + 6 in
let* root, at = decode_window buf ~at in
let* child, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
let* root_x, at = decode_int16 buf ~at in
let* root_y, at = decode_int16 buf ~at in
let* win_x, at = decode_int16 buf ~at in
let* win_y, at = decode_int16 buf ~at in
let* mask, at = decode_mask decode_uint16 Int64.of_int key_but_mask_mask_of_int64 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ same_screen; root; child; root_x; root_y; win_x; win_y; mask }, at);;
type timecoord = { time : timestamp; x : int; y : int; } [@@deriving sexp];;
let decode_timecoord buf ~at : (timecoord * int) option = let orig = at in let* time, at = decode_timestamp buf ~at in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
ignore orig;
Some ({ time; x; y }, at);;
let encode_timecoord buf (v : timecoord) ~at : int option = let orig = at in let* at = encode_timestamp buf v.time ~at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in ignore orig; Some at;;

type get_motion_events_reply = { events : timecoord list; } [@@deriving sexp];;
let encode_get_motion_events ~(window : window) ~(start : time_enum alt_enum) ~(stop : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 39 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf start ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf stop ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_motion_events_reply length buf ~at : (get_motion_events_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* events_len, at = decode_int32 buf ~at in let events_len = events_len in
let at = at + 20 in
let* events, at = decode_list (decode_timecoord) events_len buf ~at in
ignore orig;
Some ({ events }, at);;
type translate_coordinates_reply = { same_screen : bool; child : window_enum alt_enum; dst_x : int; dst_y : int; } [@@deriving sexp];;
let encode_translate_coordinates ~(src_window : window) ~(dst_window : window) ~(src_x : int) ~(src_y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 40 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf src_window ~at in
let* at = encode_window buf dst_window ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_translate_coordinates_reply length buf ~at : (translate_coordinates_reply * int) option = let orig = at in let at = at + 1 in
let* same_screen, at = decode_bool buf ~at in
let at = at + 6 in
let* child, at = decode_alt_enum decode_window identity window_enum_of_int buf ~at in
let* dst_x, at = decode_int16 buf ~at in
let* dst_y, at = decode_int16 buf ~at in
ignore orig;
Some ({ same_screen; child; dst_x; dst_y }, at);;
let encode_warp_pointer ~(src_window : window_enum alt_enum) ~(dst_window : window_enum alt_enum) ~(src_x : int) ~(src_y : int) ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 41 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf src_window ~at in
let* at = encode_alt_enum encode_window identity window_int_of_enum buf dst_window ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_uint16 buf src_width ~at in
let* at = encode_uint16 buf src_height ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type input_focus_enum = [ `None | `Pointer_root | `Parent | `Follow_keyboard ] [@@deriving sexp];;
let input_focus_enum_of_int : int -> [> input_focus_enum ] option = function 0 -> Some `None | 1 -> Some `Pointer_root | 2 -> Some `Parent | 3 -> Some `Follow_keyboard | n -> Printf.printf "unknown input_focus_enum: %d\n" n; None;;
let input_focus_int_of_enum : input_focus_enum -> int = function `None -> 0 | `Pointer_root -> 1 | `Parent -> 2 | `Follow_keyboard -> 3;;
let encode_set_input_focus ~(revert_to : input_focus_enum) ~(focus : input_focus_enum alt_enum) ~(time : time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 42 ~at in
let* at = encode_enum encode_uint8 identity input_focus_int_of_enum buf revert_to ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_window identity input_focus_int_of_enum buf focus ~at in
let* at = encode_alt_enum encode_timestamp identity time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_input_focus_reply = { revert_to : input_focus_enum; focus : input_focus_enum alt_enum; } [@@deriving sexp];;
let encode_get_input_focus  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 43 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_input_focus_reply length buf ~at : (get_input_focus_reply * int) option = let orig = at in let at = at + 1 in
let* revert_to, at = decode_enum decode_uint8 identity input_focus_enum_of_int buf ~at in
let at = at + 6 in
let* focus, at = decode_alt_enum decode_window identity input_focus_enum_of_int buf ~at in
ignore orig;
Some ({ revert_to; focus }, at);;
type query_keymap_reply = { keys : int list; } [@@deriving sexp];;
let encode_query_keymap  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 44 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_keymap_reply length buf ~at : (query_keymap_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* keys, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ keys }, at);;
let encode_open_font ~(fid : font) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 45 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_font buf fid ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_close_font ~(font : font)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 46 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_font buf font ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type font_draw_enum = [ `Left_to_right | `Right_to_left ] [@@deriving sexp];;
let font_draw_enum_of_int : int -> [> font_draw_enum ] option = function 0 -> Some `Left_to_right | 1 -> Some `Right_to_left | n -> Printf.printf "unknown font_draw_enum: %d\n" n; None;;
let font_draw_int_of_enum : font_draw_enum -> int = function `Left_to_right -> 0 | `Right_to_left -> 1;;
type fontprop = { name : atom; value : int; } [@@deriving sexp];;
let decode_fontprop buf ~at : (fontprop * int) option = let orig = at in let* name, at = decode_atom buf ~at in
let* value, at = decode_int32 buf ~at in
ignore orig;
Some ({ name; value }, at);;
let encode_fontprop buf (v : fontprop) ~at : int option = let orig = at in let* at = encode_atom buf v.name ~at in let* at = encode_int32 buf v.value ~at in ignore orig; Some at;;

type charinfo = { left_side_bearing : int; right_side_bearing : int; character_width : int; ascent : int; descent : int; attributes : int; } [@@deriving sexp];;
let decode_charinfo buf ~at : (charinfo * int) option = let orig = at in let* left_side_bearing, at = decode_int16 buf ~at in
let* right_side_bearing, at = decode_int16 buf ~at in
let* character_width, at = decode_int16 buf ~at in
let* ascent, at = decode_int16 buf ~at in
let* descent, at = decode_int16 buf ~at in
let* attributes, at = decode_uint16 buf ~at in
ignore orig;
Some ({ left_side_bearing; right_side_bearing; character_width; ascent; descent; attributes }, at);;
let encode_charinfo buf (v : charinfo) ~at : int option = let orig = at in let* at = encode_int16 buf v.left_side_bearing ~at in let* at = encode_int16 buf v.right_side_bearing ~at in let* at = encode_int16 buf v.character_width ~at in let* at = encode_int16 buf v.ascent ~at in let* at = encode_int16 buf v.descent ~at in let* at = encode_uint16 buf v.attributes ~at in ignore orig; Some at;;

type query_font_reply = { min_bounds : charinfo; max_bounds : charinfo; min_char_or_byte2 : int; max_char_or_byte2 : int; default_char : int; draw_direction : font_draw_enum; min_byte1 : int; max_byte1 : int; all_chars_exist : bool; font_ascent : int; font_descent : int; properties : fontprop list; char_infos : charinfo list; } [@@deriving sexp];;
let encode_query_font ~(font : fontable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 47 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fontable buf font ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_font_reply length buf ~at : (query_font_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* min_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* max_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* min_char_or_byte2, at = decode_uint16 buf ~at in
let* max_char_or_byte2, at = decode_uint16 buf ~at in
let* default_char, at = decode_uint16 buf ~at in
let* properties_len, at = decode_uint16 buf ~at in let properties_len = properties_len in
let* draw_direction, at = decode_enum decode_char Char.code font_draw_enum_of_int buf ~at in
let* min_byte1, at = decode_uint8 buf ~at in
let* max_byte1, at = decode_uint8 buf ~at in
let* all_chars_exist, at = decode_bool buf ~at in
let* font_ascent, at = decode_int16 buf ~at in
let* font_descent, at = decode_int16 buf ~at in
let* char_infos_len, at = decode_int32 buf ~at in let char_infos_len = char_infos_len in
let* properties, at = decode_list (decode_fontprop) properties_len buf ~at in
let* char_infos, at = decode_list (decode_charinfo) char_infos_len buf ~at in
ignore orig;
Some ({ min_bounds; max_bounds; min_char_or_byte2; max_char_or_byte2; default_char; draw_direction; min_byte1; max_byte1; all_chars_exist; font_ascent; font_descent; properties; char_infos }, at);;

type str = { name : string; } [@@deriving sexp];;
let decode_str buf ~at : (str * int) option = let orig = at in let* name_len, at = decode_uint8 buf ~at in let name_len = name_len in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ name }, at);;
let encode_str buf (v : str) ~at : int option = let orig = at in let* at = encode_uint8 buf (identity (String.length v.name)) ~at in let* at = encode_string buf v.name ~at in ignore orig; Some at;;

type list_fonts_reply = { names : str list; } [@@deriving sexp];;
let encode_list_fonts ~(max_names : int) ~(pattern : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 49 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf max_names ~at in
let* at = encode_uint16 buf (identity (String.length pattern)) ~at in
let* at = encode_string buf pattern ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_fonts_reply length buf ~at : (list_fonts_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* names_len, at = decode_uint16 buf ~at in let names_len = names_len in
let at = at + 22 in
let* names, at = decode_list (decode_str) names_len buf ~at in
ignore orig;
Some ({ names }, at);;
type list_fonts_with_info_reply = { min_bounds : charinfo; max_bounds : charinfo; min_char_or_byte2 : int; max_char_or_byte2 : int; default_char : int; draw_direction : font_draw_enum; min_byte1 : int; max_byte1 : int; all_chars_exist : bool; font_ascent : int; font_descent : int; replies_hint : int; properties : fontprop list; name : string; } [@@deriving sexp];;
let encode_list_fonts_with_info ~(max_names : int) ~(pattern : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 50 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf max_names ~at in
let* at = encode_uint16 buf (identity (String.length pattern)) ~at in
let* at = encode_string buf pattern ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_fonts_with_info_reply length buf ~at : (list_fonts_with_info_reply * int) option = let orig = at in let at = at + 1 in
let* name_len, at = decode_uint8 buf ~at in let name_len = name_len in
let at = at + 6 in
let* min_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* max_bounds, at = decode_charinfo buf ~at in
let at = at + 4 in
let* min_char_or_byte2, at = decode_uint16 buf ~at in
let* max_char_or_byte2, at = decode_uint16 buf ~at in
let* default_char, at = decode_uint16 buf ~at in
let* properties_len, at = decode_uint16 buf ~at in let properties_len = properties_len in
let* draw_direction, at = decode_enum decode_char Char.code font_draw_enum_of_int buf ~at in
let* min_byte1, at = decode_uint8 buf ~at in
let* max_byte1, at = decode_uint8 buf ~at in
let* all_chars_exist, at = decode_bool buf ~at in
let* font_ascent, at = decode_int16 buf ~at in
let* font_descent, at = decode_int16 buf ~at in
let* replies_hint, at = decode_int32 buf ~at in
let* properties, at = decode_list (decode_fontprop) properties_len buf ~at in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ min_bounds; max_bounds; min_char_or_byte2; max_char_or_byte2; default_char; draw_direction; min_byte1; max_byte1; all_chars_exist; font_ascent; font_descent; replies_hint; properties; name }, at);;
let encode_set_font_path ~(font : str list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 51 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length font)) ~at in
let at = at + 2 in
let* at = encode_list encode_str buf font ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_font_path_reply = { path : str list; } [@@deriving sexp];;
let encode_get_font_path  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 52 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_font_path_reply length buf ~at : (get_font_path_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* path_len, at = decode_uint16 buf ~at in let path_len = path_len in
let at = at + 22 in
let* path, at = decode_list (decode_str) path_len buf ~at in
ignore orig;
Some ({ path }, at);;
let encode_create_pixmap ~(depth : int) ~(pid : pixmap) ~(drawable : drawable) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 53 ~at in
let* at = encode_uint8 buf depth ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pixmap buf pid ~at in
let* at = encode_drawable buf drawable ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_pixmap ~(pixmap : pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 54 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pixmap buf pixmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type gc_mask = [ `Function | `Plane_mask | `Foreground | `Background | `Line_width | `Line_style | `Cap_style | `Join_style | `Fill_style | `Fill_rule | `Tile | `Stipple | `Tile_stipple_origin_x | `Tile_stipple_origin_y | `Font | `Subwindow_mode | `Graphics_exposures | `Clip_origin_x | `Clip_origin_y | `Clip_mask | `Dash_offset | `Dash_list | `Arc_mode ] list [@@deriving sexp];;
let gc_mask_of_int64 mask : gc_mask option = let of_int = function 0 -> Some `Function | 1 -> Some `Plane_mask | 2 -> Some `Foreground | 3 -> Some `Background | 4 -> Some `Line_width | 5 -> Some `Line_style | 6 -> Some `Cap_style | 7 -> Some `Join_style | 8 -> Some `Fill_style | 9 -> Some `Fill_rule | 10 -> Some `Tile | 11 -> Some `Stipple | 12 -> Some `Tile_stipple_origin_x | 13 -> Some `Tile_stipple_origin_y | 14 -> Some `Font | 15 -> Some `Subwindow_mode | 16 -> Some `Graphics_exposures | 17 -> Some `Clip_origin_x | 18 -> Some `Clip_origin_y | 19 -> Some `Clip_mask | 20 -> Some `Dash_offset | 21 -> Some `Dash_list | 22 -> Some `Arc_mode | _ -> None in mask_of_int of_int mask;;
let gc_int_of_mask : gc_mask -> int = let to_bit = function `Function -> 0 | `Plane_mask -> 1 | `Foreground -> 2 | `Background -> 3 | `Line_width -> 4 | `Line_style -> 5 | `Cap_style -> 6 | `Join_style -> 7 | `Fill_style -> 8 | `Fill_rule -> 9 | `Tile -> 10 | `Stipple -> 11 | `Tile_stipple_origin_x -> 12 | `Tile_stipple_origin_y -> 13 | `Font -> 14 | `Subwindow_mode -> 15 | `Graphics_exposures -> 16 | `Clip_origin_x -> 17 | `Clip_origin_y -> 18 | `Clip_mask -> 19 | `Dash_offset -> 20 | `Dash_list -> 21 | `Arc_mode -> 22 in int_of_mask to_bit;;
type gx_enum = [ `Clear | `And | `And_reverse | `Copy | `And_inverted | `Noop | `Xor | `Or | `Nor | `Equiv | `Invert | `Or_reverse | `Copy_inverted | `Or_inverted | `Nand | `Set ] [@@deriving sexp];;
let gx_enum_of_int : int -> [> gx_enum ] option = function 0 -> Some `Clear | 1 -> Some `And | 2 -> Some `And_reverse | 3 -> Some `Copy | 4 -> Some `And_inverted | 5 -> Some `Noop | 6 -> Some `Xor | 7 -> Some `Or | 8 -> Some `Nor | 9 -> Some `Equiv | 10 -> Some `Invert | 11 -> Some `Or_reverse | 12 -> Some `Copy_inverted | 13 -> Some `Or_inverted | 14 -> Some `Nand | 15 -> Some `Set | n -> Printf.printf "unknown gx_enum: %d\n" n; None;;
let gx_int_of_enum : gx_enum -> int = function `Clear -> 0 | `And -> 1 | `And_reverse -> 2 | `Copy -> 3 | `And_inverted -> 4 | `Noop -> 5 | `Xor -> 6 | `Or -> 7 | `Nor -> 8 | `Equiv -> 9 | `Invert -> 10 | `Or_reverse -> 11 | `Copy_inverted -> 12 | `Or_inverted -> 13 | `Nand -> 14 | `Set -> 15;;
type line_style_enum = [ `Solid | `On_off_dash | `Double_dash ] [@@deriving sexp];;
let line_style_enum_of_int : int -> [> line_style_enum ] option = function 0 -> Some `Solid | 1 -> Some `On_off_dash | 2 -> Some `Double_dash | n -> Printf.printf "unknown line_style_enum: %d\n" n; None;;
let line_style_int_of_enum : line_style_enum -> int = function `Solid -> 0 | `On_off_dash -> 1 | `Double_dash -> 2;;
type cap_style_enum = [ `Not_last | `Butt | `Round | `Projecting ] [@@deriving sexp];;
let cap_style_enum_of_int : int -> [> cap_style_enum ] option = function 0 -> Some `Not_last | 1 -> Some `Butt | 2 -> Some `Round | 3 -> Some `Projecting | n -> Printf.printf "unknown cap_style_enum: %d\n" n; None;;
let cap_style_int_of_enum : cap_style_enum -> int = function `Not_last -> 0 | `Butt -> 1 | `Round -> 2 | `Projecting -> 3;;
type join_style_enum = [ `Miter | `Round | `Bevel ] [@@deriving sexp];;
let join_style_enum_of_int : int -> [> join_style_enum ] option = function 0 -> Some `Miter | 1 -> Some `Round | 2 -> Some `Bevel | n -> Printf.printf "unknown join_style_enum: %d\n" n; None;;
let join_style_int_of_enum : join_style_enum -> int = function `Miter -> 0 | `Round -> 1 | `Bevel -> 2;;
type fill_style_enum = [ `Solid | `Tiled | `Stippled | `Opaque_stippled ] [@@deriving sexp];;
let fill_style_enum_of_int : int -> [> fill_style_enum ] option = function 0 -> Some `Solid | 1 -> Some `Tiled | 2 -> Some `Stippled | 3 -> Some `Opaque_stippled | n -> Printf.printf "unknown fill_style_enum: %d\n" n; None;;
let fill_style_int_of_enum : fill_style_enum -> int = function `Solid -> 0 | `Tiled -> 1 | `Stippled -> 2 | `Opaque_stippled -> 3;;
type fill_rule_enum = [ `Even_odd | `Winding ] [@@deriving sexp];;
let fill_rule_enum_of_int : int -> [> fill_rule_enum ] option = function 0 -> Some `Even_odd | 1 -> Some `Winding | n -> Printf.printf "unknown fill_rule_enum: %d\n" n; None;;
let fill_rule_int_of_enum : fill_rule_enum -> int = function `Even_odd -> 0 | `Winding -> 1;;
type subwindow_mode_enum = [ `Clip_by_children | `Include_inferiors ] [@@deriving sexp];;
let subwindow_mode_enum_of_int : int -> [> subwindow_mode_enum ] option = function 0 -> Some `Clip_by_children | 1 -> Some `Include_inferiors | n -> Printf.printf "unknown subwindow_mode_enum: %d\n" n; None;;
let subwindow_mode_int_of_enum : subwindow_mode_enum -> int = function `Clip_by_children -> 0 | `Include_inferiors -> 1;;
type arc_mode_enum = [ `Chord | `Pie_slice ] [@@deriving sexp];;
let arc_mode_enum_of_int : int -> [> arc_mode_enum ] option = function 0 -> Some `Chord | 1 -> Some `Pie_slice | n -> Printf.printf "unknown arc_mode_enum: %d\n" n; None;;
let arc_mode_int_of_enum : arc_mode_enum -> int = function `Chord -> 0 | `Pie_slice -> 1;;
type font_enum = [ `None ] [@@deriving sexp];;
let font_enum_of_int : int -> [> font_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown font_enum: %d\n" n; None;;
let font_int_of_enum : font_enum -> int = function `None -> 0;;
let encode_create_gc ~(cid : gcontext) ~(drawable : drawable) ?(function_ : gx_enum option) ?(plane_mask : int option) ?(foreground : int option) ?(background : int option) ?(line_width : int option) ?(line_style : line_style_enum option) ?(cap_style : cap_style_enum option) ?(join_style : join_style_enum option) ?(fill_style : fill_style_enum option) ?(fill_rule : fill_rule_enum option) ?(tile : pixmap_enum alt_enum option) ?(stipple : pixmap_enum alt_enum option) ?(tile_stipple_x_origin : int option) ?(tile_stipple_y_origin : int option) ?(font : font_enum alt_enum option) ?(subwindow_mode : subwindow_mode_enum option) ?(graphics_exposures : bool32 option) ?(clip_x_origin : int option) ?(clip_y_origin : int option) ?(clip_mask : pixmap_enum alt_enum option) ?(dash_offset : int option) ?(dashes : int option) ?(arc_mode : arc_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 55 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf cid ~at in
let* at = encode_drawable buf drawable ~at in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_gc ~(gc : gcontext) ?(function_ : gx_enum option) ?(plane_mask : int option) ?(foreground : int option) ?(background : int option) ?(line_width : int option) ?(line_style : line_style_enum option) ?(cap_style : cap_style_enum option) ?(join_style : join_style_enum option) ?(fill_style : fill_style_enum option) ?(fill_rule : fill_rule_enum option) ?(tile : pixmap_enum alt_enum option) ?(stipple : pixmap_enum alt_enum option) ?(tile_stipple_x_origin : int option) ?(tile_stipple_y_origin : int option) ?(font : font_enum alt_enum option) ?(subwindow_mode : subwindow_mode_enum option) ?(graphics_exposures : bool32 option) ?(clip_x_origin : int option) ?(clip_y_origin : int option) ?(clip_mask : pixmap_enum alt_enum option) ?(dash_offset : int option) ?(dashes : int option) ?(arc_mode : arc_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 56 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_copy_gc ~(src_gc : gcontext) ~(dst_gc : gcontext) ~(value_mask : gc_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 57 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf src_gc ~at in
let* at = encode_gcontext buf dst_gc ~at in
let* at = encode_mask encode_int32 identity gc_int_of_mask buf value_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_dashes ~(gc : gcontext) ~(dash_offset : int) ~(dashes : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 58 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
let* at = encode_uint16 buf dash_offset ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card8 *) List.length dashes)) ~at in
let* at = encode_list encode_uint8 buf dashes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type clip_ordering_enum = [ `Unsorted | `Y_sorted | `Yx_sorted | `Yx_banded ] [@@deriving sexp];;
let clip_ordering_enum_of_int : int -> [> clip_ordering_enum ] option = function 0 -> Some `Unsorted | 1 -> Some `Y_sorted | 2 -> Some `Yx_sorted | 3 -> Some `Yx_banded | n -> Printf.printf "unknown clip_ordering_enum: %d\n" n; None;;
let clip_ordering_int_of_enum : clip_ordering_enum -> int = function `Unsorted -> 0 | `Y_sorted -> 1 | `Yx_sorted -> 2 | `Yx_banded -> 3;;
let encode_set_clip_rectangles ~(ordering : clip_ordering_enum) ~(gc : gcontext) ~(clip_x_origin : int) ~(clip_y_origin : int) ~(rectangles : rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 59 ~at in
let* at = encode_enum encode_char Char.chr clip_ordering_int_of_enum buf ordering ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf clip_x_origin ~at in
let* at = encode_int16 buf clip_y_origin ~at in
let* at = encode_list encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_gc ~(gc : gcontext)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 60 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_gcontext buf gc ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_clear_area ~(exposures : bool) ~(window : window) ~(x : int) ~(y : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 61 ~at in
let* at = encode_bool buf exposures ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_copy_area ~(src_drawable : drawable) ~(dst_drawable : drawable) ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 62 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf src_drawable ~at in
let* at = encode_drawable buf dst_drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_copy_plane ~(src_drawable : drawable) ~(dst_drawable : drawable) ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int) ~(bit_plane : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 63 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf src_drawable ~at in
let* at = encode_drawable buf dst_drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf bit_plane ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type coord_mode_enum = [ `Origin | `Previous ] [@@deriving sexp];;
let coord_mode_enum_of_int : int -> [> coord_mode_enum ] option = function 0 -> Some `Origin | 1 -> Some `Previous | n -> Printf.printf "unknown coord_mode_enum: %d\n" n; None;;
let coord_mode_int_of_enum : coord_mode_enum -> int = function `Origin -> 0 | `Previous -> 1;;
let encode_poly_point ~(coordinate_mode : coord_mode_enum) ~(drawable : drawable) ~(gc : gcontext) ~(points : point list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 64 ~at in
let* at = encode_enum encode_char Char.chr coord_mode_int_of_enum buf coordinate_mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_point buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_poly_line ~(coordinate_mode : coord_mode_enum) ~(drawable : drawable) ~(gc : gcontext) ~(points : point list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 65 ~at in
let* at = encode_enum encode_char Char.chr coord_mode_int_of_enum buf coordinate_mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_point buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type segment = { x1 : int; y1 : int; x2 : int; y2 : int; } [@@deriving sexp];;
let decode_segment buf ~at : (segment * int) option = let orig = at in let* x1, at = decode_int16 buf ~at in
let* y1, at = decode_int16 buf ~at in
let* x2, at = decode_int16 buf ~at in
let* y2, at = decode_int16 buf ~at in
ignore orig;
Some ({ x1; y1; x2; y2 }, at);;
let encode_segment buf (v : segment) ~at : int option = let orig = at in let* at = encode_int16 buf v.x1 ~at in let* at = encode_int16 buf v.y1 ~at in let* at = encode_int16 buf v.x2 ~at in let* at = encode_int16 buf v.y2 ~at in ignore orig; Some at;;

let encode_poly_segment ~(drawable : drawable) ~(gc : gcontext) ~(segments : segment list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 66 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_segment buf segments ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_poly_rectangle ~(drawable : drawable) ~(gc : gcontext) ~(rectangles : rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 67 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_poly_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 68 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_arc buf arcs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type poly_shape_enum = [ `Complex | `Nonconvex | `Convex ] [@@deriving sexp];;
let poly_shape_enum_of_int : int -> [> poly_shape_enum ] option = function 0 -> Some `Complex | 1 -> Some `Nonconvex | 2 -> Some `Convex | n -> Printf.printf "unknown poly_shape_enum: %d\n" n; None;;
let poly_shape_int_of_enum : poly_shape_enum -> int = function `Complex -> 0 | `Nonconvex -> 1 | `Convex -> 2;;
let encode_fill_poly ~(drawable : drawable) ~(gc : gcontext) ~(shape : poly_shape_enum) ~(coordinate_mode : coord_mode_enum) ~(points : point list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 69 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_enum encode_uint8 identity poly_shape_int_of_enum buf shape ~at in
let* at = encode_enum encode_uint8 identity coord_mode_int_of_enum buf coordinate_mode ~at in
let at = at + 2 in
let* at = encode_list encode_point buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_poly_fill_rectangle ~(drawable : drawable) ~(gc : gcontext) ~(rectangles : rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 70 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_poly_fill_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 71 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_list encode_arc buf arcs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type image_format_enum = [ `Xy_bitmap | `Xy_pixmap | `Z_pixmap ] [@@deriving sexp];;
let image_format_enum_of_int : int -> [> image_format_enum ] option = function 0 -> Some `Xy_bitmap | 1 -> Some `Xy_pixmap | 2 -> Some `Z_pixmap | n -> Printf.printf "unknown image_format_enum: %d\n" n; None;;
let image_format_int_of_enum : image_format_enum -> int = function `Xy_bitmap -> 0 | `Xy_pixmap -> 1 | `Z_pixmap -> 2;;
let encode_put_image ~(format : image_format_enum) ~(drawable : drawable) ~(gc : gcontext) ~(width : int) ~(height : int) ~(dst_x : int) ~(dst_y : int) ~(left_pad : int) ~(depth : int) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 72 ~at in
let* at = encode_enum encode_uint8 identity image_format_int_of_enum buf format ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint8 buf left_pad ~at in
let* at = encode_uint8 buf depth ~at in
let at = at + 2 in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_image_reply = { depth : int; visual : visualid; data : char list; } [@@deriving sexp];;
let encode_get_image ~(format : image_format_enum) ~(drawable : drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(plane_mask : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 73 ~at in
let* at = encode_enum encode_uint8 identity image_format_int_of_enum buf format ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf plane_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_image_reply length buf ~at : (get_image_reply * int) option = let orig = at in let at = at + 1 in
let* depth, at = decode_uint8 buf ~at in
let at = at + 6 in
let* visual, at = decode_visualid buf ~at in
let at = at + 20 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ depth; visual; data }, at);;
let encode_poly_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(items : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 74 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_list encode_char buf items ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_poly_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(items : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 75 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_list encode_char buf items ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_image_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(string : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 76 ~at in
let* at = encode_char buf (Char.chr (String.length string)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_string buf string ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_image_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int) ~(y : int) ~(string : char2b list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 77 ~at in
let* at = encode_char buf (Char.chr ((* invalid_argument *) List.length string)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_gcontext buf gc ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_list encode_char2b buf string ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type colormap_alloc_enum = [ `None | `All ] [@@deriving sexp];;
let colormap_alloc_enum_of_int : int -> [> colormap_alloc_enum ] option = function 0 -> Some `None | 1 -> Some `All | n -> Printf.printf "unknown colormap_alloc_enum: %d\n" n; None;;
let colormap_alloc_int_of_enum : colormap_alloc_enum -> int = function `None -> 0 | `All -> 1;;
let encode_create_colormap ~(alloc : colormap_alloc_enum) ~(mid : colormap) ~(window : window) ~(visual : visualid)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 78 ~at in
let* at = encode_enum encode_char Char.chr colormap_alloc_int_of_enum buf alloc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf mid ~at in
let* at = encode_window buf window ~at in
let* at = encode_visualid buf visual ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_colormap ~(cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 79 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_copy_colormap_and_free ~(mid : colormap) ~(src_cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 80 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf mid ~at in
let* at = encode_colormap buf src_cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_install_colormap ~(cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 81 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_uninstall_colormap ~(cmap : colormap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 82 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type list_installed_colormaps_reply = { cmaps : colormap list; } [@@deriving sexp];;
let encode_list_installed_colormaps ~(window : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 83 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_installed_colormaps_reply length buf ~at : (list_installed_colormaps_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* cmaps_len, at = decode_uint16 buf ~at in let cmaps_len = cmaps_len in
let at = at + 22 in
let* cmaps, at = decode_list (decode_colormap) cmaps_len buf ~at in
ignore orig;
Some ({ cmaps }, at);;
type alloc_color_reply = { red : int; green : int; blue : int; pixel : int; } [@@deriving sexp];;
let encode_alloc_color ~(cmap : colormap) ~(red : int) ~(green : int) ~(blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 84 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf red ~at in
let* at = encode_uint16 buf green ~at in
let* at = encode_uint16 buf blue ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_alloc_color_reply length buf ~at : (alloc_color_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let at = at + 2 in
let* pixel, at = decode_int32 buf ~at in
ignore orig;
Some ({ red; green; blue; pixel }, at);;
type alloc_named_color_reply = { pixel : int; exact_red : int; exact_green : int; exact_blue : int; visual_red : int; visual_green : int; visual_blue : int; } [@@deriving sexp];;
let encode_alloc_named_color ~(cmap : colormap) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 85 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_alloc_named_color_reply length buf ~at : (alloc_named_color_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pixel, at = decode_int32 buf ~at in
let* exact_red, at = decode_uint16 buf ~at in
let* exact_green, at = decode_uint16 buf ~at in
let* exact_blue, at = decode_uint16 buf ~at in
let* visual_red, at = decode_uint16 buf ~at in
let* visual_green, at = decode_uint16 buf ~at in
let* visual_blue, at = decode_uint16 buf ~at in
ignore orig;
Some ({ pixel; exact_red; exact_green; exact_blue; visual_red; visual_green; visual_blue }, at);;
type alloc_color_cells_reply = { pixels : int list; masks : int list; } [@@deriving sexp];;
let encode_alloc_color_cells ~(contiguous : bool) ~(cmap : colormap) ~(colors : int) ~(planes : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 86 ~at in
let* at = encode_bool buf contiguous ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf colors ~at in
let* at = encode_uint16 buf planes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_alloc_color_cells_reply length buf ~at : (alloc_color_cells_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pixels_len, at = decode_uint16 buf ~at in let pixels_len = pixels_len in
let* masks_len, at = decode_uint16 buf ~at in let masks_len = masks_len in
let at = at + 20 in
let* pixels, at = decode_list (decode_int32) pixels_len buf ~at in
let* masks, at = decode_list (decode_int32) masks_len buf ~at in
ignore orig;
Some ({ pixels; masks }, at);;
type alloc_color_planes_reply = { red_mask : int; green_mask : int; blue_mask : int; pixels : int list; } [@@deriving sexp];;
let encode_alloc_color_planes ~(contiguous : bool) ~(cmap : colormap) ~(colors : int) ~(reds : int) ~(greens : int) ~(blues : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 87 ~at in
let* at = encode_bool buf contiguous ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf colors ~at in
let* at = encode_uint16 buf reds ~at in
let* at = encode_uint16 buf greens ~at in
let* at = encode_uint16 buf blues ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_alloc_color_planes_reply length buf ~at : (alloc_color_planes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pixels_len, at = decode_uint16 buf ~at in let pixels_len = pixels_len in
let at = at + 2 in
let* red_mask, at = decode_int32 buf ~at in
let* green_mask, at = decode_int32 buf ~at in
let* blue_mask, at = decode_int32 buf ~at in
let at = at + 8 in
let* pixels, at = decode_list (decode_int32) pixels_len buf ~at in
ignore orig;
Some ({ red_mask; green_mask; blue_mask; pixels }, at);;
let encode_free_colors ~(cmap : colormap) ~(plane_mask : int) ~(pixels : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 88 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_int32 buf plane_mask ~at in
let* at = encode_list encode_int32 buf pixels ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type color_flag_mask = [ `Red | `Green | `Blue ] list [@@deriving sexp];;
let color_flag_mask_of_int64 mask : color_flag_mask option = let of_int = function 0 -> Some `Red | 1 -> Some `Green | 2 -> Some `Blue | _ -> None in mask_of_int of_int mask;;
let color_flag_int_of_mask : color_flag_mask -> int = let to_bit = function `Red -> 0 | `Green -> 1 | `Blue -> 2 in int_of_mask to_bit;;
type coloritem = { pixel : int; red : int; green : int; blue : int; flags : color_flag_mask; } [@@deriving sexp];;
let decode_coloritem buf ~at : (coloritem * int) option = let orig = at in let* pixel, at = decode_int32 buf ~at in
let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let* flags, at = decode_mask decode_char char_to_int64 color_flag_mask_of_int64 buf ~at in
let at = at + 1 in
ignore orig;
Some ({ pixel; red; green; blue; flags }, at);;
let encode_coloritem buf (v : coloritem) ~at : int option = let orig = at in let* at = encode_int32 buf v.pixel ~at in let* at = encode_uint16 buf v.red ~at in let* at = encode_uint16 buf v.green ~at in let* at = encode_uint16 buf v.blue ~at in let* at = encode_mask encode_char Char.chr color_flag_int_of_mask buf v.flags ~at in let at = at + 1 in ignore orig; Some at;;

let encode_store_colors ~(cmap : colormap) ~(items : coloritem list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 89 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_list encode_coloritem buf items ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_store_named_color ~(flags : color_flag_mask) ~(cmap : colormap) ~(pixel : int) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 90 ~at in
let* at = encode_mask encode_uint8 identity color_flag_int_of_mask buf flags ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_int32 buf pixel ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type rgb = { red : int; green : int; blue : int; } [@@deriving sexp];;
let decode_rgb buf ~at : (rgb * int) option = let orig = at in let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ red; green; blue }, at);;
let encode_rgb buf (v : rgb) ~at : int option = let orig = at in let* at = encode_uint16 buf v.red ~at in let* at = encode_uint16 buf v.green ~at in let* at = encode_uint16 buf v.blue ~at in let at = at + 2 in ignore orig; Some at;;

type query_colors_reply = { colors : rgb list; } [@@deriving sexp];;
let encode_query_colors ~(cmap : colormap) ~(pixels : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 91 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_list encode_int32 buf pixels ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_colors_reply length buf ~at : (query_colors_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* colors_len, at = decode_uint16 buf ~at in let colors_len = colors_len in
let at = at + 22 in
let* colors, at = decode_list (decode_rgb) colors_len buf ~at in
ignore orig;
Some ({ colors }, at);;
type lookup_color_reply = { exact_red : int; exact_green : int; exact_blue : int; visual_red : int; visual_green : int; visual_blue : int; } [@@deriving sexp];;
let encode_lookup_color ~(cmap : colormap) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 92 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_colormap buf cmap ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_lookup_color_reply length buf ~at : (lookup_color_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* exact_red, at = decode_uint16 buf ~at in
let* exact_green, at = decode_uint16 buf ~at in
let* exact_blue, at = decode_uint16 buf ~at in
let* visual_red, at = decode_uint16 buf ~at in
let* visual_green, at = decode_uint16 buf ~at in
let* visual_blue, at = decode_uint16 buf ~at in
ignore orig;
Some ({ exact_red; exact_green; exact_blue; visual_red; visual_green; visual_blue }, at);;
let encode_create_cursor ~(cid : cursor) ~(source : pixmap) ~(mask : pixmap_enum alt_enum) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int) ~(x : int) ~(y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 93 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cid ~at in
let* at = encode_pixmap buf source ~at in
let* at = encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf mask ~at in
let* at = encode_uint16 buf fore_red ~at in
let* at = encode_uint16 buf fore_green ~at in
let* at = encode_uint16 buf fore_blue ~at in
let* at = encode_uint16 buf back_red ~at in
let* at = encode_uint16 buf back_green ~at in
let* at = encode_uint16 buf back_blue ~at in
let* at = encode_uint16 buf x ~at in
let* at = encode_uint16 buf y ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_glyph_cursor ~(cid : cursor) ~(source_font : font) ~(mask_font : font_enum alt_enum) ~(source_char : int) ~(mask_char : int) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 94 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cid ~at in
let* at = encode_font buf source_font ~at in
let* at = encode_alt_enum encode_font identity font_int_of_enum buf mask_font ~at in
let* at = encode_uint16 buf source_char ~at in
let* at = encode_uint16 buf mask_char ~at in
let* at = encode_uint16 buf fore_red ~at in
let* at = encode_uint16 buf fore_green ~at in
let* at = encode_uint16 buf fore_blue ~at in
let* at = encode_uint16 buf back_red ~at in
let* at = encode_uint16 buf back_green ~at in
let* at = encode_uint16 buf back_blue ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_cursor ~(cursor : cursor)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 95 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cursor ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_recolor_cursor ~(cursor : cursor) ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int) ~(back_green : int) ~(back_blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 96 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_cursor buf cursor ~at in
let* at = encode_uint16 buf fore_red ~at in
let* at = encode_uint16 buf fore_green ~at in
let* at = encode_uint16 buf fore_blue ~at in
let* at = encode_uint16 buf back_red ~at in
let* at = encode_uint16 buf back_green ~at in
let* at = encode_uint16 buf back_blue ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_shape_of_enum = [ `Largest_cursor | `Fastest_tile | `Fastest_stipple ] [@@deriving sexp];;
let query_shape_of_enum_of_int : int -> [> query_shape_of_enum ] option = function 0 -> Some `Largest_cursor | 1 -> Some `Fastest_tile | 2 -> Some `Fastest_stipple | n -> Printf.printf "unknown query_shape_of_enum: %d\n" n; None;;
let query_shape_of_int_of_enum : query_shape_of_enum -> int = function `Largest_cursor -> 0 | `Fastest_tile -> 1 | `Fastest_stipple -> 2;;
type query_best_size_reply = { width : int; height : int; } [@@deriving sexp];;
let encode_query_best_size ~(class_ : query_shape_of_enum) ~(drawable : drawable) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 97 ~at in
let* at = encode_enum encode_uint8 identity query_shape_of_int_of_enum buf class_ ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_best_size_reply length buf ~at : (query_best_size_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ width; height }, at);;
type query_extension_reply = { present : bool; major_opcode : int; first_event : int; first_error : int; } [@@deriving sexp];;
let encode_query_extension ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 98 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_extension_reply length buf ~at : (query_extension_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* present, at = decode_bool buf ~at in
let* major_opcode, at = decode_uint8 buf ~at in
let* first_event, at = decode_uint8 buf ~at in
let* first_error, at = decode_uint8 buf ~at in
ignore orig;
Some ({ present; major_opcode; first_event; first_error }, at);;
type list_extensions_reply = { names : str list; } [@@deriving sexp];;
let encode_list_extensions  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 99 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_extensions_reply length buf ~at : (list_extensions_reply * int) option = let orig = at in let at = at + 1 in
let* names_len, at = decode_uint8 buf ~at in let names_len = names_len in
let at = at + 6 in
let at = at + 24 in
let* names, at = decode_list (decode_str) names_len buf ~at in
ignore orig;
Some ({ names }, at);;
let encode_change_keyboard_mapping ~(keycode_count : int) ~(first_keycode : keycode) ~(keysyms_per_keycode : int) ~(keysyms : keysym list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 100 ~at in
let* at = encode_uint8 buf keycode_count ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_keycode buf first_keycode ~at in
let* at = encode_uint8 buf keysyms_per_keycode ~at in
let at = at + 2 in
let* at = encode_list encode_keysym buf keysyms ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_keyboard_mapping_reply = { keysyms_per_keycode : char; keysyms : keysym list; } [@@deriving sexp];;
let encode_get_keyboard_mapping ~(first_keycode : keycode) ~(count : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 101 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_keycode buf first_keycode ~at in
let* at = encode_uint8 buf count ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_keyboard_mapping_reply length buf ~at : (get_keyboard_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* keysyms_per_keycode, at = decode_char buf ~at in
let at = at + 6 in
let at = at + 24 in
let* keysyms, at = let length = length in decode_list (decode_keysym) length buf ~at in
ignore orig;
Some ({ keysyms_per_keycode; keysyms }, at);;
type kb_mask = [ `Key_click_percent | `Bell_percent | `Bell_pitch | `Bell_duration | `Led | `Led_mode | `Key | `Auto_repeat_mode ] list [@@deriving sexp];;
let kb_mask_of_int64 mask : kb_mask option = let of_int = function 0 -> Some `Key_click_percent | 1 -> Some `Bell_percent | 2 -> Some `Bell_pitch | 3 -> Some `Bell_duration | 4 -> Some `Led | 5 -> Some `Led_mode | 6 -> Some `Key | 7 -> Some `Auto_repeat_mode | _ -> None in mask_of_int of_int mask;;
let kb_int_of_mask : kb_mask -> int = let to_bit = function `Key_click_percent -> 0 | `Bell_percent -> 1 | `Bell_pitch -> 2 | `Bell_duration -> 3 | `Led -> 4 | `Led_mode -> 5 | `Key -> 6 | `Auto_repeat_mode -> 7 in int_of_mask to_bit;;
type led_mode_enum = [ `Off | `On ] [@@deriving sexp];;
let led_mode_enum_of_int : int -> [> led_mode_enum ] option = function 0 -> Some `Off | 1 -> Some `On | n -> Printf.printf "unknown led_mode_enum: %d\n" n; None;;
let led_mode_int_of_enum : led_mode_enum -> int = function `Off -> 0 | `On -> 1;;
type auto_repeat_mode_enum = [ `Off | `On | `Default ] [@@deriving sexp];;
let auto_repeat_mode_enum_of_int : int -> [> auto_repeat_mode_enum ] option = function 0 -> Some `Off | 1 -> Some `On | 2 -> Some `Default | n -> Printf.printf "unknown auto_repeat_mode_enum: %d\n" n; None;;
let auto_repeat_mode_int_of_enum : auto_repeat_mode_enum -> int = function `Off -> 0 | `On -> 1 | `Default -> 2;;
let encode_change_keyboard_control ?(key_click_percent : int option) ?(bell_percent : int option) ?(bell_pitch : int option) ?(bell_duration : int option) ?(led : int option) ?(led_mode : led_mode_enum option) ?(key : keycode32 option) ?(auto_repeat_mode : auto_repeat_mode_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 102 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_keyboard_control_reply = { global_auto_repeat : auto_repeat_mode_enum; led_mask : int; key_click_percent : int; bell_percent : int; bell_pitch : int; bell_duration : int; auto_repeats : int list; } [@@deriving sexp];;
let encode_get_keyboard_control  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 103 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_keyboard_control_reply length buf ~at : (get_keyboard_control_reply * int) option = let orig = at in let at = at + 1 in
let* global_auto_repeat, at = decode_enum decode_char Char.code auto_repeat_mode_enum_of_int buf ~at in
let at = at + 6 in
let* led_mask, at = decode_int32 buf ~at in
let* key_click_percent, at = decode_uint8 buf ~at in
let* bell_percent, at = decode_uint8 buf ~at in
let* bell_pitch, at = decode_uint16 buf ~at in
let* bell_duration, at = decode_uint16 buf ~at in
let at = at + 2 in
let* auto_repeats, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ global_auto_repeat; led_mask; key_click_percent; bell_percent; bell_pitch; bell_duration; auto_repeats }, at);;
let encode_bell ~(percent : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 104 ~at in
let* at = encode_int8 buf percent ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_pointer_control ~(acceleration_numerator : int) ~(acceleration_denominator : int) ~(threshold : int) ~(do_acceleration : bool) ~(do_threshold : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 105 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf acceleration_numerator ~at in
let* at = encode_int16 buf acceleration_denominator ~at in
let* at = encode_int16 buf threshold ~at in
let* at = encode_bool buf do_acceleration ~at in
let* at = encode_bool buf do_threshold ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_pointer_control_reply = { acceleration_numerator : int; acceleration_denominator : int; threshold : int; } [@@deriving sexp];;
let encode_get_pointer_control  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 106 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_pointer_control_reply length buf ~at : (get_pointer_control_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* acceleration_numerator, at = decode_uint16 buf ~at in
let* acceleration_denominator, at = decode_uint16 buf ~at in
let* threshold, at = decode_uint16 buf ~at in
let at = at + 18 in
ignore orig;
Some ({ acceleration_numerator; acceleration_denominator; threshold }, at);;
type blanking_enum = [ `Not_preferred | `Preferred | `Default ] [@@deriving sexp];;
let blanking_enum_of_int : int -> [> blanking_enum ] option = function 0 -> Some `Not_preferred | 1 -> Some `Preferred | 2 -> Some `Default | n -> Printf.printf "unknown blanking_enum: %d\n" n; None;;
let blanking_int_of_enum : blanking_enum -> int = function `Not_preferred -> 0 | `Preferred -> 1 | `Default -> 2;;
type exposures_enum = [ `Not_allowed | `Allowed | `Default ] [@@deriving sexp];;
let exposures_enum_of_int : int -> [> exposures_enum ] option = function 0 -> Some `Not_allowed | 1 -> Some `Allowed | 2 -> Some `Default | n -> Printf.printf "unknown exposures_enum: %d\n" n; None;;
let exposures_int_of_enum : exposures_enum -> int = function `Not_allowed -> 0 | `Allowed -> 1 | `Default -> 2;;
let encode_set_screen_saver ~(timeout : int) ~(interval : int) ~(prefer_blanking : blanking_enum) ~(allow_exposures : exposures_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 107 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf timeout ~at in
let* at = encode_int16 buf interval ~at in
let* at = encode_enum encode_uint8 identity blanking_int_of_enum buf prefer_blanking ~at in
let* at = encode_enum encode_uint8 identity exposures_int_of_enum buf allow_exposures ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_screen_saver_reply = { timeout : int; interval : int; prefer_blanking : blanking_enum; allow_exposures : exposures_enum; } [@@deriving sexp];;
let encode_get_screen_saver  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 108 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_saver_reply length buf ~at : (get_screen_saver_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* timeout, at = decode_uint16 buf ~at in
let* interval, at = decode_uint16 buf ~at in
let* prefer_blanking, at = decode_enum decode_char Char.code blanking_enum_of_int buf ~at in
let* allow_exposures, at = decode_enum decode_char Char.code exposures_enum_of_int buf ~at in
let at = at + 18 in
ignore orig;
Some ({ timeout; interval; prefer_blanking; allow_exposures }, at);;
type host_mode_enum = [ `Insert | `Delete ] [@@deriving sexp];;
let host_mode_enum_of_int : int -> [> host_mode_enum ] option = function 0 -> Some `Insert | 1 -> Some `Delete | n -> Printf.printf "unknown host_mode_enum: %d\n" n; None;;
let host_mode_int_of_enum : host_mode_enum -> int = function `Insert -> 0 | `Delete -> 1;;
type family_enum = [ `Internet | `Decnet | `Chaos | `Server_interpreted | `Internet6 ] [@@deriving sexp];;
let family_enum_of_int : int -> [> family_enum ] option = function 0 -> Some `Internet | 1 -> Some `Decnet | 2 -> Some `Chaos | 5 -> Some `Server_interpreted | 6 -> Some `Internet6 | n -> Printf.printf "unknown family_enum: %d\n" n; None;;
let family_int_of_enum : family_enum -> int = function `Internet -> 0 | `Decnet -> 1 | `Chaos -> 2 | `Server_interpreted -> 5 | `Internet6 -> 6;;
let encode_change_hosts ~(mode : host_mode_enum) ~(family : family_enum) ~(address : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 109 ~at in
let* at = encode_enum encode_uint8 identity host_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity family_int_of_enum buf family ~at in
let at = at + 1 in
let* at = encode_uint16 buf (identity ((* Parsetree.Byte *) List.length address)) ~at in
let* at = encode_list encode_char buf address ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type host = { family : family_enum; address : char list; } [@@deriving sexp];;
let decode_host buf ~at : (host * int) option = let orig = at in let* family, at = decode_enum decode_uint8 identity family_enum_of_int buf ~at in
let at = at + 1 in
let* address_len, at = decode_uint16 buf ~at in let address_len = address_len in
let* address, at = decode_list (decode_char) address_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ family; address }, at);;
let encode_host buf (v : host) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity family_int_of_enum buf v.family ~at in let at = at + 1 in let* at = encode_uint16 buf (identity ((* Parsetree.Byte *) List.length v.address)) ~at in let* at = encode_list encode_char buf v.address ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type access_control_enum = [ `Disable | `Enable ] [@@deriving sexp];;
let access_control_enum_of_int : int -> [> access_control_enum ] option = function 0 -> Some `Disable | 1 -> Some `Enable | n -> Printf.printf "unknown access_control_enum: %d\n" n; None;;
let access_control_int_of_enum : access_control_enum -> int = function `Disable -> 0 | `Enable -> 1;;
type list_hosts_reply = { mode : access_control_enum; hosts : host list; } [@@deriving sexp];;
let encode_list_hosts  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 110 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_hosts_reply length buf ~at : (list_hosts_reply * int) option = let orig = at in let at = at + 1 in
let* mode, at = decode_enum decode_char Char.code access_control_enum_of_int buf ~at in
let at = at + 6 in
let* hosts_len, at = decode_uint16 buf ~at in let hosts_len = hosts_len in
let at = at + 22 in
let* hosts, at = decode_list (decode_host) hosts_len buf ~at in
ignore orig;
Some ({ mode; hosts }, at);;
let encode_set_access_control ~(mode : access_control_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 111 ~at in
let* at = encode_enum encode_uint8 identity access_control_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type close_down_enum = [ `Destroy_all | `Retain_permanent | `Retain_temporary ] [@@deriving sexp];;
let close_down_enum_of_int : int -> [> close_down_enum ] option = function 0 -> Some `Destroy_all | 1 -> Some `Retain_permanent | 2 -> Some `Retain_temporary | n -> Printf.printf "unknown close_down_enum: %d\n" n; None;;
let close_down_int_of_enum : close_down_enum -> int = function `Destroy_all -> 0 | `Retain_permanent -> 1 | `Retain_temporary -> 2;;
let encode_set_close_down_mode ~(mode : close_down_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 112 ~at in
let* at = encode_enum encode_uint8 identity close_down_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type kill_enum = [ `All_temporary ] [@@deriving sexp];;
let kill_enum_of_int : int -> [> kill_enum ] option = function 0 -> Some `All_temporary | n -> Printf.printf "unknown kill_enum: %d\n" n; None;;
let kill_int_of_enum : kill_enum -> int = function `All_temporary -> 0;;
let encode_kill_client ~(resource : kill_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 113 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_int32 identity kill_int_of_enum buf resource ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_rotate_properties ~(window : window) ~(delta : int) ~(atoms : atom list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 114 ~at in
let at = at + 1 in
(* reserve request length *)
let at = at + 2 in
let* at = encode_window buf window ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Xid *) List.length atoms)) ~at in
let* at = encode_int16 buf delta ~at in
let* at = encode_list encode_atom buf atoms ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type screen_saver_enum = [ `Reset | `Active ] [@@deriving sexp];;
let screen_saver_enum_of_int : int -> [> screen_saver_enum ] option = function 0 -> Some `Reset | 1 -> Some `Active | n -> Printf.printf "unknown screen_saver_enum: %d\n" n; None;;
let screen_saver_int_of_enum : screen_saver_enum -> int = function `Reset -> 0 | `Active -> 1;;
let encode_force_screen_saver ~(mode : screen_saver_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 115 ~at in
let* at = encode_enum encode_uint8 identity screen_saver_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type mapping_status_enum = [ `Success | `Busy | `Failure ] [@@deriving sexp];;
let mapping_status_enum_of_int : int -> [> mapping_status_enum ] option = function 0 -> Some `Success | 1 -> Some `Busy | 2 -> Some `Failure | n -> Printf.printf "unknown mapping_status_enum: %d\n" n; None;;
let mapping_status_int_of_enum : mapping_status_enum -> int = function `Success -> 0 | `Busy -> 1 | `Failure -> 2;;
type set_pointer_mapping_reply = { status : mapping_status_enum; } [@@deriving sexp];;
let encode_set_pointer_mapping ~(map : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 116 ~at in
let* at = encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length map)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_uint8 buf map ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_pointer_mapping_reply length buf ~at : (set_pointer_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code mapping_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
type get_pointer_mapping_reply = { map : int list; } [@@deriving sexp];;
let encode_get_pointer_mapping  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 117 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_pointer_mapping_reply length buf ~at : (get_pointer_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* map_len, at = decode_uint8 buf ~at in let map_len = map_len in
let at = at + 6 in
let at = at + 24 in
let* map, at = decode_list (decode_uint8) map_len buf ~at in
ignore orig;
Some ({ map }, at);;
type map_index_enum = [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 ] [@@deriving sexp];;
let map_index_enum_of_int : int -> [> map_index_enum ] option = function 0 -> Some `Shift | 1 -> Some `Lock | 2 -> Some `Control | 3 -> Some `D1 | 4 -> Some `D2 | 5 -> Some `D3 | 6 -> Some `D4 | 7 -> Some `D5 | n -> Printf.printf "unknown map_index_enum: %d\n" n; None;;
let map_index_int_of_enum : map_index_enum -> int = function `Shift -> 0 | `Lock -> 1 | `Control -> 2 | `D1 -> 3 | `D2 -> 4 | `D3 -> 5 | `D4 -> 6 | `D5 -> 7;;
type set_modifier_mapping_reply = { status : mapping_status_enum; } [@@deriving sexp];;
let encode_set_modifier_mapping ~(keycodes : keycode list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 118 ~at in
let* at = encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length keycodes)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_keycode buf keycodes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_modifier_mapping_reply length buf ~at : (set_modifier_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_char Char.code mapping_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ status }, at);;
type get_modifier_mapping_reply = { keycodes : keycode list; } [@@deriving sexp];;
let encode_get_modifier_mapping  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 119 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_modifier_mapping_reply length buf ~at : (get_modifier_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* keycodes_per_modifier, at = decode_uint8 buf ~at in let keycodes_per_modifier = (keycodes_per_modifier) / (8) in
let at = at + 6 in
let at = at + 24 in
let* keycodes, at = decode_list (decode_keycode) keycodes_per_modifier buf ~at in
ignore orig;
Some ({ keycodes }, at);;
let encode_no_operation  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 127 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;module[@warning "-27"] Render = struct
type pict_type_enum = [ `Indexed | `Direct ] [@@deriving sexp];;
let pict_type_enum_of_int : int -> [> pict_type_enum ] option = function 0 -> Some `Indexed | 1 -> Some `Direct | n -> Printf.printf "unknown pict_type_enum: %d\n" n; None;;
let pict_type_int_of_enum : pict_type_enum -> int = function `Indexed -> 0 | `Direct -> 1;;
type picture_enum = [ `None ] [@@deriving sexp];;
let picture_enum_of_int : int -> [> picture_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown picture_enum: %d\n" n; None;;
let picture_int_of_enum : picture_enum -> int = function `None -> 0;;
type pict_op_enum = [ `Clear | `Src | `Dst | `Over | `Over_reverse | `In | `In_reverse | `Out | `Out_reverse | `Atop | `Atop_reverse | `Xor | `Add | `Saturate | `Disjoint_clear | `Disjoint_src | `Disjoint_dst | `Disjoint_over | `Disjoint_over_reverse | `Disjoint_in | `Disjoint_in_reverse | `Disjoint_out | `Disjoint_out_reverse | `Disjoint_atop | `Disjoint_atop_reverse | `Disjoint_xor | `Conjoint_clear | `Conjoint_src | `Conjoint_dst | `Conjoint_over | `Conjoint_over_reverse | `Conjoint_in | `Conjoint_in_reverse | `Conjoint_out | `Conjoint_out_reverse | `Conjoint_atop | `Conjoint_atop_reverse | `Conjoint_xor | `Multiply | `Screen | `Overlay | `Darken | `Lighten | `Color_dodge | `Color_burn | `Hard_light | `Soft_light | `Difference | `Exclusion | `Hsl_hue | `Hsl_saturation | `Hsl_color | `Hsl_luminosity ] [@@deriving sexp];;
let pict_op_enum_of_int : int -> [> pict_op_enum ] option = function 0 -> Some `Clear | 1 -> Some `Src | 2 -> Some `Dst | 3 -> Some `Over | 4 -> Some `Over_reverse | 5 -> Some `In | 6 -> Some `In_reverse | 7 -> Some `Out | 8 -> Some `Out_reverse | 9 -> Some `Atop | 10 -> Some `Atop_reverse | 11 -> Some `Xor | 12 -> Some `Add | 13 -> Some `Saturate | 16 -> Some `Disjoint_clear | 17 -> Some `Disjoint_src | 18 -> Some `Disjoint_dst | 19 -> Some `Disjoint_over | 20 -> Some `Disjoint_over_reverse | 21 -> Some `Disjoint_in | 22 -> Some `Disjoint_in_reverse | 23 -> Some `Disjoint_out | 24 -> Some `Disjoint_out_reverse | 25 -> Some `Disjoint_atop | 26 -> Some `Disjoint_atop_reverse | 27 -> Some `Disjoint_xor | 32 -> Some `Conjoint_clear | 33 -> Some `Conjoint_src | 34 -> Some `Conjoint_dst | 35 -> Some `Conjoint_over | 36 -> Some `Conjoint_over_reverse | 37 -> Some `Conjoint_in | 38 -> Some `Conjoint_in_reverse | 39 -> Some `Conjoint_out | 40 -> Some `Conjoint_out_reverse | 41 -> Some `Conjoint_atop | 42 -> Some `Conjoint_atop_reverse | 43 -> Some `Conjoint_xor | 48 -> Some `Multiply | 49 -> Some `Screen | 50 -> Some `Overlay | 51 -> Some `Darken | 52 -> Some `Lighten | 53 -> Some `Color_dodge | 54 -> Some `Color_burn | 55 -> Some `Hard_light | 56 -> Some `Soft_light | 57 -> Some `Difference | 58 -> Some `Exclusion | 59 -> Some `Hsl_hue | 60 -> Some `Hsl_saturation | 61 -> Some `Hsl_color | 62 -> Some `Hsl_luminosity | n -> Printf.printf "unknown pict_op_enum: %d\n" n; None;;
let pict_op_int_of_enum : pict_op_enum -> int = function `Clear -> 0 | `Src -> 1 | `Dst -> 2 | `Over -> 3 | `Over_reverse -> 4 | `In -> 5 | `In_reverse -> 6 | `Out -> 7 | `Out_reverse -> 8 | `Atop -> 9 | `Atop_reverse -> 10 | `Xor -> 11 | `Add -> 12 | `Saturate -> 13 | `Disjoint_clear -> 16 | `Disjoint_src -> 17 | `Disjoint_dst -> 18 | `Disjoint_over -> 19 | `Disjoint_over_reverse -> 20 | `Disjoint_in -> 21 | `Disjoint_in_reverse -> 22 | `Disjoint_out -> 23 | `Disjoint_out_reverse -> 24 | `Disjoint_atop -> 25 | `Disjoint_atop_reverse -> 26 | `Disjoint_xor -> 27 | `Conjoint_clear -> 32 | `Conjoint_src -> 33 | `Conjoint_dst -> 34 | `Conjoint_over -> 35 | `Conjoint_over_reverse -> 36 | `Conjoint_in -> 37 | `Conjoint_in_reverse -> 38 | `Conjoint_out -> 39 | `Conjoint_out_reverse -> 40 | `Conjoint_atop -> 41 | `Conjoint_atop_reverse -> 42 | `Conjoint_xor -> 43 | `Multiply -> 48 | `Screen -> 49 | `Overlay -> 50 | `Darken -> 51 | `Lighten -> 52 | `Color_dodge -> 53 | `Color_burn -> 54 | `Hard_light -> 55 | `Soft_light -> 56 | `Difference -> 57 | `Exclusion -> 58 | `Hsl_hue -> 59 | `Hsl_saturation -> 60 | `Hsl_color -> 61 | `Hsl_luminosity -> 62;;
type poly_edge_enum = [ `Sharp | `Smooth ] [@@deriving sexp];;
let poly_edge_enum_of_int : int -> [> poly_edge_enum ] option = function 0 -> Some `Sharp | 1 -> Some `Smooth | n -> Printf.printf "unknown poly_edge_enum: %d\n" n; None;;
let poly_edge_int_of_enum : poly_edge_enum -> int = function `Sharp -> 0 | `Smooth -> 1;;
type poly_mode_enum = [ `Precise | `Imprecise ] [@@deriving sexp];;
let poly_mode_enum_of_int : int -> [> poly_mode_enum ] option = function 0 -> Some `Precise | 1 -> Some `Imprecise | n -> Printf.printf "unknown poly_mode_enum: %d\n" n; None;;
let poly_mode_int_of_enum : poly_mode_enum -> int = function `Precise -> 0 | `Imprecise -> 1;;
type cp_mask = [ `Repeat | `Alpha_map | `Alpha_x_origin | `Alpha_y_origin | `Clip_x_origin | `Clip_y_origin | `Clip_mask | `Graphics_exposure | `Subwindow_mode | `Poly_edge | `Poly_mode | `Dither | `Component_alpha ] list [@@deriving sexp];;
let cp_mask_of_int64 mask : cp_mask option = let of_int = function 0 -> Some `Repeat | 1 -> Some `Alpha_map | 2 -> Some `Alpha_x_origin | 3 -> Some `Alpha_y_origin | 4 -> Some `Clip_x_origin | 5 -> Some `Clip_y_origin | 6 -> Some `Clip_mask | 7 -> Some `Graphics_exposure | 8 -> Some `Subwindow_mode | 9 -> Some `Poly_edge | 10 -> Some `Poly_mode | 11 -> Some `Dither | 12 -> Some `Component_alpha | _ -> None in mask_of_int of_int mask;;
let cp_int_of_mask : cp_mask -> int = let to_bit = function `Repeat -> 0 | `Alpha_map -> 1 | `Alpha_x_origin -> 2 | `Alpha_y_origin -> 3 | `Clip_x_origin -> 4 | `Clip_y_origin -> 5 | `Clip_mask -> 6 | `Graphics_exposure -> 7 | `Subwindow_mode -> 8 | `Poly_edge -> 9 | `Poly_mode -> 10 | `Dither -> 11 | `Component_alpha -> 12 in int_of_mask to_bit;;
type sub_pixel_enum = [ `Unknown | `Horizontal_rgb | `Horizontal_bgr | `Vertical_rgb | `Vertical_bgr | `None ] [@@deriving sexp];;
let sub_pixel_enum_of_int : int -> [> sub_pixel_enum ] option = function 0 -> Some `Unknown | 1 -> Some `Horizontal_rgb | 2 -> Some `Horizontal_bgr | 3 -> Some `Vertical_rgb | 4 -> Some `Vertical_bgr | 5 -> Some `None | n -> Printf.printf "unknown sub_pixel_enum: %d\n" n; None;;
let sub_pixel_int_of_enum : sub_pixel_enum -> int = function `Unknown -> 0 | `Horizontal_rgb -> 1 | `Horizontal_bgr -> 2 | `Vertical_rgb -> 3 | `Vertical_bgr -> 4 | `None -> 5;;
type repeat_enum = [ `None | `Normal | `Pad | `Reflect ] [@@deriving sexp];;
let repeat_enum_of_int : int -> [> repeat_enum ] option = function 0 -> Some `None | 1 -> Some `Normal | 2 -> Some `Pad | 3 -> Some `Reflect | n -> Printf.printf "unknown repeat_enum: %d\n" n; None;;
let repeat_int_of_enum : repeat_enum -> int = function `None -> 0 | `Normal -> 1 | `Pad -> 2 | `Reflect -> 3;;
type glyph = int [@@deriving sexp];;
let decode_glyph = decode_int32;;
let encode_glyph = encode_int32;;

type glyphset = xid [@@deriving sexp];;
let decode_glyphset = decode_xid;;
let encode_glyphset = encode_xid;;

type picture = xid [@@deriving sexp];;
let decode_picture = decode_xid;;
let encode_picture = encode_xid;;

type pictformat = xid [@@deriving sexp];;
let decode_pictformat = decode_xid;;
let encode_pictformat = encode_xid;;

type fixed = int [@@deriving sexp];;
let decode_fixed = decode_int32;;
let encode_fixed = encode_int32;;

type pict_format_error = unit [@@deriving sexp];;
type picture_error = unit [@@deriving sexp];;
type pict_op_error = unit [@@deriving sexp];;
type glyph_set_error = unit [@@deriving sexp];;
type glyph_error = unit [@@deriving sexp];;
type directformat = { red_shift : int; red_mask : int; green_shift : int; green_mask : int; blue_shift : int; blue_mask : int; alpha_shift : int; alpha_mask : int; } [@@deriving sexp];;
let decode_directformat buf ~at : (directformat * int) option = let orig = at in let* red_shift, at = decode_uint16 buf ~at in
let* red_mask, at = decode_uint16 buf ~at in
let* green_shift, at = decode_uint16 buf ~at in
let* green_mask, at = decode_uint16 buf ~at in
let* blue_shift, at = decode_uint16 buf ~at in
let* blue_mask, at = decode_uint16 buf ~at in
let* alpha_shift, at = decode_uint16 buf ~at in
let* alpha_mask, at = decode_uint16 buf ~at in
ignore orig;
Some ({ red_shift; red_mask; green_shift; green_mask; blue_shift; blue_mask; alpha_shift; alpha_mask }, at);;
let encode_directformat buf (v : directformat) ~at : int option = let orig = at in let* at = encode_uint16 buf v.red_shift ~at in let* at = encode_uint16 buf v.red_mask ~at in let* at = encode_uint16 buf v.green_shift ~at in let* at = encode_uint16 buf v.green_mask ~at in let* at = encode_uint16 buf v.blue_shift ~at in let* at = encode_uint16 buf v.blue_mask ~at in let* at = encode_uint16 buf v.alpha_shift ~at in let* at = encode_uint16 buf v.alpha_mask ~at in ignore orig; Some at;;

type pictforminfo = { id : pictformat; type_ : pict_type_enum; depth : int; direct : directformat; colormap : Xproto.colormap; } [@@deriving sexp];;
let decode_pictforminfo buf ~at : (pictforminfo * int) option = let orig = at in let* id, at = decode_pictformat buf ~at in
let* type_, at = decode_enum decode_uint8 identity pict_type_enum_of_int buf ~at in
let* depth, at = decode_uint8 buf ~at in
let at = at + 2 in
let* direct, at = decode_directformat buf ~at in
let* colormap, at = Xproto.decode_colormap buf ~at in
ignore orig;
Some ({ id; type_; depth; direct; colormap }, at);;
let encode_pictforminfo buf (v : pictforminfo) ~at : int option = let orig = at in let* at = encode_pictformat buf v.id ~at in let* at = encode_enum encode_uint8 identity pict_type_int_of_enum buf v.type_ ~at in let* at = encode_uint8 buf v.depth ~at in let at = at + 2 in let* at = encode_directformat buf v.direct ~at in let* at = Xproto.encode_colormap buf v.colormap ~at in ignore orig; Some at;;

type pictvisual = { visual : Xproto.visualid; format : pictformat; } [@@deriving sexp];;
let decode_pictvisual buf ~at : (pictvisual * int) option = let orig = at in let* visual, at = Xproto.decode_visualid buf ~at in
let* format, at = decode_pictformat buf ~at in
ignore orig;
Some ({ visual; format }, at);;
let encode_pictvisual buf (v : pictvisual) ~at : int option = let orig = at in let* at = Xproto.encode_visualid buf v.visual ~at in let* at = encode_pictformat buf v.format ~at in ignore orig; Some at;;

type pictdepth = { depth : int; visuals : pictvisual list; } [@@deriving sexp];;
let decode_pictdepth buf ~at : (pictdepth * int) option = let orig = at in let* depth, at = decode_uint8 buf ~at in
let at = at + 1 in
let* num_visuals, at = decode_uint16 buf ~at in let num_visuals = num_visuals in
let at = at + 4 in
let* visuals, at = decode_list (decode_pictvisual) num_visuals buf ~at in
ignore orig;
Some ({ depth; visuals }, at);;
let encode_pictdepth buf (v : pictdepth) ~at : int option = let orig = at in let* at = encode_uint8 buf v.depth ~at in let at = at + 1 in let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length v.visuals)) ~at in let at = at + 4 in let* at = encode_list encode_pictvisual buf v.visuals ~at in ignore orig; Some at;;

type pictscreen = { fallback : pictformat; depths : pictdepth list; } [@@deriving sexp];;
let decode_pictscreen buf ~at : (pictscreen * int) option = let orig = at in let* num_depths, at = decode_int32 buf ~at in let num_depths = num_depths in
let* fallback, at = decode_pictformat buf ~at in
let* depths, at = decode_list (decode_pictdepth) num_depths buf ~at in
ignore orig;
Some ({ fallback; depths }, at);;
let encode_pictscreen buf (v : pictscreen) ~at : int option = let orig = at in let* at = encode_int32 buf (identity ((* invalid_argument *) List.length v.depths)) ~at in let* at = encode_pictformat buf v.fallback ~at in let* at = encode_list encode_pictdepth buf v.depths ~at in ignore orig; Some at;;

type indexvalue = { pixel : int; red : int; green : int; blue : int; alpha : int; } [@@deriving sexp];;
let decode_indexvalue buf ~at : (indexvalue * int) option = let orig = at in let* pixel, at = decode_int32 buf ~at in
let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let* alpha, at = decode_uint16 buf ~at in
ignore orig;
Some ({ pixel; red; green; blue; alpha }, at);;
let encode_indexvalue buf (v : indexvalue) ~at : int option = let orig = at in let* at = encode_int32 buf v.pixel ~at in let* at = encode_uint16 buf v.red ~at in let* at = encode_uint16 buf v.green ~at in let* at = encode_uint16 buf v.blue ~at in let* at = encode_uint16 buf v.alpha ~at in ignore orig; Some at;;

type color = { red : int; green : int; blue : int; alpha : int; } [@@deriving sexp];;
let decode_color buf ~at : (color * int) option = let orig = at in let* red, at = decode_uint16 buf ~at in
let* green, at = decode_uint16 buf ~at in
let* blue, at = decode_uint16 buf ~at in
let* alpha, at = decode_uint16 buf ~at in
ignore orig;
Some ({ red; green; blue; alpha }, at);;
let encode_color buf (v : color) ~at : int option = let orig = at in let* at = encode_uint16 buf v.red ~at in let* at = encode_uint16 buf v.green ~at in let* at = encode_uint16 buf v.blue ~at in let* at = encode_uint16 buf v.alpha ~at in ignore orig; Some at;;

type pointfix = { x : fixed; y : fixed; } [@@deriving sexp];;
let decode_pointfix buf ~at : (pointfix * int) option = let orig = at in let* x, at = decode_fixed buf ~at in
let* y, at = decode_fixed buf ~at in
ignore orig;
Some ({ x; y }, at);;
let encode_pointfix buf (v : pointfix) ~at : int option = let orig = at in let* at = encode_fixed buf v.x ~at in let* at = encode_fixed buf v.y ~at in ignore orig; Some at;;

type linefix = { p1 : pointfix; p2 : pointfix; } [@@deriving sexp];;
let decode_linefix buf ~at : (linefix * int) option = let orig = at in let* p1, at = decode_pointfix buf ~at in
let* p2, at = decode_pointfix buf ~at in
ignore orig;
Some ({ p1; p2 }, at);;
let encode_linefix buf (v : linefix) ~at : int option = let orig = at in let* at = encode_pointfix buf v.p1 ~at in let* at = encode_pointfix buf v.p2 ~at in ignore orig; Some at;;

type triangle = { p1 : pointfix; p2 : pointfix; p3 : pointfix; } [@@deriving sexp];;
let decode_triangle buf ~at : (triangle * int) option = let orig = at in let* p1, at = decode_pointfix buf ~at in
let* p2, at = decode_pointfix buf ~at in
let* p3, at = decode_pointfix buf ~at in
ignore orig;
Some ({ p1; p2; p3 }, at);;
let encode_triangle buf (v : triangle) ~at : int option = let orig = at in let* at = encode_pointfix buf v.p1 ~at in let* at = encode_pointfix buf v.p2 ~at in let* at = encode_pointfix buf v.p3 ~at in ignore orig; Some at;;

type trapezoid = { top : fixed; bottom : fixed; left : linefix; right : linefix; } [@@deriving sexp];;
let decode_trapezoid buf ~at : (trapezoid * int) option = let orig = at in let* top, at = decode_fixed buf ~at in
let* bottom, at = decode_fixed buf ~at in
let* left, at = decode_linefix buf ~at in
let* right, at = decode_linefix buf ~at in
ignore orig;
Some ({ top; bottom; left; right }, at);;
let encode_trapezoid buf (v : trapezoid) ~at : int option = let orig = at in let* at = encode_fixed buf v.top ~at in let* at = encode_fixed buf v.bottom ~at in let* at = encode_linefix buf v.left ~at in let* at = encode_linefix buf v.right ~at in ignore orig; Some at;;

type glyphinfo = { width : int; height : int; x : int; y : int; x_off : int; y_off : int; } [@@deriving sexp];;
let decode_glyphinfo buf ~at : (glyphinfo * int) option = let orig = at in let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* x_off, at = decode_int16 buf ~at in
let* y_off, at = decode_int16 buf ~at in
ignore orig;
Some ({ width; height; x; y; x_off; y_off }, at);;
let encode_glyphinfo buf (v : glyphinfo) ~at : int option = let orig = at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_int16 buf v.x_off ~at in let* at = encode_int16 buf v.y_off ~at in ignore orig; Some at;;

type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ major_version; minor_version }, at);;
type query_pict_formats_reply = { num_depths : int; num_visuals : int; formats : pictforminfo list; screens : pictscreen list; subpixels : sub_pixel_enum list; } [@@deriving sexp];;
let encode_query_pict_formats  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_pict_formats_reply length buf ~at : (query_pict_formats_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_formats, at = decode_int32 buf ~at in let num_formats = num_formats in
let* num_screens, at = decode_int32 buf ~at in let num_screens = num_screens in
let* num_depths, at = decode_int32 buf ~at in
let* num_visuals, at = decode_int32 buf ~at in
let* num_subpixel, at = decode_int32 buf ~at in let num_subpixel = num_subpixel in
let at = at + 4 in
let* formats, at = decode_list (decode_pictforminfo) num_formats buf ~at in
let* screens, at = decode_list (decode_pictscreen) num_screens buf ~at in
let* subpixels, at = decode_list (decode_enum decode_int32 identity sub_pixel_enum_of_int) num_subpixel buf ~at in
ignore orig;
Some ({ num_depths; num_visuals; formats; screens; subpixels }, at);;
type query_pict_index_values_reply = { values : indexvalue list; } [@@deriving sexp];;
let encode_query_pict_index_values ~(format : pictformat)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_pictformat buf format ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_pict_index_values_reply length buf ~at : (query_pict_index_values_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_values, at = decode_int32 buf ~at in let num_values = num_values in
let at = at + 20 in
let* values, at = decode_list (decode_indexvalue) num_values buf ~at in
ignore orig;
Some ({ values }, at);;
let encode_create_picture ~(pid : picture) ~(drawable : Xproto.drawable) ~(format : pictformat) ?(repeat : repeat_enum option) ?(alphamap : picture option) ?(alphaxorigin : int option) ?(alphayorigin : int option) ?(clipxorigin : int option) ?(clipyorigin : int option) ?(clipmask : Xproto.pixmap option) ?(graphicsexposure : int option) ?(subwindowmode : Xproto.subwindow_mode_enum option) ?(polyedge : poly_edge_enum option) ?(polymode : poly_mode_enum option) ?(dither : Xproto.atom option) ?(componentalpha : int option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_picture buf pid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = encode_pictformat buf format ~at in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_picture ~(picture : picture) ?(repeat : repeat_enum option) ?(alphamap : picture option) ?(alphaxorigin : int option) ?(alphayorigin : int option) ?(clipxorigin : int option) ?(clipyorigin : int option) ?(clipmask : Xproto.pixmap option) ?(graphicsexposure : int option) ?(subwindowmode : Xproto.subwindow_mode_enum option) ?(polyedge : poly_edge_enum option) ?(polymode : poly_mode_enum option) ?(dither : Xproto.atom option) ?(componentalpha : int option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_picture_clip_rectangles ~(picture : picture) ~(clip_x_origin : int) ~(clip_y_origin : int) ~(rectangles : Xproto.rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf clip_x_origin ~at in
let* at = encode_int16 buf clip_y_origin ~at in
let* at = encode_list Xproto.encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_picture ~(picture : picture)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_composite ~(op : pict_op_enum) ~(src : picture) ~(mask : picture_enum alt_enum) ~(dst : picture) ~(src_x : int) ~(src_y : int) ~(mask_x : int) ~(mask_y : int) ~(dst_x : int) ~(dst_y : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_alt_enum encode_picture identity picture_int_of_enum buf mask ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_int16 buf mask_x ~at in
let* at = encode_int16 buf mask_y ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_trapezoids ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(traps : trapezoid list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_trapezoid buf traps ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_triangles ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(triangles : triangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_triangle buf triangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_tri_strip ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(points : pointfix list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_pointfix buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_tri_fan ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int) ~(points : pointfix list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_pointfix buf points ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_glyph_set ~(gsid : glyphset) ~(format : pictformat)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_glyphset buf gsid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pictformat buf format ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_reference_glyph_set ~(gsid : glyphset) ~(existing : glyphset)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_glyphset buf gsid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_glyphset buf existing ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_glyph_set ~(glyphset : glyphset)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_glyphset buf glyphset ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_add_glyphs ~(glyphset : glyphset) ~(glyphids : int list) ~(glyphs : glyphinfo list) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_glyphset buf glyphset ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length glyphids)) ~at in
let* at = encode_list encode_int32 buf glyphids ~at in
let* at = encode_list encode_glyphinfo buf glyphs ~at in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_glyphs ~(glyphset : glyphset) ~(glyphs : glyph list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let* at = encode_glyphset buf glyphset ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_glyph buf glyphs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_composite_glyphs8 ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset) ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_glyphset buf glyphset ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_char buf glyphcmds ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_composite_glyphs16 ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset) ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_glyphset buf glyphset ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_char buf glyphcmds ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_composite_glyphs32 ~(op : pict_op_enum) ~(src : picture) ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset) ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf src ~at in
let* at = encode_picture buf dst ~at in
let* at = encode_pictformat buf mask_format ~at in
let* at = encode_glyphset buf glyphset ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_list encode_char buf glyphcmds ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_fill_rectangles ~(op : pict_op_enum) ~(dst : picture) ~(color : color) ~(rects : Xproto.rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = encode_enum encode_uint8 identity pict_op_int_of_enum buf op ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_picture buf dst ~at in
let* at = encode_color buf color ~at in
let* at = encode_list Xproto.encode_rectangle buf rects ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_cursor ~(cid : Xproto.cursor) ~(source : picture) ~(x : int) ~(y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let* at = Xproto.encode_cursor buf cid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_picture buf source ~at in
let* at = encode_uint16 buf x ~at in
let* at = encode_uint16 buf y ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type transform = { matrix11 : fixed; matrix12 : fixed; matrix13 : fixed; matrix21 : fixed; matrix22 : fixed; matrix23 : fixed; matrix31 : fixed; matrix32 : fixed; matrix33 : fixed; } [@@deriving sexp];;
let decode_transform buf ~at : (transform * int) option = let orig = at in let* matrix11, at = decode_fixed buf ~at in
let* matrix12, at = decode_fixed buf ~at in
let* matrix13, at = decode_fixed buf ~at in
let* matrix21, at = decode_fixed buf ~at in
let* matrix22, at = decode_fixed buf ~at in
let* matrix23, at = decode_fixed buf ~at in
let* matrix31, at = decode_fixed buf ~at in
let* matrix32, at = decode_fixed buf ~at in
let* matrix33, at = decode_fixed buf ~at in
ignore orig;
Some ({ matrix11; matrix12; matrix13; matrix21; matrix22; matrix23; matrix31; matrix32; matrix33 }, at);;
let encode_transform buf (v : transform) ~at : int option = let orig = at in let* at = encode_fixed buf v.matrix11 ~at in let* at = encode_fixed buf v.matrix12 ~at in let* at = encode_fixed buf v.matrix13 ~at in let* at = encode_fixed buf v.matrix21 ~at in let* at = encode_fixed buf v.matrix22 ~at in let* at = encode_fixed buf v.matrix23 ~at in let* at = encode_fixed buf v.matrix31 ~at in let* at = encode_fixed buf v.matrix32 ~at in let* at = encode_fixed buf v.matrix33 ~at in ignore orig; Some at;;

let encode_set_picture_transform ~(picture : picture) ~(transform : transform)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_transform buf transform ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_filters_reply = { aliases : int list; filters : Xproto.str list; } [@@deriving sexp];;
let encode_query_filters ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_filters_reply length buf ~at : (query_filters_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_aliases, at = decode_int32 buf ~at in let num_aliases = num_aliases in
let* num_filters, at = decode_int32 buf ~at in let num_filters = num_filters in
let at = at + 16 in
let* aliases, at = decode_list (decode_uint16) num_aliases buf ~at in
let* filters, at = decode_list (Xproto.decode_str) num_filters buf ~at in
ignore orig;
Some ({ aliases; filters }, at);;
let encode_set_picture_filter ~(picture : picture) ~(filter : string) ~(values : fixed list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length filter)) ~at in
let at = at + 2 in
let* at = encode_string buf filter ~at in
let at = at + ((at - orig) mod 4) in
let* at = encode_list encode_fixed buf values ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type animcursorelt = { cursor : Xproto.cursor; delay : int; } [@@deriving sexp];;
let decode_animcursorelt buf ~at : (animcursorelt * int) option = let orig = at in let* cursor, at = Xproto.decode_cursor buf ~at in
let* delay, at = decode_int32 buf ~at in
ignore orig;
Some ({ cursor; delay }, at);;
let encode_animcursorelt buf (v : animcursorelt) ~at : int option = let orig = at in let* at = Xproto.encode_cursor buf v.cursor ~at in let* at = encode_int32 buf v.delay ~at in ignore orig; Some at;;

let encode_create_anim_cursor ~(cid : Xproto.cursor) ~(cursors : animcursorelt list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = Xproto.encode_cursor buf cid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_animcursorelt buf cursors ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type spanfix = { l : fixed; r : fixed; y : fixed; } [@@deriving sexp];;
let decode_spanfix buf ~at : (spanfix * int) option = let orig = at in let* l, at = decode_fixed buf ~at in
let* r, at = decode_fixed buf ~at in
let* y, at = decode_fixed buf ~at in
ignore orig;
Some ({ l; r; y }, at);;
let encode_spanfix buf (v : spanfix) ~at : int option = let orig = at in let* at = encode_fixed buf v.l ~at in let* at = encode_fixed buf v.r ~at in let* at = encode_fixed buf v.y ~at in ignore orig; Some at;;

type trap = { top : spanfix; bot : spanfix; } [@@deriving sexp];;
let decode_trap buf ~at : (trap * int) option = let orig = at in let* top, at = decode_spanfix buf ~at in
let* bot, at = decode_spanfix buf ~at in
ignore orig;
Some ({ top; bot }, at);;
let encode_trap buf (v : trap) ~at : int option = let orig = at in let* at = encode_spanfix buf v.top ~at in let* at = encode_spanfix buf v.bot ~at in ignore orig; Some at;;

let encode_add_traps ~(picture : picture) ~(x_off : int) ~(y_off : int) ~(traps : trap list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf x_off ~at in
let* at = encode_int16 buf y_off ~at in
let* at = encode_list encode_trap buf traps ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_solid_fill ~(picture : picture) ~(color : color)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 33 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_color buf color ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_linear_gradient ~(picture : picture) ~(p1 : pointfix) ~(p2 : pointfix) ~(stops : fixed list) ~(colors : color list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 34 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pointfix buf p1 ~at in
let* at = encode_pointfix buf p2 ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Int32 *) List.length stops)) ~at in
let* at = encode_list encode_fixed buf stops ~at in
let* at = encode_list encode_color buf colors ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_radial_gradient ~(picture : picture) ~(inner : pointfix) ~(outer : pointfix) ~(inner_radius : fixed) ~(outer_radius : fixed) ~(stops : fixed list) ~(colors : color list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 35 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pointfix buf inner ~at in
let* at = encode_pointfix buf outer ~at in
let* at = encode_fixed buf inner_radius ~at in
let* at = encode_fixed buf outer_radius ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Int32 *) List.length stops)) ~at in
let* at = encode_list encode_fixed buf stops ~at in
let* at = encode_list encode_color buf colors ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_conical_gradient ~(picture : picture) ~(center : pointfix) ~(angle : fixed) ~(stops : fixed list) ~(colors : color list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 36 ~at in
let* at = encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_pointfix buf center ~at in
let* at = encode_fixed buf angle ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Int32 *) List.length stops)) ~at in
let* at = encode_list encode_fixed buf stops ~at in
let* at = encode_list encode_color buf colors ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
end
module[@warning "-27"] Shape = struct
type op = int [@@deriving sexp];;
let decode_op = decode_uint8;;
let encode_op = encode_uint8;;

type kind = int [@@deriving sexp];;
let decode_kind = decode_uint8;;
let encode_kind = encode_uint8;;

type so_enum = [ `Set | `Union | `Intersect | `Subtract | `Invert ] [@@deriving sexp];;
let so_enum_of_int : int -> [> so_enum ] option = function 0 -> Some `Set | 1 -> Some `Union | 2 -> Some `Intersect | 3 -> Some `Subtract | 4 -> Some `Invert | n -> Printf.printf "unknown so_enum: %d\n" n; None;;
let so_int_of_enum : so_enum -> int = function `Set -> 0 | `Union -> 1 | `Intersect -> 2 | `Subtract -> 3 | `Invert -> 4;;
type sk_enum = [ `Bounding | `Clip | `Input ] [@@deriving sexp];;
let sk_enum_of_int : int -> [> sk_enum ] option = function 0 -> Some `Bounding | 1 -> Some `Clip | 2 -> Some `Input | n -> Printf.printf "unknown sk_enum: %d\n" n; None;;
let sk_int_of_enum : sk_enum -> int = function `Bounding -> 0 | `Clip -> 1 | `Input -> 2;;
type notify_event = { shape_kind : sk_enum; affected_window : Xproto.window; extents_x : int; extents_y : int; extents_width : int; extents_height : int; server_time : Xproto.timestamp; shaped : bool; } [@@deriving sexp];;
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
let encode_rectangles ~(operation : so_enum) ~(destination_kind : sk_enum) ~(ordering : Xproto.clip_ordering_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) ~(rectangles : Xproto.rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_enum encode_op identity so_int_of_enum buf operation ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_kind identity sk_int_of_enum buf destination_kind ~at in
let* at = encode_enum encode_char Char.chr Xproto.clip_ordering_int_of_enum buf ordering ~at in
let at = at + 1 in
let* at = Xproto.encode_window buf destination_window ~at in
let* at = encode_int16 buf x_offset ~at in
let* at = encode_int16 buf y_offset ~at in
let* at = encode_list Xproto.encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_mask ~(operation : so_enum) ~(destination_kind : sk_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) ~(source_bitmap : Xproto.pixmap_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_enum encode_op identity so_int_of_enum buf operation ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_kind identity sk_int_of_enum buf destination_kind ~at in
let at = at + 2 in
let* at = Xproto.encode_window buf destination_window ~at in
let* at = encode_int16 buf x_offset ~at in
let* at = encode_int16 buf y_offset ~at in
let* at = encode_alt_enum Xproto.encode_pixmap identity Xproto.pixmap_int_of_enum buf source_bitmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_combine ~(operation : so_enum) ~(destination_kind : sk_enum) ~(source_kind : sk_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int) ~(source_window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_enum encode_op identity so_int_of_enum buf operation ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_kind identity sk_int_of_enum buf destination_kind ~at in
let* at = encode_enum encode_kind identity sk_int_of_enum buf source_kind ~at in
let at = at + 1 in
let* at = Xproto.encode_window buf destination_window ~at in
let* at = encode_int16 buf x_offset ~at in
let* at = encode_int16 buf y_offset ~at in
let* at = Xproto.encode_window buf source_window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_offset ~(destination_kind : sk_enum) ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_enum encode_kind identity sk_int_of_enum buf destination_kind ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = Xproto.encode_window buf destination_window ~at in
let* at = encode_int16 buf x_offset ~at in
let* at = encode_int16 buf y_offset ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_extents_reply = { bounding_shaped : bool; clip_shaped : bool; bounding_shape_extents_x : int; bounding_shape_extents_y : int; bounding_shape_extents_width : int; bounding_shape_extents_height : int; clip_shape_extents_x : int; clip_shape_extents_y : int; clip_shape_extents_width : int; clip_shape_extents_height : int; } [@@deriving sexp];;
let encode_query_extents ~(destination_window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = Xproto.encode_window buf destination_window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_extents_reply length buf ~at : (query_extents_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* bounding_shaped, at = decode_bool buf ~at in
let* clip_shaped, at = decode_bool buf ~at in
let at = at + 2 in
let* bounding_shape_extents_x, at = decode_int16 buf ~at in
let* bounding_shape_extents_y, at = decode_int16 buf ~at in
let* bounding_shape_extents_width, at = decode_uint16 buf ~at in
let* bounding_shape_extents_height, at = decode_uint16 buf ~at in
let* clip_shape_extents_x, at = decode_int16 buf ~at in
let* clip_shape_extents_y, at = decode_int16 buf ~at in
let* clip_shape_extents_width, at = decode_uint16 buf ~at in
let* clip_shape_extents_height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ bounding_shaped; clip_shaped; bounding_shape_extents_x; bounding_shape_extents_y; bounding_shape_extents_width; bounding_shape_extents_height; clip_shape_extents_x; clip_shape_extents_y; clip_shape_extents_width; clip_shape_extents_height }, at);;
let encode_select_input ~(destination_window : Xproto.window) ~(enable : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = Xproto.encode_window buf destination_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_bool buf enable ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type input_selected_reply = { enabled : bool; } [@@deriving sexp];;
let encode_input_selected ~(destination_window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_window buf destination_window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_input_selected_reply length buf ~at : (input_selected_reply * int) option = let orig = at in let at = at + 1 in
let* enabled, at = decode_bool buf ~at in
let at = at + 6 in
ignore orig;
Some ({ enabled }, at);;
type get_rectangles_reply = { ordering : Xproto.clip_ordering_enum; rectangles : Xproto.rectangle list; } [@@deriving sexp];;
let encode_get_rectangles ~(window : Xproto.window) ~(source_kind : sk_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_kind identity sk_int_of_enum buf source_kind ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_rectangles_reply length buf ~at : (get_rectangles_reply * int) option = let orig = at in let at = at + 1 in
let* ordering, at = decode_enum decode_char Char.code Xproto.clip_ordering_enum_of_int buf ~at in
let at = at + 6 in
let* rectangles_len, at = decode_int32 buf ~at in let rectangles_len = rectangles_len in
let at = at + 20 in
let* rectangles, at = decode_list (Xproto.decode_rectangle) rectangles_len buf ~at in
ignore orig;
Some ({ ordering; rectangles }, at);;
end
module[@warning "-27"] Xfixes = struct
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ major_version; minor_version }, at);;
type save_set_mode_enum = [ `Insert | `Delete ] [@@deriving sexp];;
let save_set_mode_enum_of_int : int -> [> save_set_mode_enum ] option = function 0 -> Some `Insert | 1 -> Some `Delete | n -> Printf.printf "unknown save_set_mode_enum: %d\n" n; None;;
let save_set_mode_int_of_enum : save_set_mode_enum -> int = function `Insert -> 0 | `Delete -> 1;;
type save_set_target_enum = [ `Nearest | `Root ] [@@deriving sexp];;
let save_set_target_enum_of_int : int -> [> save_set_target_enum ] option = function 0 -> Some `Nearest | 1 -> Some `Root | n -> Printf.printf "unknown save_set_target_enum: %d\n" n; None;;
let save_set_target_int_of_enum : save_set_target_enum -> int = function `Nearest -> 0 | `Root -> 1;;
type save_set_mapping_enum = [ `Map | `Unmap ] [@@deriving sexp];;
let save_set_mapping_enum_of_int : int -> [> save_set_mapping_enum ] option = function 0 -> Some `Map | 1 -> Some `Unmap | n -> Printf.printf "unknown save_set_mapping_enum: %d\n" n; None;;
let save_set_mapping_int_of_enum : save_set_mapping_enum -> int = function `Map -> 0 | `Unmap -> 1;;
let encode_change_save_set ~(mode : save_set_mode_enum) ~(target : save_set_target_enum) ~(map : save_set_mapping_enum) ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_enum encode_char Char.chr save_set_mode_int_of_enum buf mode ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_char Char.chr save_set_target_int_of_enum buf target ~at in
let* at = encode_enum encode_char Char.chr save_set_mapping_int_of_enum buf map ~at in
let at = at + 1 in
let* at = Xproto.encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type selection_event_enum = [ `Set_selection_owner | `Selection_window_destroy | `Selection_client_close ] [@@deriving sexp];;
let selection_event_enum_of_int : int -> [> selection_event_enum ] option = function 0 -> Some `Set_selection_owner | 1 -> Some `Selection_window_destroy | 2 -> Some `Selection_client_close | n -> Printf.printf "unknown selection_event_enum: %d\n" n; None;;
let selection_event_int_of_enum : selection_event_enum -> int = function `Set_selection_owner -> 0 | `Selection_window_destroy -> 1 | `Selection_client_close -> 2;;
type selection_event_mask = [ `Set_selection_owner | `Selection_window_destroy | `Selection_client_close ] list [@@deriving sexp];;
let selection_event_mask_mask_of_int64 mask : selection_event_mask option = let of_int = function 0 -> Some `Set_selection_owner | 1 -> Some `Selection_window_destroy | 2 -> Some `Selection_client_close | _ -> None in mask_of_int of_int mask;;
let selection_event_mask_int_of_mask : selection_event_mask -> int = let to_bit = function `Set_selection_owner -> 0 | `Selection_window_destroy -> 1 | `Selection_client_close -> 2 in int_of_mask to_bit;;
type selection_notify_event = { subtype : selection_event_enum; window : Xproto.window; owner : Xproto.window; selection : Xproto.atom; timestamp : Xproto.timestamp; selection_timestamp : Xproto.timestamp; } [@@deriving sexp];;
let encode_select_selection_input ~(window : Xproto.window) ~(selection : Xproto.atom) ~(event_mask : selection_event_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf selection ~at in
let* at = encode_mask encode_int32 identity selection_event_mask_int_of_mask buf event_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type cursor_notify_enum = [ `Display_cursor ] [@@deriving sexp];;
let cursor_notify_enum_of_int : int -> [> cursor_notify_enum ] option = function 0 -> Some `Display_cursor | n -> Printf.printf "unknown cursor_notify_enum: %d\n" n; None;;
let cursor_notify_int_of_enum : cursor_notify_enum -> int = function `Display_cursor -> 0;;
type cursor_notify_mask = [ `Display_cursor ] list [@@deriving sexp];;
let cursor_notify_mask_mask_of_int64 mask : cursor_notify_mask option = let of_int = function 0 -> Some `Display_cursor | _ -> None in mask_of_int of_int mask;;
let cursor_notify_mask_int_of_mask : cursor_notify_mask -> int = let to_bit = function `Display_cursor -> 0 in int_of_mask to_bit;;
type cursor_notify_event = { subtype : cursor_notify_enum; window : Xproto.window; cursor_serial : int; timestamp : Xproto.timestamp; name : Xproto.atom_enum alt_enum; } [@@deriving sexp];;
let encode_select_cursor_input ~(window : Xproto.window) ~(event_mask : cursor_notify_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mask encode_int32 identity cursor_notify_mask_int_of_mask buf event_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_cursor_image_reply = { x : int; y : int; width : int; height : int; xhot : int; yhot : int; cursor_serial : int; cursor_image : int list; } [@@deriving sexp];;
let encode_get_cursor_image  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_cursor_image_reply length buf ~at : (get_cursor_image_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* xhot, at = decode_uint16 buf ~at in
let* yhot, at = decode_uint16 buf ~at in
let* cursor_serial, at = decode_int32 buf ~at in
let at = at + 8 in
let* cursor_image, at = let length = (width) * (height) in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ x; y; width; height; xhot; yhot; cursor_serial; cursor_image }, at);;
type region = xid [@@deriving sexp];;
let decode_region = decode_xid;;
let encode_region = encode_xid;;

type bad_region_error = unit [@@deriving sexp];;
type region_enum = [ `None ] [@@deriving sexp];;
let region_enum_of_int : int -> [> region_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown region_enum: %d\n" n; None;;
let region_int_of_enum : region_enum -> int = function `None -> 0;;
let encode_create_region ~(region : region) ~(rectangles : Xproto.rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list Xproto.encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_region_from_bitmap ~(region : region) ~(bitmap : Xproto.pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_pixmap buf bitmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_region_from_window ~(region : region) ~(window : Xproto.window) ~(kind : Shape.sk_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf window ~at in
let* at = encode_enum Shape.encode_kind identity Shape.sk_int_of_enum buf kind ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_region_from_gc ~(region : region) ~(gc : Xproto.gcontext)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_gcontext buf gc ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_region_from_picture ~(region : region) ~(picture : Render.picture)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Render.encode_picture buf picture ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_region ~(region : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_region ~(region : region) ~(rectangles : Xproto.rectangle list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list Xproto.encode_rectangle buf rectangles ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_copy_region ~(source : region) ~(destination : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_region buf source ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_region buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_union_region ~(source1 : region) ~(source2 : region) ~(destination : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_region buf source1 ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_region buf source2 ~at in
let* at = encode_region buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_intersect_region ~(source1 : region) ~(source2 : region) ~(destination : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_region buf source1 ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_region buf source2 ~at in
let* at = encode_region buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_subtract_region ~(source1 : region) ~(source2 : region) ~(destination : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_region buf source1 ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_region buf source2 ~at in
let* at = encode_region buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_invert_region ~(source : region) ~(bounds : Xproto.rectangle) ~(destination : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_region buf source ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_rectangle buf bounds ~at in
let* at = encode_region buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_translate_region ~(region : region) ~(dx : int) ~(dy : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf dx ~at in
let* at = encode_int16 buf dy ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_region_extents ~(source : region) ~(destination : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_region buf source ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_region buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type fetch_region_reply = { extents : Xproto.rectangle; rectangles : Xproto.rectangle list; } [@@deriving sexp];;
let encode_fetch_region ~(region : region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_fetch_region_reply length buf ~at : (fetch_region_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* extents, at = Xproto.decode_rectangle buf ~at in
let at = at + 16 in
let* rectangles, at = let length = (length) / (2) in decode_list (Xproto.decode_rectangle) length buf ~at in
ignore orig;
Some ({ extents; rectangles }, at);;
let encode_set_gc_clip_region ~(gc : Xproto.gcontext) ~(region : region_enum alt_enum) ~(x_origin : int) ~(y_origin : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_region identity region_int_of_enum buf region ~at in
let* at = encode_int16 buf x_origin ~at in
let* at = encode_int16 buf y_origin ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_window_shape_region ~(dest : Xproto.window) ~(dest_kind : Shape.sk_enum) ~(x_offset : int) ~(y_offset : int) ~(region : region_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let* at = Xproto.encode_window buf dest ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum Shape.encode_kind identity Shape.sk_int_of_enum buf dest_kind ~at in
let at = at + 3 in
let* at = encode_int16 buf x_offset ~at in
let* at = encode_int16 buf y_offset ~at in
let* at = encode_alt_enum encode_region identity region_int_of_enum buf region ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_picture_clip_region ~(picture : Render.picture) ~(region : region_enum alt_enum) ~(x_origin : int) ~(y_origin : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let* at = Render.encode_picture buf picture ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_region identity region_int_of_enum buf region ~at in
let* at = encode_int16 buf x_origin ~at in
let* at = encode_int16 buf y_origin ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_cursor_name ~(cursor : Xproto.cursor) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let* at = Xproto.encode_cursor buf cursor ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_cursor_name_reply = { atom : Xproto.atom_enum alt_enum; name : string; } [@@deriving sexp];;
let encode_get_cursor_name ~(cursor : Xproto.cursor)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let* at = Xproto.encode_cursor buf cursor ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_cursor_name_reply length buf ~at : (get_cursor_name_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* atom, at = decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf ~at in
let* nbytes, at = decode_uint16 buf ~at in let nbytes = nbytes in
let at = at + 18 in
let* name, at = decode_string nbytes buf ~at in
ignore orig;
Some ({ atom; name }, at);;
type get_cursor_image_and_name_reply = { x : int; y : int; width : int; height : int; xhot : int; yhot : int; cursor_serial : int; cursor_atom : Xproto.atom_enum alt_enum; cursor_image : int list; name : string; } [@@deriving sexp];;
let encode_get_cursor_image_and_name  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_cursor_image_and_name_reply length buf ~at : (get_cursor_image_and_name_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* xhot, at = decode_uint16 buf ~at in
let* yhot, at = decode_uint16 buf ~at in
let* cursor_serial, at = decode_int32 buf ~at in
let* cursor_atom, at = decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf ~at in
let* nbytes, at = decode_uint16 buf ~at in let nbytes = nbytes in
let at = at + 2 in
let* cursor_image, at = let length = (width) * (height) in decode_list (decode_int32) length buf ~at in
let* name, at = decode_string nbytes buf ~at in
ignore orig;
Some ({ x; y; width; height; xhot; yhot; cursor_serial; cursor_atom; cursor_image; name }, at);;
let encode_change_cursor ~(source : Xproto.cursor) ~(destination : Xproto.cursor)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = Xproto.encode_cursor buf source ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_cursor buf destination ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_cursor_by_name ~(src : Xproto.cursor) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let* at = Xproto.encode_cursor buf src ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_expand_region ~(source : region) ~(destination : region) ~(left : int) ~(right : int) ~(top : int) ~(bottom : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_region buf source ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_region buf destination ~at in
let* at = encode_uint16 buf left ~at in
let* at = encode_uint16 buf right ~at in
let* at = encode_uint16 buf top ~at in
let* at = encode_uint16 buf bottom ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_hide_cursor ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_show_cursor ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type barrier = xid [@@deriving sexp];;
let decode_barrier = decode_xid;;
let encode_barrier = encode_xid;;

type barrier_directions_mask = [ `Positive_x | `Positive_y | `Negative_x | `Negative_y ] list [@@deriving sexp];;
let barrier_directions_mask_of_int64 mask : barrier_directions_mask option = let of_int = function 0 -> Some `Positive_x | 1 -> Some `Positive_y | 2 -> Some `Negative_x | 3 -> Some `Negative_y | _ -> None in mask_of_int of_int mask;;
let barrier_directions_int_of_mask : barrier_directions_mask -> int = let to_bit = function `Positive_x -> 0 | `Positive_y -> 1 | `Negative_x -> 2 | `Negative_y -> 3 in int_of_mask to_bit;;
let encode_create_pointer_barrier ~(barrier : barrier) ~(window : Xproto.window) ~(x1 : int) ~(y1 : int) ~(x2 : int) ~(y2 : int) ~(directions : barrier_directions_mask) ~(devices : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = encode_barrier buf barrier ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf window ~at in
let* at = encode_uint16 buf x1 ~at in
let* at = encode_uint16 buf y1 ~at in
let* at = encode_uint16 buf x2 ~at in
let* at = encode_uint16 buf y2 ~at in
let* at = encode_mask encode_int32 identity barrier_directions_int_of_mask buf directions ~at in
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* Parsetree.Card16 *) List.length devices)) ~at in
let* at = encode_list encode_uint16 buf devices ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_pointer_barrier ~(barrier : barrier)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let* at = encode_barrier buf barrier ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
end
module[@warning "-27"] Composite = struct
type redirect_enum = [ `Automatic | `Manual ] [@@deriving sexp];;
let redirect_enum_of_int : int -> [> redirect_enum ] option = function 0 -> Some `Automatic | 1 -> Some `Manual | n -> Printf.printf "unknown redirect_enum: %d\n" n; None;;
let redirect_int_of_enum : redirect_enum -> int = function `Automatic -> 0 | `Manual -> 1;;
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ major_version; minor_version }, at);;
let encode_redirect_window ~(window : Xproto.window) ~(update : redirect_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity redirect_int_of_enum buf update ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_redirect_subwindows ~(window : Xproto.window) ~(update : redirect_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity redirect_int_of_enum buf update ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_unredirect_window ~(window : Xproto.window) ~(update : redirect_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity redirect_int_of_enum buf update ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_unredirect_subwindows ~(window : Xproto.window) ~(update : redirect_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity redirect_int_of_enum buf update ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_region_from_border_clip ~(region : Xfixes.region) ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = Xfixes.encode_region buf region ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_name_window_pixmap ~(window : Xproto.window) ~(pixmap : Xproto.pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_pixmap buf pixmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_overlay_window_reply = { overlay_win : Xproto.window; } [@@deriving sexp];;
let encode_get_overlay_window ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_overlay_window_reply length buf ~at : (get_overlay_window_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* overlay_win, at = Xproto.decode_window buf ~at in
let at = at + 20 in
ignore orig;
Some ({ overlay_win }, at);;
let encode_release_overlay_window ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
end
module[@warning "-27"] Damage = struct
type damage = xid [@@deriving sexp];;
let decode_damage = decode_xid;;
let encode_damage = encode_xid;;

type report_level_enum = [ `Raw_rectangles | `Delta_rectangles | `Bounding_box | `Non_empty ] [@@deriving sexp];;
let report_level_enum_of_int : int -> [> report_level_enum ] option = function 0 -> Some `Raw_rectangles | 1 -> Some `Delta_rectangles | 2 -> Some `Bounding_box | 3 -> Some `Non_empty | n -> Printf.printf "unknown report_level_enum: %d\n" n; None;;
let report_level_int_of_enum : report_level_enum -> int = function `Raw_rectangles -> 0 | `Delta_rectangles -> 1 | `Bounding_box -> 2 | `Non_empty -> 3;;
type bad_damage_error = unit [@@deriving sexp];;
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ major_version; minor_version }, at);;
let encode_create ~(damage : damage) ~(drawable : Xproto.drawable) ~(level : report_level_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_damage buf damage ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = encode_enum encode_uint8 identity report_level_int_of_enum buf level ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy ~(damage : damage)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_damage buf damage ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_subtract ~(damage : damage) ~(repair : Xfixes.region_enum alt_enum) ~(parts : Xfixes.region_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_damage buf damage ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xfixes.encode_region identity Xfixes.region_int_of_enum buf repair ~at in
let* at = encode_alt_enum Xfixes.encode_region identity Xfixes.region_int_of_enum buf parts ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_add ~(drawable : Xproto.drawable) ~(region : Xfixes.region)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xfixes.encode_region buf region ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type notify_event = { level : report_level_enum; drawable : Xproto.drawable; damage : damage; timestamp : Xproto.timestamp; area : Xproto.rectangle; geometry : Xproto.rectangle; } [@@deriving sexp];;
end
module[@warning "-27"] Dpms = struct
type get_version_reply = { server_major_version : int; server_minor_version : int; } [@@deriving sexp];;
let encode_get_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint16 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_version_reply length buf ~at : (get_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* server_major_version, at = decode_uint16 buf ~at in
let* server_minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ server_major_version; server_minor_version }, at);;
type capable_reply = { capable : bool; } [@@deriving sexp];;
let encode_capable  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_capable_reply length buf ~at : (capable_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* capable, at = decode_bool buf ~at in
let at = at + 23 in
ignore orig;
Some ({ capable }, at);;
type get_timeouts_reply = { standby_timeout : int; suspend_timeout : int; off_timeout : int; } [@@deriving sexp];;
let encode_get_timeouts  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_timeouts_reply length buf ~at : (get_timeouts_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* standby_timeout, at = decode_uint16 buf ~at in
let* suspend_timeout, at = decode_uint16 buf ~at in
let* off_timeout, at = decode_uint16 buf ~at in
let at = at + 18 in
ignore orig;
Some ({ standby_timeout; suspend_timeout; off_timeout }, at);;
let encode_set_timeouts ~(standby_timeout : int) ~(suspend_timeout : int) ~(off_timeout : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_uint16 buf standby_timeout ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf suspend_timeout ~at in
let* at = encode_uint16 buf off_timeout ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_enable  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_disable  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type dpms_mode_enum = [ `On | `Standby | `Suspend | `Off ] [@@deriving sexp];;
let dpms_mode_enum_of_int : int -> [> dpms_mode_enum ] option = function 0 -> Some `On | 1 -> Some `Standby | 2 -> Some `Suspend | 3 -> Some `Off | n -> Printf.printf "unknown dpms_mode_enum: %d\n" n; None;;
let dpms_mode_int_of_enum : dpms_mode_enum -> int = function `On -> 0 | `Standby -> 1 | `Suspend -> 2 | `Off -> 3;;
let encode_force_level ~(power_level : dpms_mode_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_enum encode_uint16 identity dpms_mode_int_of_enum buf power_level ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type info_reply = { power_level : dpms_mode_enum; state : bool; } [@@deriving sexp];;
let encode_info  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_info_reply length buf ~at : (info_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* power_level, at = decode_enum decode_uint16 identity dpms_mode_enum_of_int buf ~at in
let* state, at = decode_bool buf ~at in
let at = at + 21 in
ignore orig;
Some ({ power_level; state }, at);;
end
module[@warning "-27"] Dri2 = struct
type attachment_enum = [ `Buffer_front_left | `Buffer_back_left | `Buffer_front_right | `Buffer_back_right | `Buffer_depth | `Buffer_stencil | `Buffer_accum | `Buffer_fake_front_left | `Buffer_fake_front_right | `Buffer_depth_stencil | `Buffer_hiz ] [@@deriving sexp];;
let attachment_enum_of_int : int -> [> attachment_enum ] option = function 0 -> Some `Buffer_front_left | 1 -> Some `Buffer_back_left | 2 -> Some `Buffer_front_right | 3 -> Some `Buffer_back_right | 4 -> Some `Buffer_depth | 5 -> Some `Buffer_stencil | 6 -> Some `Buffer_accum | 7 -> Some `Buffer_fake_front_left | 8 -> Some `Buffer_fake_front_right | 9 -> Some `Buffer_depth_stencil | 10 -> Some `Buffer_hiz | n -> Printf.printf "unknown attachment_enum: %d\n" n; None;;
let attachment_int_of_enum : attachment_enum -> int = function `Buffer_front_left -> 0 | `Buffer_back_left -> 1 | `Buffer_front_right -> 2 | `Buffer_back_right -> 3 | `Buffer_depth -> 4 | `Buffer_stencil -> 5 | `Buffer_accum -> 6 | `Buffer_fake_front_left -> 7 | `Buffer_fake_front_right -> 8 | `Buffer_depth_stencil -> 9 | `Buffer_hiz -> 10;;
type driver_type_enum = [ `Dri | `Vdpau ] [@@deriving sexp];;
let driver_type_enum_of_int : int -> [> driver_type_enum ] option = function 0 -> Some `Dri | 1 -> Some `Vdpau | n -> Printf.printf "unknown driver_type_enum: %d\n" n; None;;
let driver_type_int_of_enum : driver_type_enum -> int = function `Dri -> 0 | `Vdpau -> 1;;
type event_type_enum = [ `Exchange_complete | `Blit_complete | `Flip_complete ] [@@deriving sexp];;
let event_type_enum_of_int : int -> [> event_type_enum ] option = function 1 -> Some `Exchange_complete | 2 -> Some `Blit_complete | 3 -> Some `Flip_complete | n -> Printf.printf "unknown event_type_enum: %d\n" n; None;;
let event_type_int_of_enum : event_type_enum -> int = function `Exchange_complete -> 1 | `Blit_complete -> 2 | `Flip_complete -> 3;;
type dri2_buffer = { attachment : attachment_enum; name : int; pitch : int; cpp : int; flags : int; } [@@deriving sexp];;
let decode_dri2_buffer buf ~at : (dri2_buffer * int) option = let orig = at in let* attachment, at = decode_enum decode_int32 identity attachment_enum_of_int buf ~at in
let* name, at = decode_int32 buf ~at in
let* pitch, at = decode_int32 buf ~at in
let* cpp, at = decode_int32 buf ~at in
let* flags, at = decode_int32 buf ~at in
ignore orig;
Some ({ attachment; name; pitch; cpp; flags }, at);;
let encode_dri2_buffer buf (v : dri2_buffer) ~at : int option = let orig = at in let* at = encode_enum encode_int32 identity attachment_int_of_enum buf v.attachment ~at in let* at = encode_int32 buf v.name ~at in let* at = encode_int32 buf v.pitch ~at in let* at = encode_int32 buf v.cpp ~at in let* at = encode_int32 buf v.flags ~at in ignore orig; Some at;;

type attach_format = { attachment : attachment_enum; format : int; } [@@deriving sexp];;
let decode_attach_format buf ~at : (attach_format * int) option = let orig = at in let* attachment, at = decode_enum decode_int32 identity attachment_enum_of_int buf ~at in
let* format, at = decode_int32 buf ~at in
ignore orig;
Some ({ attachment; format }, at);;
let encode_attach_format buf (v : attach_format) ~at : int option = let orig = at in let* at = encode_enum encode_int32 identity attachment_int_of_enum buf v.attachment ~at in let* at = encode_int32 buf v.format ~at in ignore orig; Some at;;

type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
type connect_reply = { driver_name : string; alignment_pad : string; device_name : string; } [@@deriving sexp];;
let encode_connect ~(window : Xproto.window) ~(driver_type : driver_type_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_int32 identity driver_type_int_of_enum buf driver_type ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_connect_reply length buf ~at : (connect_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* driver_name_length, at = decode_int32 buf ~at in let driver_name_length = driver_name_length in
let* device_name_length, at = decode_int32 buf ~at in let device_name_length = device_name_length in
let at = at + 16 in
let* driver_name, at = decode_string driver_name_length buf ~at in
let* alignment_pad, at = let length = (((driver_name_length) + (3)) land (lnot (3))) - (driver_name_length) in decode_string length buf ~at in
let* device_name, at = decode_string device_name_length buf ~at in
ignore orig;
Some ({ driver_name; alignment_pad; device_name }, at);;
type authenticate_reply = { authenticated : int; } [@@deriving sexp];;
let encode_authenticate ~(window : Xproto.window) ~(magic : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf magic ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_authenticate_reply length buf ~at : (authenticate_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* authenticated, at = decode_int32 buf ~at in
ignore orig;
Some ({ authenticated }, at);;
let encode_create_drawable ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_drawable ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_buffers_reply = { width : int; height : int; buffers : dri2_buffer list; } [@@deriving sexp];;
let encode_get_buffers ~(drawable : Xproto.drawable) ~(attachments : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attachments)) ~at in
let* at = encode_list encode_int32 buf attachments ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_buffers_reply length buf ~at : (get_buffers_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let* count, at = decode_int32 buf ~at in let count = count in
let at = at + 12 in
let* buffers, at = decode_list (decode_dri2_buffer) count buf ~at in
ignore orig;
Some ({ width; height; buffers }, at);;
type copy_region_reply = unit [@@deriving sexp];;
let encode_copy_region ~(drawable : Xproto.drawable) ~(region : int) ~(dest : int) ~(src : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf region ~at in
let* at = encode_int32 buf dest ~at in
let* at = encode_int32 buf src ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_copy_region_reply length buf ~at : (copy_region_reply * int) option = ignore length; ignore buf; Some ((), at);;
type get_buffers_with_format_reply = { width : int; height : int; buffers : dri2_buffer list; } [@@deriving sexp];;
let encode_get_buffers_with_format ~(drawable : Xproto.drawable) ~(attachments : attach_format list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* invalid_argument *) List.length attachments)) ~at in
let* at = encode_list encode_attach_format buf attachments ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_buffers_with_format_reply length buf ~at : (get_buffers_with_format_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let* count, at = decode_int32 buf ~at in let count = count in
let at = at + 12 in
let* buffers, at = decode_list (decode_dri2_buffer) count buf ~at in
ignore orig;
Some ({ width; height; buffers }, at);;
type swap_buffers_reply = { swap_hi : int; swap_lo : int; } [@@deriving sexp];;
let encode_swap_buffers ~(drawable : Xproto.drawable) ~(target_msc_hi : int) ~(target_msc_lo : int) ~(divisor_hi : int) ~(divisor_lo : int) ~(remainder_hi : int) ~(remainder_lo : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target_msc_hi ~at in
let* at = encode_int32 buf target_msc_lo ~at in
let* at = encode_int32 buf divisor_hi ~at in
let* at = encode_int32 buf divisor_lo ~at in
let* at = encode_int32 buf remainder_hi ~at in
let* at = encode_int32 buf remainder_lo ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_swap_buffers_reply length buf ~at : (swap_buffers_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* swap_hi, at = decode_int32 buf ~at in
let* swap_lo, at = decode_int32 buf ~at in
ignore orig;
Some ({ swap_hi; swap_lo }, at);;
type get_msc_reply = { ust_hi : int; ust_lo : int; msc_hi : int; msc_lo : int; sbc_hi : int; sbc_lo : int; } [@@deriving sexp];;
let encode_get_msc ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_msc_reply length buf ~at : (get_msc_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ust_hi, at = decode_int32 buf ~at in
let* ust_lo, at = decode_int32 buf ~at in
let* msc_hi, at = decode_int32 buf ~at in
let* msc_lo, at = decode_int32 buf ~at in
let* sbc_hi, at = decode_int32 buf ~at in
let* sbc_lo, at = decode_int32 buf ~at in
ignore orig;
Some ({ ust_hi; ust_lo; msc_hi; msc_lo; sbc_hi; sbc_lo }, at);;
type wait_msc_reply = { ust_hi : int; ust_lo : int; msc_hi : int; msc_lo : int; sbc_hi : int; sbc_lo : int; } [@@deriving sexp];;
let encode_wait_msc ~(drawable : Xproto.drawable) ~(target_msc_hi : int) ~(target_msc_lo : int) ~(divisor_hi : int) ~(divisor_lo : int) ~(remainder_hi : int) ~(remainder_lo : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target_msc_hi ~at in
let* at = encode_int32 buf target_msc_lo ~at in
let* at = encode_int32 buf divisor_hi ~at in
let* at = encode_int32 buf divisor_lo ~at in
let* at = encode_int32 buf remainder_hi ~at in
let* at = encode_int32 buf remainder_lo ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_wait_msc_reply length buf ~at : (wait_msc_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ust_hi, at = decode_int32 buf ~at in
let* ust_lo, at = decode_int32 buf ~at in
let* msc_hi, at = decode_int32 buf ~at in
let* msc_lo, at = decode_int32 buf ~at in
let* sbc_hi, at = decode_int32 buf ~at in
let* sbc_lo, at = decode_int32 buf ~at in
ignore orig;
Some ({ ust_hi; ust_lo; msc_hi; msc_lo; sbc_hi; sbc_lo }, at);;
type wait_sbc_reply = { ust_hi : int; ust_lo : int; msc_hi : int; msc_lo : int; sbc_hi : int; sbc_lo : int; } [@@deriving sexp];;
let encode_wait_sbc ~(drawable : Xproto.drawable) ~(target_sbc_hi : int) ~(target_sbc_lo : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target_sbc_hi ~at in
let* at = encode_int32 buf target_sbc_lo ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_wait_sbc_reply length buf ~at : (wait_sbc_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ust_hi, at = decode_int32 buf ~at in
let* ust_lo, at = decode_int32 buf ~at in
let* msc_hi, at = decode_int32 buf ~at in
let* msc_lo, at = decode_int32 buf ~at in
let* sbc_hi, at = decode_int32 buf ~at in
let* sbc_lo, at = decode_int32 buf ~at in
ignore orig;
Some ({ ust_hi; ust_lo; msc_hi; msc_lo; sbc_hi; sbc_lo }, at);;
let encode_swap_interval ~(drawable : Xproto.drawable) ~(interval : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf interval ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_param_reply = { is_param_recognized : bool; value_hi : int; value_lo : int; } [@@deriving sexp];;
let encode_get_param ~(drawable : Xproto.drawable) ~(param : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf param ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_param_reply length buf ~at : (get_param_reply * int) option = let orig = at in let at = at + 1 in
let* is_param_recognized, at = decode_bool buf ~at in
let at = at + 6 in
let* value_hi, at = decode_int32 buf ~at in
let* value_lo, at = decode_int32 buf ~at in
ignore orig;
Some ({ is_param_recognized; value_hi; value_lo }, at);;
type buffer_swap_complete_event = { event_type : event_type_enum; drawable : Xproto.drawable; ust_hi : int; ust_lo : int; msc_hi : int; msc_lo : int; sbc : int; } [@@deriving sexp];;
type invalidate_buffers_event = { drawable : Xproto.drawable; } [@@deriving sexp];;
end
module[@warning "-27"] Dri3 = struct
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
type open_reply = { nfd : int; device_fd : Unix.file_descr; } [@@deriving sexp];;
let encode_open ~(drawable : Xproto.drawable) ~(provider : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf provider ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_open_reply length buf ~at : (open_reply * int) option = let orig = at in let at = at + 1 in
let* nfd, at = decode_uint8 buf ~at in
let at = at + 6 in
let* device_fd, at = decode_file_descr buf ~at in
let at = at + 24 in
ignore orig;
Some ({ nfd; device_fd }, at);;
let encode_pixmap_from_buffer ~(pixmap : Xproto.pixmap) ~(drawable : Xproto.drawable) ~(size : int) ~(width : int) ~(height : int) ~(stride : int) ~(depth : int) ~(bpp : int) ~(pixmap_fd : Unix.file_descr)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_pixmap buf pixmap ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = encode_int32 buf size ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint16 buf stride ~at in
let* at = encode_uint8 buf depth ~at in
let* at = encode_uint8 buf bpp ~at in
let* at = encode_file_descriptor buf pixmap_fd ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type buffer_from_pixmap_reply = { nfd : int; size : int; width : int; height : int; stride : int; depth : int; bpp : int; pixmap_fd : Unix.file_descr; } [@@deriving sexp];;
let encode_buffer_from_pixmap ~(pixmap : Xproto.pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_pixmap buf pixmap ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_buffer_from_pixmap_reply length buf ~at : (buffer_from_pixmap_reply * int) option = let orig = at in let at = at + 1 in
let* nfd, at = decode_uint8 buf ~at in
let at = at + 6 in
let* size, at = decode_int32 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* stride, at = decode_uint16 buf ~at in
let* depth, at = decode_uint8 buf ~at in
let* bpp, at = decode_uint8 buf ~at in
let* pixmap_fd, at = decode_file_descr buf ~at in
let at = at + 12 in
ignore orig;
Some ({ nfd; size; width; height; stride; depth; bpp; pixmap_fd }, at);;
let encode_fence_from_fd ~(drawable : Xproto.drawable) ~(fence : int) ~(initially_triggered : bool) ~(fence_fd : Unix.file_descr)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf fence ~at in
let* at = encode_bool buf initially_triggered ~at in
let at = at + 3 in
let* at = encode_file_descriptor buf fence_fd ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type fd_from_fence_reply = { nfd : int; fence_fd : Unix.file_descr; } [@@deriving sexp];;
let encode_fd_from_fence ~(drawable : Xproto.drawable) ~(fence : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf fence ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_fd_from_fence_reply length buf ~at : (fd_from_fence_reply * int) option = let orig = at in let at = at + 1 in
let* nfd, at = decode_uint8 buf ~at in
let at = at + 6 in
let* fence_fd, at = decode_file_descr buf ~at in
let at = at + 24 in
ignore orig;
Some ({ nfd; fence_fd }, at);;
type get_supported_modifiers_reply = { window_modifiers : int64 list; screen_modifiers : int64 list; } [@@deriving sexp];;
let encode_get_supported_modifiers ~(window : int) ~(depth : int) ~(bpp : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_int32 buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf depth ~at in
let* at = encode_uint8 buf bpp ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_supported_modifiers_reply length buf ~at : (get_supported_modifiers_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_window_modifiers, at = decode_int32 buf ~at in let num_window_modifiers = num_window_modifiers in
let* num_screen_modifiers, at = decode_int32 buf ~at in let num_screen_modifiers = num_screen_modifiers in
let at = at + 16 in
let* window_modifiers, at = decode_list (decode_int64) num_window_modifiers buf ~at in
let* screen_modifiers, at = decode_list (decode_int64) num_screen_modifiers buf ~at in
ignore orig;
Some ({ window_modifiers; screen_modifiers }, at);;
let encode_pixmap_from_buffers ~(pixmap : Xproto.pixmap) ~(window : Xproto.window) ~(width : int) ~(height : int) ~(stride0 : int) ~(offset0 : int) ~(stride1 : int) ~(offset1 : int) ~(stride2 : int) ~(offset2 : int) ~(stride3 : int) ~(offset3 : int) ~(depth : int) ~(bpp : int) ~(modifier : int64) ~(buffers : Unix.file_descr list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_pixmap buf pixmap ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf window ~at in
let* at = encode_uint8 buf (identity ((* Parsetree.Fd *) List.length buffers)) ~at in
let at = at + 3 in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf stride0 ~at in
let* at = encode_int32 buf offset0 ~at in
let* at = encode_int32 buf stride1 ~at in
let* at = encode_int32 buf offset1 ~at in
let* at = encode_int32 buf stride2 ~at in
let* at = encode_int32 buf offset2 ~at in
let* at = encode_int32 buf stride3 ~at in
let* at = encode_int32 buf offset3 ~at in
let* at = encode_uint8 buf depth ~at in
let* at = encode_uint8 buf bpp ~at in
let at = at + 2 in
let* at = encode_int64 buf modifier ~at in
let* at = encode_list encode_file_descr buf buffers ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type buffers_from_pixmap_reply = { width : int; height : int; modifier : int64; depth : int; bpp : int; strides : int list; offsets : int list; buffers : Unix.file_descr list; } [@@deriving sexp];;
let encode_buffers_from_pixmap ~(pixmap : Xproto.pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xproto.encode_pixmap buf pixmap ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_buffers_from_pixmap_reply length buf ~at : (buffers_from_pixmap_reply * int) option = let orig = at in let at = at + 1 in
let* nfd, at = decode_uint8 buf ~at in let nfd = nfd in
let at = at + 6 in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let at = at + 4 in
let* modifier, at = decode_int64 buf ~at in
let* depth, at = decode_uint8 buf ~at in
let* bpp, at = decode_uint8 buf ~at in
let at = at + 6 in
let* strides, at = decode_list (decode_int32) nfd buf ~at in
let* offsets, at = decode_list (decode_int32) nfd buf ~at in
let* buffers, at = decode_list (decode_file_descr) nfd buf ~at in
ignore orig;
Some ({ width; height; modifier; depth; bpp; strides; offsets; buffers }, at);;
end
module[@warning "-27"] Ge = struct
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint16 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
let at = at + 20 in
ignore orig;
Some ({ major_version; minor_version }, at);;
end
module[@warning "-27"] Glx = struct
type pixmap = xid [@@deriving sexp];;
let decode_pixmap = decode_xid;;
let encode_pixmap = encode_xid;;

type context = xid [@@deriving sexp];;
let decode_context = decode_xid;;
let encode_context = encode_xid;;

type pbuffer = xid [@@deriving sexp];;
let decode_pbuffer = decode_xid;;
let encode_pbuffer = encode_xid;;

type window = xid [@@deriving sexp];;
let decode_window = decode_xid;;
let encode_window = encode_xid;;

type fbconfig = xid [@@deriving sexp];;
let decode_fbconfig = decode_xid;;
let encode_fbconfig = encode_xid;;

type drawable = xid [@@deriving sexp];;
let decode_drawable = decode_xid;;
let encode_drawable = encode_xid;;

type float32 = float [@@deriving sexp];;
let decode_float32 = decode_float;;
let encode_float32 = encode_float;;

type float64 = float [@@deriving sexp];;
let decode_float64 = decode_float;;
let encode_float64 = encode_float;;

type bool32 = int [@@deriving sexp];;
let decode_bool32 = decode_int32;;
let encode_bool32 = encode_int32;;

type context_tag = int [@@deriving sexp];;
let decode_context_tag = decode_int32;;
let encode_context_tag = encode_int32;;

type generic_error = { bad_value : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type bad_context_error = generic_error [@@deriving sexp];;
type bad_context_state_error = generic_error [@@deriving sexp];;
type bad_drawable_error = generic_error [@@deriving sexp];;
type bad_pixmap_error = generic_error [@@deriving sexp];;
type bad_context_tag_error = generic_error [@@deriving sexp];;
type bad_current_window_error = generic_error [@@deriving sexp];;
type bad_render_request_error = generic_error [@@deriving sexp];;
type bad_large_request_error = generic_error [@@deriving sexp];;
type unsupported_private_request_error = generic_error [@@deriving sexp];;
type bad_fb_config_error = generic_error [@@deriving sexp];;
type bad_pbuffer_error = generic_error [@@deriving sexp];;
type bad_current_drawable_error = generic_error [@@deriving sexp];;
type bad_window_error = generic_error [@@deriving sexp];;
type glx_bad_profile_arb_error = generic_error [@@deriving sexp];;
type pbuffer_clobber_event = { event_type : int; draw_type : int; drawable : drawable; b_mask : int; aux_buffer : int; x : int; y : int; width : int; height : int; count : int; } [@@deriving sexp];;
type buffer_swap_complete_event = { event_type : int; drawable : drawable; ust_hi : int; ust_lo : int; msc_hi : int; msc_lo : int; sbc : int; } [@@deriving sexp];;
type pbcet_enum = [ `Damaged | `Saved ] [@@deriving sexp];;
let pbcet_enum_of_int : int -> [> pbcet_enum ] option = function 32791 -> Some `Damaged | 32792 -> Some `Saved | n -> Printf.printf "unknown pbcet_enum: %d\n" n; None;;
let pbcet_int_of_enum : pbcet_enum -> int = function `Damaged -> 32791 | `Saved -> 32792;;
type pbcdt_enum = [ `Window | `Pbuffer ] [@@deriving sexp];;
let pbcdt_enum_of_int : int -> [> pbcdt_enum ] option = function 32793 -> Some `Window | 32794 -> Some `Pbuffer | n -> Printf.printf "unknown pbcdt_enum: %d\n" n; None;;
let pbcdt_int_of_enum : pbcdt_enum -> int = function `Window -> 32793 | `Pbuffer -> 32794;;
let encode_render ~(context_tag : context_tag) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_render_large ~(context_tag : context_tag) ~(request_num : int) ~(request_total : int) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf request_num ~at in
let* at = encode_uint16 buf request_total ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Byte *) List.length data)) ~at in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_context ~(context : context) ~(visual : Xproto.visualid) ~(screen : int) ~(share_list : context) ~(is_direct : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_visualid buf visual ~at in
let* at = encode_int32 buf screen ~at in
let* at = encode_context buf share_list ~at in
let* at = encode_bool buf is_direct ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_context ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type make_current_reply = { context_tag : context_tag; } [@@deriving sexp];;
let encode_make_current ~(drawable : drawable) ~(context : context) ~(old_context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_context buf context ~at in
let* at = encode_context_tag buf old_context_tag ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_make_current_reply length buf ~at : (make_current_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_tag, at = decode_context_tag buf ~at in
let at = at + 20 in
ignore orig;
Some ({ context_tag }, at);;
type is_direct_reply = { is_direct : bool; } [@@deriving sexp];;
let encode_is_direct ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_is_direct_reply length buf ~at : (is_direct_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* is_direct, at = decode_bool buf ~at in
let at = at + 23 in
ignore orig;
Some ({ is_direct }, at);;
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ major_version; minor_version }, at);;
let encode_wait_gl ~(context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_wait_x ~(context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_copy_context ~(src : context) ~(dest : context) ~(mask : int) ~(src_context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_context buf src ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_context buf dest ~at in
let* at = encode_int32 buf mask ~at in
let* at = encode_context_tag buf src_context_tag ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type gc_mask = ([ `Gl_current_bit | `Gl_point_bit | `Gl_line_bit | `Gl_polygon_bit | `Gl_polygon_stipple_bit | `Gl_pixel_mode_bit | `Gl_lighting_bit | `Gl_fog_bit | `Gl_depth_buffer_bit | `Gl_accum_buffer_bit | `Gl_stencil_buffer_bit | `Gl_viewport_bit | `Gl_transform_bit | `Gl_enable_bit | `Gl_color_buffer_bit | `Gl_hint_bit | `Gl_eval_bit | `Gl_list_bit | `Gl_texture_bit | `Gl_scissor_bit ] list, [ `Gl_all_attrib_bits ]) mask [@@deriving sexp];;let gc_mask_of_int64 mask : gc_mask option = let of_enum = function 16777215L -> Some `Gl_all_attrib_bits | _ -> None in let of_mask = function 0 -> Some `Gl_current_bit | 1 -> Some `Gl_point_bit | 2 -> Some `Gl_line_bit | 3 -> Some `Gl_polygon_bit | 4 -> Some `Gl_polygon_stipple_bit | 5 -> Some `Gl_pixel_mode_bit | 6 -> Some `Gl_lighting_bit | 7 -> Some `Gl_fog_bit | 8 -> Some `Gl_depth_buffer_bit | 9 -> Some `Gl_accum_buffer_bit | 10 -> Some `Gl_stencil_buffer_bit | 11 -> Some `Gl_viewport_bit | 12 -> Some `Gl_transform_bit | 13 -> Some `Gl_enable_bit | 14 -> Some `Gl_color_buffer_bit | 15 -> Some `Gl_hint_bit | 16 -> Some `Gl_eval_bit | 17 -> Some `Gl_list_bit | 18 -> Some `Gl_texture_bit | 19 -> Some `Gl_scissor_bit | _ -> None in mask_value_of_int of_mask of_enum mask;;
let gc_int_of_mask (mask : gc_mask) : int = let to_enum = function `Gl_all_attrib_bits -> 16777215 in let to_mask = function `Gl_current_bit -> 0 | `Gl_point_bit -> 1 | `Gl_line_bit -> 2 | `Gl_polygon_bit -> 3 | `Gl_polygon_stipple_bit -> 4 | `Gl_pixel_mode_bit -> 5 | `Gl_lighting_bit -> 6 | `Gl_fog_bit -> 7 | `Gl_depth_buffer_bit -> 8 | `Gl_accum_buffer_bit -> 9 | `Gl_stencil_buffer_bit -> 10 | `Gl_viewport_bit -> 11 | `Gl_transform_bit -> 12 | `Gl_enable_bit -> 13 | `Gl_color_buffer_bit -> 14 | `Gl_hint_bit -> 15 | `Gl_eval_bit -> 16 | `Gl_list_bit -> 17 | `Gl_texture_bit -> 18 | `Gl_scissor_bit -> 19 in mask_value_to_int to_mask to_enum mask;;
let encode_swap_buffers ~(context_tag : context_tag) ~(drawable : drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_use_x_font ~(context_tag : context_tag) ~(font : Xproto.font) ~(first : int) ~(count : int) ~(list_base : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_font buf font ~at in
let* at = encode_int32 buf first ~at in
let* at = encode_int32 buf count ~at in
let* at = encode_int32 buf list_base ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_glx_pixmap ~(screen : int) ~(visual : Xproto.visualid) ~(pixmap : Xproto.pixmap) ~(glx_pixmap : pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_visualid buf visual ~at in
let* at = Xproto.encode_pixmap buf pixmap ~at in
let* at = encode_pixmap buf glx_pixmap ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_visual_configs_reply = { num_visuals : int; num_properties : int; property_list : int list; } [@@deriving sexp];;
let encode_get_visual_configs ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_visual_configs_reply length buf ~at : (get_visual_configs_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_visuals, at = decode_int32 buf ~at in
let* num_properties, at = decode_int32 buf ~at in
let at = at + 16 in
let* property_list, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ num_visuals; num_properties; property_list }, at);;
let encode_destroy_glx_pixmap ~(glx_pixmap : pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_pixmap buf glx_pixmap ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_vendor_private ~(vendor_code : int) ~(context_tag : context_tag) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_int32 buf vendor_code ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_context_tag buf context_tag ~at in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type vendor_private_with_reply = { retval : int; data1 : char list; data2 : char list; } [@@deriving sexp];;
let encode_vendor_private_with_reply ~(vendor_code : int) ~(context_tag : context_tag) ~(data : char list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_int32 buf vendor_code ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_context_tag buf context_tag ~at in
let* at = encode_list encode_char buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_vendor_private_with_reply_reply length buf ~at : (vendor_private_with_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* retval, at = decode_int32 buf ~at in
let* data1, at = let length = 24 in decode_list (decode_char) length buf ~at in
let* data2, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ retval; data1; data2 }, at);;
type query_extensions_string_reply = { n : int; } [@@deriving sexp];;
let encode_query_extensions_string ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_extensions_string_reply length buf ~at : (query_extensions_string_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ n }, at);;
type query_server_string_reply = { string : string; } [@@deriving sexp];;
let encode_query_server_string ~(screen : int) ~(name : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_server_string_reply length buf ~at : (query_server_string_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* str_len, at = decode_int32 buf ~at in let str_len = str_len in
let at = at + 16 in
let* string, at = decode_string str_len buf ~at in
ignore orig;
Some ({ string }, at);;
let encode_client_info ~(major_version : int) ~(minor_version : int) ~(string : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
let* at = encode_int32 buf (identity (String.length string)) ~at in
let* at = encode_string buf string ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_fb_configs_reply = { num_f_b_configs : int; num_properties : int; property_list : int list; } [@@deriving sexp];;
let encode_get_fb_configs ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_fb_configs_reply length buf ~at : (get_fb_configs_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_f_b_configs, at = decode_int32 buf ~at in
let* num_properties, at = decode_int32 buf ~at in
let at = at + 16 in
let* property_list, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ num_f_b_configs; num_properties; property_list }, at);;
let encode_create_pixmap ~(screen : int) ~(fbconfig : fbconfig) ~(pixmap : Xproto.pixmap) ~(glx_pixmap : pixmap) ~(attribs : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fbconfig buf fbconfig ~at in
let* at = Xproto.encode_pixmap buf pixmap ~at in
let* at = encode_pixmap buf glx_pixmap ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs)) ~at in
let* at = encode_list encode_int32 buf attribs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_pixmap ~(glx_pixmap : pixmap)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let* at = encode_pixmap buf glx_pixmap ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_new_context ~(context : context) ~(fbconfig : fbconfig) ~(screen : int) ~(render_type : int) ~(share_list : context) ~(is_direct : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fbconfig buf fbconfig ~at in
let* at = encode_int32 buf screen ~at in
let* at = encode_int32 buf render_type ~at in
let* at = encode_context buf share_list ~at in
let* at = encode_bool buf is_direct ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_context_reply = { attribs : int list; } [@@deriving sexp];;
let encode_query_context ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_context_reply length buf ~at : (query_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_attribs, at = decode_int32 buf ~at in let num_attribs = (num_attribs) / (2) in
let at = at + 20 in
let* attribs, at = decode_list (decode_int32) num_attribs buf ~at in
ignore orig;
Some ({ attribs }, at);;
type make_context_current_reply = { context_tag : context_tag; } [@@deriving sexp];;
let encode_make_context_current ~(old_context_tag : context_tag) ~(drawable : drawable) ~(read_drawable : drawable) ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = encode_context_tag buf old_context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_drawable buf drawable ~at in
let* at = encode_drawable buf read_drawable ~at in
let* at = encode_context buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_make_context_current_reply length buf ~at : (make_context_current_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_tag, at = decode_context_tag buf ~at in
let at = at + 20 in
ignore orig;
Some ({ context_tag }, at);;
let encode_create_pbuffer ~(screen : int) ~(fbconfig : fbconfig) ~(pbuffer : pbuffer) ~(attribs : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fbconfig buf fbconfig ~at in
let* at = encode_pbuffer buf pbuffer ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs)) ~at in
let* at = encode_list encode_int32 buf attribs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_pbuffer ~(pbuffer : pbuffer)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_pbuffer buf pbuffer ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_drawable_attributes_reply = { attribs : int list; } [@@deriving sexp];;
let encode_get_drawable_attributes ~(drawable : drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_drawable_attributes_reply length buf ~at : (get_drawable_attributes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_attribs, at = decode_int32 buf ~at in let num_attribs = (num_attribs) / (2) in
let at = at + 20 in
let* attribs, at = decode_list (decode_int32) num_attribs buf ~at in
ignore orig;
Some ({ attribs }, at);;
let encode_change_drawable_attributes ~(drawable : drawable) ~(attribs : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let* at = encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs)) ~at in
let* at = encode_list encode_int32 buf attribs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_window ~(screen : int) ~(fbconfig : fbconfig) ~(window : Xproto.window) ~(glx_window : window) ~(attribs : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fbconfig buf fbconfig ~at in
let* at = Xproto.encode_window buf window ~at in
let* at = encode_window buf glx_window ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs)) ~at in
let* at = encode_list encode_int32 buf attribs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_window ~(glxwindow : window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let* at = encode_window buf glxwindow ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_client_info_arb ~(major_version : int) ~(minor_version : int) ~(gl_versions : int list) ~(gl_extension_string : string) ~(glx_extension_string : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 33 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length gl_versions)) ~at in
let* at = encode_int32 buf (identity (String.length gl_extension_string)) ~at in
let* at = encode_int32 buf (identity (String.length glx_extension_string)) ~at in
let* at = encode_list encode_int32 buf gl_versions ~at in
let* at = encode_string buf gl_extension_string ~at in
let* at = encode_string buf glx_extension_string ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_context_attribs_arb ~(context : context) ~(fbconfig : fbconfig) ~(screen : int) ~(share_list : context) ~(is_direct : bool) ~(attribs : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 34 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fbconfig buf fbconfig ~at in
let* at = encode_int32 buf screen ~at in
let* at = encode_context buf share_list ~at in
let* at = encode_bool buf is_direct ~at in
let at = at + 3 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs)) ~at in
let* at = encode_list encode_int32 buf attribs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_client_info2_arb ~(major_version : int) ~(minor_version : int) ~(gl_versions : int list) ~(gl_extension_string : string) ~(glx_extension_string : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 35 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length gl_versions)) ~at in
let* at = encode_int32 buf (identity (String.length gl_extension_string)) ~at in
let* at = encode_int32 buf (identity (String.length glx_extension_string)) ~at in
let* at = encode_list encode_int32 buf gl_versions ~at in
let* at = encode_string buf gl_extension_string ~at in
let* at = encode_string buf glx_extension_string ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_new_list ~(context_tag : context_tag) ~(list : int) ~(mode : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 101 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf list ~at in
let* at = encode_int32 buf mode ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_end_list ~(context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 102 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_lists ~(context_tag : context_tag) ~(list : int) ~(range : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 103 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf list ~at in
let* at = encode_int32 buf range ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type gen_lists_reply = { ret_val : int; } [@@deriving sexp];;
let encode_gen_lists ~(context_tag : context_tag) ~(range : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 104 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf range ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_gen_lists_reply length buf ~at : (gen_lists_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_int32 buf ~at in
ignore orig;
Some ({ ret_val }, at);;
let encode_feedback_buffer ~(context_tag : context_tag) ~(size : int) ~(type_ : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 105 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf size ~at in
let* at = encode_int32 buf type_ ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_select_buffer ~(context_tag : context_tag) ~(size : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 106 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf size ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type render_mode_reply = { ret_val : int; new_mode : int; data : int list; } [@@deriving sexp];;
let encode_render_mode ~(context_tag : context_tag) ~(mode : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 107 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf mode ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_render_mode_reply length buf ~at : (render_mode_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_int32 buf ~at in
let* n, at = decode_int32 buf ~at in let n = n in
let* new_mode, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ ret_val; new_mode; data }, at);;
type rm_enum = [ `Gl_render | `Gl_feedback | `Gl_select ] [@@deriving sexp];;
let rm_enum_of_int : int -> [> rm_enum ] option = function 7168 -> Some `Gl_render | 7169 -> Some `Gl_feedback | 7170 -> Some `Gl_select | n -> Printf.printf "unknown rm_enum: %d\n" n; None;;
let rm_int_of_enum : rm_enum -> int = function `Gl_render -> 7168 | `Gl_feedback -> 7169 | `Gl_select -> 7170;;
type finish_reply = unit [@@deriving sexp];;
let encode_finish ~(context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 108 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_finish_reply length buf ~at : (finish_reply * int) option = ignore length; ignore buf; Some ((), at);;
let encode_pixel_storef ~(context_tag : context_tag) ~(pname : int) ~(datum : float32)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 109 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf pname ~at in
let* at = encode_float32 buf datum ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_pixel_storei ~(context_tag : context_tag) ~(pname : int) ~(datum : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 110 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf pname ~at in
let* at = encode_int32 buf datum ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type read_pixels_reply = { data : char list; } [@@deriving sexp];;
let encode_read_pixels ~(context_tag : context_tag) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool) ~(lsb_first : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 111 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf x ~at in
let* at = encode_int32 buf y ~at in
let* at = encode_int32 buf width ~at in
let* at = encode_int32 buf height ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
let* at = encode_bool buf lsb_first ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_read_pixels_reply length buf ~at : (read_pixels_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ data }, at);;
type get_booleanv_reply = { datum : bool; data : bool list; } [@@deriving sexp];;
let encode_get_booleanv ~(context_tag : context_tag) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 112 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_booleanv_reply length buf ~at : (get_booleanv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_bool buf ~at in
let at = at + 15 in
let* data, at = decode_list (decode_bool) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_clip_plane_reply = { data : float64 list; } [@@deriving sexp];;
let encode_get_clip_plane ~(context_tag : context_tag) ~(plane : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 113 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf plane ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_clip_plane_reply length buf ~at : (get_clip_plane_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* data, at = let length = (length) / (2) in decode_list (decode_float64) length buf ~at in
ignore orig;
Some ({ data }, at);;
type get_doublev_reply = { datum : float64; data : float64 list; } [@@deriving sexp];;
let encode_get_doublev ~(context_tag : context_tag) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 114 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_doublev_reply length buf ~at : (get_doublev_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float64 buf ~at in
let at = at + 8 in
let* data, at = decode_list (decode_float64) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_error_reply = { error : int; } [@@deriving sexp];;
let encode_get_error ~(context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 115 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_error_reply length buf ~at : (get_error_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* error, at = decode_int32 buf ~at in
ignore orig;
Some ({ error }, at);;
type get_floatv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_floatv ~(context_tag : context_tag) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 116 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_floatv_reply length buf ~at : (get_floatv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_integerv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_integerv ~(context_tag : context_tag) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 117 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_integerv_reply length buf ~at : (get_integerv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_lightfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_lightfv ~(context_tag : context_tag) ~(light : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 118 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf light ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_lightfv_reply length buf ~at : (get_lightfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_lightiv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_lightiv ~(context_tag : context_tag) ~(light : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 119 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf light ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_lightiv_reply length buf ~at : (get_lightiv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_mapdv_reply = { datum : float64; data : float64 list; } [@@deriving sexp];;
let encode_get_mapdv ~(context_tag : context_tag) ~(target : int) ~(query : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 120 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf query ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_mapdv_reply length buf ~at : (get_mapdv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float64 buf ~at in
let at = at + 8 in
let* data, at = decode_list (decode_float64) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_mapfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_mapfv ~(context_tag : context_tag) ~(target : int) ~(query : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 121 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf query ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_mapfv_reply length buf ~at : (get_mapfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_mapiv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_mapiv ~(context_tag : context_tag) ~(target : int) ~(query : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 122 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf query ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_mapiv_reply length buf ~at : (get_mapiv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_materialfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_materialfv ~(context_tag : context_tag) ~(face : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 123 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf face ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_materialfv_reply length buf ~at : (get_materialfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_materialiv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_materialiv ~(context_tag : context_tag) ~(face : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 124 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf face ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_materialiv_reply length buf ~at : (get_materialiv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_pixel_mapfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_pixel_mapfv ~(context_tag : context_tag) ~(map : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 125 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf map ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_pixel_mapfv_reply length buf ~at : (get_pixel_mapfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_pixel_mapuiv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_pixel_mapuiv ~(context_tag : context_tag) ~(map : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 126 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf map ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_pixel_mapuiv_reply length buf ~at : (get_pixel_mapuiv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_pixel_mapusv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_pixel_mapusv ~(context_tag : context_tag) ~(map : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 127 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf map ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_pixel_mapusv_reply length buf ~at : (get_pixel_mapusv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_uint16 buf ~at in
let at = at + 16 in
let* data, at = decode_list (decode_uint16) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_polygon_stipple_reply = { data : char list; } [@@deriving sexp];;
let encode_get_polygon_stipple ~(context_tag : context_tag) ~(lsb_first : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 128 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_bool buf lsb_first ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_polygon_stipple_reply length buf ~at : (get_polygon_stipple_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ data }, at);;
type get_string_reply = { string : string; } [@@deriving sexp];;
let encode_get_string ~(context_tag : context_tag) ~(name : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 129 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_string_reply length buf ~at : (get_string_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let at = at + 16 in
let* string, at = decode_string n buf ~at in
ignore orig;
Some ({ string }, at);;
type get_tex_envfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_tex_envfv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 130 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_envfv_reply length buf ~at : (get_tex_envfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_enviv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_tex_enviv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 131 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_enviv_reply length buf ~at : (get_tex_enviv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_gendv_reply = { datum : float64; data : float64 list; } [@@deriving sexp];;
let encode_get_tex_gendv ~(context_tag : context_tag) ~(coord : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 132 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf coord ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_gendv_reply length buf ~at : (get_tex_gendv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float64 buf ~at in
let at = at + 8 in
let* data, at = decode_list (decode_float64) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_genfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_tex_genfv ~(context_tag : context_tag) ~(coord : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 133 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf coord ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_genfv_reply length buf ~at : (get_tex_genfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_geniv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_tex_geniv ~(context_tag : context_tag) ~(coord : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 134 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf coord ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_geniv_reply length buf ~at : (get_tex_geniv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_image_reply = { width : int; height : int; depth : int; data : char list; } [@@deriving sexp];;
let encode_get_tex_image ~(context_tag : context_tag) ~(target : int) ~(level : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 135 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf level ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_image_reply length buf ~at : (get_tex_image_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 8 in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let* depth, at = decode_int32 buf ~at in
let at = at + 4 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ width; height; depth; data }, at);;
type get_tex_parameterfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_tex_parameterfv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 136 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_parameterfv_reply length buf ~at : (get_tex_parameterfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_parameteriv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_tex_parameteriv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 137 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_parameteriv_reply length buf ~at : (get_tex_parameteriv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_level_parameterfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_tex_level_parameterfv ~(context_tag : context_tag) ~(target : int) ~(level : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 138 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf level ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_level_parameterfv_reply length buf ~at : (get_tex_level_parameterfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_tex_level_parameteriv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_tex_level_parameteriv ~(context_tag : context_tag) ~(target : int) ~(level : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 139 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf level ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_tex_level_parameteriv_reply length buf ~at : (get_tex_level_parameteriv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type is_enabled_reply = { ret_val : bool32; } [@@deriving sexp];;
let encode_is_enabled ~(context_tag : context_tag) ~(capability : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 140 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf capability ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_is_enabled_reply length buf ~at : (is_enabled_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_bool32 buf ~at in
ignore orig;
Some ({ ret_val }, at);;
type is_list_reply = { ret_val : bool32; } [@@deriving sexp];;
let encode_is_list ~(context_tag : context_tag) ~(list : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 141 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf list ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_is_list_reply length buf ~at : (is_list_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_bool32 buf ~at in
ignore orig;
Some ({ ret_val }, at);;
let encode_flush ~(context_tag : context_tag)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 142 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type are_textures_resident_reply = { ret_val : bool32; data : bool list; } [@@deriving sexp];;
let encode_are_textures_resident ~(context_tag : context_tag) ~(textures : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 143 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length textures)) ~at in
let* at = encode_list encode_int32 buf textures ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_are_textures_resident_reply length buf ~at : (are_textures_resident_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_bool32 buf ~at in
let at = at + 20 in
let* data, at = let length = (length) * (4) in decode_list (decode_bool) length buf ~at in
ignore orig;
Some ({ ret_val; data }, at);;
let encode_delete_textures ~(context_tag : context_tag) ~(textures : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 144 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length textures)) ~at in
let* at = encode_list encode_int32 buf textures ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type gen_textures_reply = { data : int list; } [@@deriving sexp];;
let encode_gen_textures ~(context_tag : context_tag) ~(n : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 145 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf n ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_gen_textures_reply length buf ~at : (gen_textures_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* data, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ data }, at);;
type is_texture_reply = { ret_val : bool32; } [@@deriving sexp];;
let encode_is_texture ~(context_tag : context_tag) ~(texture : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 146 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf texture ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_is_texture_reply length buf ~at : (is_texture_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_bool32 buf ~at in
ignore orig;
Some ({ ret_val }, at);;
type get_color_table_reply = { width : int; data : char list; } [@@deriving sexp];;
let encode_get_color_table ~(context_tag : context_tag) ~(target : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 147 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_color_table_reply length buf ~at : (get_color_table_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 8 in
let* width, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ width; data }, at);;
type get_color_table_parameterfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_color_table_parameterfv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 148 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_color_table_parameterfv_reply length buf ~at : (get_color_table_parameterfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_color_table_parameteriv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_color_table_parameteriv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 149 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_color_table_parameteriv_reply length buf ~at : (get_color_table_parameteriv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_convolution_filter_reply = { width : int; height : int; data : char list; } [@@deriving sexp];;
let encode_get_convolution_filter ~(context_tag : context_tag) ~(target : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 150 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_convolution_filter_reply length buf ~at : (get_convolution_filter_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 8 in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let at = at + 8 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ width; height; data }, at);;
type get_convolution_parameterfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_convolution_parameterfv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 151 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_convolution_parameterfv_reply length buf ~at : (get_convolution_parameterfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_convolution_parameteriv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_convolution_parameteriv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 152 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_convolution_parameteriv_reply length buf ~at : (get_convolution_parameteriv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_separable_filter_reply = { row_w : int; col_h : int; rows_and_cols : char list; } [@@deriving sexp];;
let encode_get_separable_filter ~(context_tag : context_tag) ~(target : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 153 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_separable_filter_reply length buf ~at : (get_separable_filter_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 8 in
let* row_w, at = decode_int32 buf ~at in
let* col_h, at = decode_int32 buf ~at in
let at = at + 8 in
let* rows_and_cols, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ row_w; col_h; rows_and_cols }, at);;
type get_histogram_reply = { width : int; data : char list; } [@@deriving sexp];;
let encode_get_histogram ~(context_tag : context_tag) ~(target : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool) ~(reset : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 154 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
let* at = encode_bool buf reset ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_histogram_reply length buf ~at : (get_histogram_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 8 in
let* width, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ width; data }, at);;
type get_histogram_parameterfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_histogram_parameterfv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 155 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_histogram_parameterfv_reply length buf ~at : (get_histogram_parameterfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_histogram_parameteriv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_histogram_parameteriv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 156 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_histogram_parameteriv_reply length buf ~at : (get_histogram_parameteriv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_minmax_reply = { data : char list; } [@@deriving sexp];;
let encode_get_minmax ~(context_tag : context_tag) ~(target : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool) ~(reset : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 157 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf format ~at in
let* at = encode_int32 buf type_ ~at in
let* at = encode_bool buf swap_bytes ~at in
let* at = encode_bool buf reset ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_minmax_reply length buf ~at : (get_minmax_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ data }, at);;
type get_minmax_parameterfv_reply = { datum : float32; data : float32 list; } [@@deriving sexp];;
let encode_get_minmax_parameterfv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 158 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_minmax_parameterfv_reply length buf ~at : (get_minmax_parameterfv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_float32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_float32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_minmax_parameteriv_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_minmax_parameteriv ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 159 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_minmax_parameteriv_reply length buf ~at : (get_minmax_parameteriv_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_compressed_tex_image_arb_reply = { size : int; data : char list; } [@@deriving sexp];;
let encode_get_compressed_tex_image_arb ~(context_tag : context_tag) ~(target : int) ~(level : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 160 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf level ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_compressed_tex_image_arb_reply length buf ~at : (get_compressed_tex_image_arb_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 8 in
let* size, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ size; data }, at);;
let encode_delete_queries_arb ~(context_tag : context_tag) ~(ids : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 161 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length ids)) ~at in
let* at = encode_list encode_int32 buf ids ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type gen_queries_arb_reply = { data : int list; } [@@deriving sexp];;
let encode_gen_queries_arb ~(context_tag : context_tag) ~(n : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 162 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf n ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_gen_queries_arb_reply length buf ~at : (gen_queries_arb_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* data, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ data }, at);;
type is_query_arb_reply = { ret_val : bool32; } [@@deriving sexp];;
let encode_is_query_arb ~(context_tag : context_tag) ~(id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 163 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf id ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_is_query_arb_reply length buf ~at : (is_query_arb_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ret_val, at = decode_bool32 buf ~at in
ignore orig;
Some ({ ret_val }, at);;
type get_queryiv_arb_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_queryiv_arb ~(context_tag : context_tag) ~(target : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 164 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf target ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_queryiv_arb_reply length buf ~at : (get_queryiv_arb_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_query_objectiv_arb_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_query_objectiv_arb ~(context_tag : context_tag) ~(id : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 165 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf id ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_query_objectiv_arb_reply length buf ~at : (get_query_objectiv_arb_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
type get_query_objectuiv_arb_reply = { datum : int; data : int list; } [@@deriving sexp];;
let encode_get_query_objectuiv_arb ~(context_tag : context_tag) ~(id : int) ~(pname : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 166 ~at in
let* at = encode_context_tag buf context_tag ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf id ~at in
let* at = encode_int32 buf pname ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_query_objectuiv_arb_reply length buf ~at : (get_query_objectuiv_arb_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 4 in
let* n, at = decode_int32 buf ~at in let n = n in
let* datum, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = decode_list (decode_int32) n buf ~at in
ignore orig;
Some ({ datum; data }, at);;
end
module[@warning "-27"] Randr = struct
type mode = xid [@@deriving sexp];;
let decode_mode = decode_xid;;
let encode_mode = encode_xid;;

type crtc = xid [@@deriving sexp];;
let decode_crtc = decode_xid;;
let encode_crtc = encode_xid;;

type output = xid [@@deriving sexp];;
let decode_output = decode_xid;;
let encode_output = encode_xid;;

type provider = xid [@@deriving sexp];;
let decode_provider = decode_xid;;
let encode_provider = encode_xid;;

type lease = xid [@@deriving sexp];;
let decode_lease = decode_xid;;
let encode_lease = encode_xid;;

type bad_output_error = unit [@@deriving sexp];;
type bad_crtc_error = unit [@@deriving sexp];;
type bad_mode_error = unit [@@deriving sexp];;
type bad_provider_error = unit [@@deriving sexp];;
type rotation_mask = [ `Rotate_0 | `Rotate_90 | `Rotate_180 | `Rotate_270 | `Reflect_x | `Reflect_y ] list [@@deriving sexp];;
let rotation_mask_of_int64 mask : rotation_mask option = let of_int = function 0 -> Some `Rotate_0 | 1 -> Some `Rotate_90 | 2 -> Some `Rotate_180 | 3 -> Some `Rotate_270 | 4 -> Some `Reflect_x | 5 -> Some `Reflect_y | _ -> None in mask_of_int of_int mask;;
let rotation_int_of_mask : rotation_mask -> int = let to_bit = function `Rotate_0 -> 0 | `Rotate_90 -> 1 | `Rotate_180 -> 2 | `Rotate_270 -> 3 | `Reflect_x -> 4 | `Reflect_y -> 5 in int_of_mask to_bit;;
type screen_size = { width : int; height : int; mwidth : int; mheight : int; } [@@deriving sexp];;
let decode_screen_size buf ~at : (screen_size * int) option = let orig = at in let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* mwidth, at = decode_uint16 buf ~at in
let* mheight, at = decode_uint16 buf ~at in
ignore orig;
Some ({ width; height; mwidth; mheight }, at);;
let encode_screen_size buf (v : screen_size) ~at : int option = let orig = at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_uint16 buf v.mwidth ~at in let* at = encode_uint16 buf v.mheight ~at in ignore orig; Some at;;

type refresh_rates = { rates : int list; } [@@deriving sexp];;
let decode_refresh_rates buf ~at : (refresh_rates * int) option = let orig = at in let* n_rates, at = decode_uint16 buf ~at in let n_rates = n_rates in
let* rates, at = decode_list (decode_uint16) n_rates buf ~at in
ignore orig;
Some ({ rates }, at);;
let encode_refresh_rates buf (v : refresh_rates) ~at : int option = let orig = at in let* at = encode_uint16 buf (identity ((* Parsetree.Card16 *) List.length v.rates)) ~at in let* at = encode_list encode_uint16 buf v.rates ~at in ignore orig; Some at;;

type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ major_version; minor_version }, at);;
type set_config_enum = [ `Success | `Invalid_config_time | `Invalid_time | `Failed ] [@@deriving sexp];;
let set_config_enum_of_int : int -> [> set_config_enum ] option = function 0 -> Some `Success | 1 -> Some `Invalid_config_time | 2 -> Some `Invalid_time | 3 -> Some `Failed | n -> Printf.printf "unknown set_config_enum: %d\n" n; None;;
let set_config_int_of_enum : set_config_enum -> int = function `Success -> 0 | `Invalid_config_time -> 1 | `Invalid_time -> 2 | `Failed -> 3;;
type set_screen_config_reply = { status : set_config_enum; new_timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; root : Xproto.window; subpixel_order : Render.sub_pixel_enum; } [@@deriving sexp];;
let encode_set_screen_config ~(window : Xproto.window) ~(timestamp : Xproto.timestamp) ~(config_timestamp : Xproto.timestamp) ~(size_id : int) ~(rotation : rotation_mask) ~(rate : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_timestamp buf timestamp ~at in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
let* at = encode_uint16 buf size_id ~at in
let* at = encode_mask encode_uint16 identity rotation_int_of_mask buf rotation ~at in
let* at = encode_uint16 buf rate ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_screen_config_reply length buf ~at : (set_screen_config_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_uint8 identity set_config_enum_of_int buf ~at in
let at = at + 6 in
let* new_timestamp, at = Xproto.decode_timestamp buf ~at in
let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
let* root, at = Xproto.decode_window buf ~at in
let* subpixel_order, at = decode_enum decode_uint16 identity Render.sub_pixel_enum_of_int buf ~at in
let at = at + 10 in
ignore orig;
Some ({ status; new_timestamp; config_timestamp; root; subpixel_order }, at);;
type notify_mask = [ `Screen_change | `Crtc_change | `Output_change | `Output_property | `Provider_change | `Provider_property | `Resource_change | `Lease ] list [@@deriving sexp];;
let notify_mask_mask_of_int64 mask : notify_mask option = let of_int = function 0 -> Some `Screen_change | 1 -> Some `Crtc_change | 2 -> Some `Output_change | 3 -> Some `Output_property | 4 -> Some `Provider_change | 5 -> Some `Provider_property | 6 -> Some `Resource_change | 7 -> Some `Lease | _ -> None in mask_of_int of_int mask;;
let notify_mask_int_of_mask : notify_mask -> int = let to_bit = function `Screen_change -> 0 | `Crtc_change -> 1 | `Output_change -> 2 | `Output_property -> 3 | `Provider_change -> 4 | `Provider_property -> 5 | `Resource_change -> 6 | `Lease -> 7 in int_of_mask to_bit;;
let encode_select_input ~(window : Xproto.window) ~(enable : notify_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mask encode_uint16 identity notify_mask_int_of_mask buf enable ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_screen_info_reply = { rotations : rotation_mask; root : Xproto.window; timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; size_id : int; rotation : rotation_mask; rate : int; n_info : int; sizes : screen_size list; rates : refresh_rates list; } [@@deriving sexp];;
let encode_get_screen_info ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_info_reply length buf ~at : (get_screen_info_reply * int) option = let orig = at in let at = at + 1 in
let* rotations, at = decode_mask decode_uint8 Int64.of_int rotation_mask_of_int64 buf ~at in
let at = at + 6 in
let* root, at = Xproto.decode_window buf ~at in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
let* n_sizes, at = decode_uint16 buf ~at in let n_sizes = n_sizes in
let* size_id, at = decode_uint16 buf ~at in
let* rotation, at = decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at in
let* rate, at = decode_uint16 buf ~at in
let* n_info, at = decode_uint16 buf ~at in
let at = at + 2 in
let* sizes, at = decode_list (decode_screen_size) n_sizes buf ~at in
let* rates, at = let length = (n_info) - (n_sizes) in decode_list (decode_refresh_rates) length buf ~at in
ignore orig;
Some ({ rotations; root; timestamp; config_timestamp; size_id; rotation; rate; n_info; sizes; rates }, at);;
type get_screen_size_range_reply = { min_width : int; min_height : int; max_width : int; max_height : int; } [@@deriving sexp];;
let encode_get_screen_size_range ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_size_range_reply length buf ~at : (get_screen_size_range_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* min_width, at = decode_uint16 buf ~at in
let* min_height, at = decode_uint16 buf ~at in
let* max_width, at = decode_uint16 buf ~at in
let* max_height, at = decode_uint16 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ min_width; min_height; max_width; max_height }, at);;
let encode_set_screen_size ~(window : Xproto.window) ~(width : int) ~(height : int) ~(mm_width : int) ~(mm_height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf mm_width ~at in
let* at = encode_int32 buf mm_height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type mode_flag_mask = [ `Hsync_positive | `Hsync_negative | `Vsync_positive | `Vsync_negative | `Interlace | `Double_scan | `Csync | `Csync_positive | `Csync_negative | `Hskew_present | `Bcast | `Pixel_multiplex | `Double_clock | `Halve_clock ] list [@@deriving sexp];;
let mode_flag_mask_of_int64 mask : mode_flag_mask option = let of_int = function 0 -> Some `Hsync_positive | 1 -> Some `Hsync_negative | 2 -> Some `Vsync_positive | 3 -> Some `Vsync_negative | 4 -> Some `Interlace | 5 -> Some `Double_scan | 6 -> Some `Csync | 7 -> Some `Csync_positive | 8 -> Some `Csync_negative | 9 -> Some `Hskew_present | 10 -> Some `Bcast | 11 -> Some `Pixel_multiplex | 12 -> Some `Double_clock | 13 -> Some `Halve_clock | _ -> None in mask_of_int of_int mask;;
let mode_flag_int_of_mask : mode_flag_mask -> int = let to_bit = function `Hsync_positive -> 0 | `Hsync_negative -> 1 | `Vsync_positive -> 2 | `Vsync_negative -> 3 | `Interlace -> 4 | `Double_scan -> 5 | `Csync -> 6 | `Csync_positive -> 7 | `Csync_negative -> 8 | `Hskew_present -> 9 | `Bcast -> 10 | `Pixel_multiplex -> 11 | `Double_clock -> 12 | `Halve_clock -> 13 in int_of_mask to_bit;;
type mode_info = { id : int; width : int; height : int; dot_clock : int; hsync_start : int; hsync_end : int; htotal : int; hskew : int; vsync_start : int; vsync_end : int; vtotal : int; name_len : int; mode_flags : mode_flag_mask; } [@@deriving sexp];;
let decode_mode_info buf ~at : (mode_info * int) option = let orig = at in let* id, at = decode_int32 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* dot_clock, at = decode_int32 buf ~at in
let* hsync_start, at = decode_uint16 buf ~at in
let* hsync_end, at = decode_uint16 buf ~at in
let* htotal, at = decode_uint16 buf ~at in
let* hskew, at = decode_uint16 buf ~at in
let* vsync_start, at = decode_uint16 buf ~at in
let* vsync_end, at = decode_uint16 buf ~at in
let* vtotal, at = decode_uint16 buf ~at in
let* name_len, at = decode_uint16 buf ~at in
let* mode_flags, at = decode_mask decode_int32 Int64.of_int mode_flag_mask_of_int64 buf ~at in
ignore orig;
Some ({ id; width; height; dot_clock; hsync_start; hsync_end; htotal; hskew; vsync_start; vsync_end; vtotal; name_len; mode_flags }, at);;
let encode_mode_info buf (v : mode_info) ~at : int option = let orig = at in let* at = encode_int32 buf v.id ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_int32 buf v.dot_clock ~at in let* at = encode_uint16 buf v.hsync_start ~at in let* at = encode_uint16 buf v.hsync_end ~at in let* at = encode_uint16 buf v.htotal ~at in let* at = encode_uint16 buf v.hskew ~at in let* at = encode_uint16 buf v.vsync_start ~at in let* at = encode_uint16 buf v.vsync_end ~at in let* at = encode_uint16 buf v.vtotal ~at in let* at = encode_uint16 buf v.name_len ~at in let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf v.mode_flags ~at in ignore orig; Some at;;

type get_screen_resources_reply = { timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; crtcs : crtc list; outputs : output list; modes : mode_info list; names : char list; } [@@deriving sexp];;
let encode_get_screen_resources ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_resources_reply length buf ~at : (get_screen_resources_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
let* num_crtcs, at = decode_uint16 buf ~at in let num_crtcs = num_crtcs in
let* num_outputs, at = decode_uint16 buf ~at in let num_outputs = num_outputs in
let* num_modes, at = decode_uint16 buf ~at in let num_modes = num_modes in
let* names_len, at = decode_uint16 buf ~at in let names_len = names_len in
let at = at + 8 in
let* crtcs, at = decode_list (decode_crtc) num_crtcs buf ~at in
let* outputs, at = decode_list (decode_output) num_outputs buf ~at in
let* modes, at = decode_list (decode_mode_info) num_modes buf ~at in
let* names, at = decode_list (decode_char) names_len buf ~at in
ignore orig;
Some ({ timestamp; config_timestamp; crtcs; outputs; modes; names }, at);;
type connection_enum = [ `Connected | `Disconnected | `Unknown ] [@@deriving sexp];;
let connection_enum_of_int : int -> [> connection_enum ] option = function 0 -> Some `Connected | 1 -> Some `Disconnected | 2 -> Some `Unknown | n -> Printf.printf "unknown connection_enum: %d\n" n; None;;
let connection_int_of_enum : connection_enum -> int = function `Connected -> 0 | `Disconnected -> 1 | `Unknown -> 2;;
type get_output_info_reply = { status : set_config_enum; timestamp : Xproto.timestamp; crtc : crtc; mm_width : int; mm_height : int; connection : connection_enum; subpixel_order : Render.sub_pixel_enum; num_preferred : int; crtcs : crtc list; modes : mode list; clones : output list; name : char list; } [@@deriving sexp];;
let encode_get_output_info ~(output : output) ~(config_timestamp : Xproto.timestamp)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_output_info_reply length buf ~at : (get_output_info_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_uint8 identity set_config_enum_of_int buf ~at in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* crtc, at = decode_crtc buf ~at in
let* mm_width, at = decode_int32 buf ~at in
let* mm_height, at = decode_int32 buf ~at in
let* connection, at = decode_enum decode_uint8 identity connection_enum_of_int buf ~at in
let* subpixel_order, at = decode_enum decode_uint8 identity Render.sub_pixel_enum_of_int buf ~at in
let* num_crtcs, at = decode_uint16 buf ~at in let num_crtcs = num_crtcs in
let* num_modes, at = decode_uint16 buf ~at in let num_modes = num_modes in
let* num_preferred, at = decode_uint16 buf ~at in
let* num_clones, at = decode_uint16 buf ~at in let num_clones = num_clones in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let* crtcs, at = decode_list (decode_crtc) num_crtcs buf ~at in
let* modes, at = decode_list (decode_mode) num_modes buf ~at in
let* clones, at = decode_list (decode_output) num_clones buf ~at in
let* name, at = decode_list (decode_char) name_len buf ~at in
ignore orig;
Some ({ status; timestamp; crtc; mm_width; mm_height; connection; subpixel_order; num_preferred; crtcs; modes; clones; name }, at);;
type list_output_properties_reply = { atoms : Xproto.atom list; } [@@deriving sexp];;
let encode_list_output_properties ~(output : output)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_output_properties_reply length buf ~at : (list_output_properties_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_atoms, at = decode_uint16 buf ~at in let num_atoms = num_atoms in
let at = at + 22 in
let* atoms, at = decode_list (Xproto.decode_atom) num_atoms buf ~at in
ignore orig;
Some ({ atoms }, at);;
type query_output_property_reply = { pending : bool; range : bool; immutable : bool; valid_values : int list; } [@@deriving sexp];;
let encode_query_output_property ~(output : output) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_output_property_reply length buf ~at : (query_output_property_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pending, at = decode_bool buf ~at in
let* range, at = decode_bool buf ~at in
let* immutable, at = decode_bool buf ~at in
let at = at + 21 in
let* valid_values, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ pending; range; immutable; valid_values }, at);;
let encode_configure_output_property ~(output : output) ~(property : Xproto.atom) ~(pending : bool) ~(range : bool) ~(values : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
let* at = encode_bool buf pending ~at in
let* at = encode_bool buf range ~at in
let at = at + 2 in
let* at = encode_list encode_int32 buf values ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_output_property ~(output : output) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(format : int) ~(mode : Xproto.prop_mode_enum) ~(num_units : int) ~(data : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_uint8 buf format ~at in
let* at = encode_enum encode_uint8 identity Xproto.prop_mode_int_of_enum buf mode ~at in
let at = at + 2 in
let* at = encode_int32 buf num_units ~at in
let* at = encode_string buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_output_property ~(output : output) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_output_property_reply = { format : int; type_ : Xproto.atom_enum alt_enum; bytes_after : int; num_items : int; data : char list; } [@@deriving sexp];;
let encode_get_output_property ~(output : output) ~(property : Xproto.atom) ~(type_ : Xproto.get_property_type_enum alt_enum) ~(long_offset : int) ~(long_length : int) ~(delete : bool) ~(pending : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
let* at = encode_alt_enum Xproto.encode_atom identity Xproto.get_property_type_int_of_enum buf type_ ~at in
let* at = encode_int32 buf long_offset ~at in
let* at = encode_int32 buf long_length ~at in
let* at = encode_bool buf delete ~at in
let* at = encode_bool buf pending ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_output_property_reply length buf ~at : (get_output_property_reply * int) option = let orig = at in let at = at + 1 in
let* format, at = decode_uint8 buf ~at in
let at = at + 6 in
let* type_, at = decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf ~at in
let* bytes_after, at = decode_int32 buf ~at in
let* num_items, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = let length = (num_items) * ((format) / (8)) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ format; type_; bytes_after; num_items; data }, at);;
type create_mode_reply = { mode : mode; } [@@deriving sexp];;
let encode_create_mode ~(window : Xproto.window) ~(mode_info : mode_info) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mode_info buf mode_info ~at in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_mode_reply length buf ~at : (create_mode_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* mode, at = decode_mode buf ~at in
let at = at + 20 in
ignore orig;
Some ({ mode }, at);;
let encode_destroy_mode ~(mode : mode)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_mode buf mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_add_output_mode ~(output : output) ~(mode : mode)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mode buf mode ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_output_mode ~(output : output) ~(mode : mode)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_output buf output ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mode buf mode ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_crtc_info_reply = { status : set_config_enum; timestamp : Xproto.timestamp; x : int; y : int; width : int; height : int; mode : mode; rotation : rotation_mask; rotations : rotation_mask; outputs : output list; possible : output list; } [@@deriving sexp];;
let encode_get_crtc_info ~(crtc : crtc) ~(config_timestamp : Xproto.timestamp)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_crtc_info_reply length buf ~at : (get_crtc_info_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_uint8 identity set_config_enum_of_int buf ~at in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* mode, at = decode_mode buf ~at in
let* rotation, at = decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at in
let* rotations, at = decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at in
let* num_outputs, at = decode_uint16 buf ~at in let num_outputs = num_outputs in
let* num_possible_outputs, at = decode_uint16 buf ~at in let num_possible_outputs = num_possible_outputs in
let* outputs, at = decode_list (decode_output) num_outputs buf ~at in
let* possible, at = decode_list (decode_output) num_possible_outputs buf ~at in
ignore orig;
Some ({ status; timestamp; x; y; width; height; mode; rotation; rotations; outputs; possible }, at);;
type set_crtc_config_reply = { status : set_config_enum; timestamp : Xproto.timestamp; } [@@deriving sexp];;
let encode_set_crtc_config ~(crtc : crtc) ~(timestamp : Xproto.timestamp) ~(config_timestamp : Xproto.timestamp) ~(x : int) ~(y : int) ~(mode : mode) ~(rotation : rotation_mask) ~(outputs : output list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_timestamp buf timestamp ~at in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_mode buf mode ~at in
let* at = encode_mask encode_uint16 identity rotation_int_of_mask buf rotation ~at in
let at = at + 2 in
let* at = encode_list encode_output buf outputs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_crtc_config_reply length buf ~at : (set_crtc_config_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_uint8 identity set_config_enum_of_int buf ~at in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let at = at + 20 in
ignore orig;
Some ({ status; timestamp }, at);;
type get_crtc_gamma_size_reply = { size : int; } [@@deriving sexp];;
let encode_get_crtc_gamma_size ~(crtc : crtc)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_crtc_gamma_size_reply length buf ~at : (get_crtc_gamma_size_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* size, at = decode_uint16 buf ~at in
let at = at + 22 in
ignore orig;
Some ({ size }, at);;
type get_crtc_gamma_reply = { red : int list; green : int list; blue : int list; } [@@deriving sexp];;
let encode_get_crtc_gamma ~(crtc : crtc)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_crtc_gamma_reply length buf ~at : (get_crtc_gamma_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* size, at = decode_uint16 buf ~at in let size = size in
let at = at + 22 in
let* red, at = decode_list (decode_uint16) size buf ~at in
let* green, at = decode_list (decode_uint16) size buf ~at in
let* blue, at = decode_list (decode_uint16) size buf ~at in
ignore orig;
Some ({ red; green; blue }, at);;
let encode_set_crtc_gamma ~(crtc : crtc) ~(red : int list) ~(green : int list) ~(blue : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* Parsetree.Card16 *) List.length red)) ~at in
let at = at + 2 in
let* at = encode_list encode_uint16 buf red ~at in
let* at = encode_list encode_uint16 buf green ~at in
let* at = encode_list encode_uint16 buf blue ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_screen_resources_current_reply = { timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; crtcs : crtc list; outputs : output list; modes : mode_info list; names : char list; } [@@deriving sexp];;
let encode_get_screen_resources_current ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_resources_current_reply length buf ~at : (get_screen_resources_current_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
let* num_crtcs, at = decode_uint16 buf ~at in let num_crtcs = num_crtcs in
let* num_outputs, at = decode_uint16 buf ~at in let num_outputs = num_outputs in
let* num_modes, at = decode_uint16 buf ~at in let num_modes = num_modes in
let* names_len, at = decode_uint16 buf ~at in let names_len = names_len in
let at = at + 8 in
let* crtcs, at = decode_list (decode_crtc) num_crtcs buf ~at in
let* outputs, at = decode_list (decode_output) num_outputs buf ~at in
let* modes, at = decode_list (decode_mode_info) num_modes buf ~at in
let* names, at = decode_list (decode_char) names_len buf ~at in
ignore orig;
Some ({ timestamp; config_timestamp; crtcs; outputs; modes; names }, at);;
type transform_mask = [ `Unit | `Scale_up | `Scale_down | `Projective ] list [@@deriving sexp];;
let transform_mask_of_int64 mask : transform_mask option = let of_int = function 0 -> Some `Unit | 1 -> Some `Scale_up | 2 -> Some `Scale_down | 3 -> Some `Projective | _ -> None in mask_of_int of_int mask;;
let transform_int_of_mask : transform_mask -> int = let to_bit = function `Unit -> 0 | `Scale_up -> 1 | `Scale_down -> 2 | `Projective -> 3 in int_of_mask to_bit;;
let encode_set_crtc_transform ~(crtc : crtc) ~(transform : Render.transform) ~(filter_name : string) ~(filter_params : Render.fixed list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Render.encode_transform buf transform ~at in
let* at = encode_uint16 buf (identity (String.length filter_name)) ~at in
let at = at + 2 in
let* at = encode_string buf filter_name ~at in
let at = at + ((at - orig) mod 4) in
let* at = encode_list Render.encode_fixed buf filter_params ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_crtc_transform_reply = { pending_transform : Render.transform; has_transforms : bool; current_transform : Render.transform; pending_filter_name : string; pending_params : Render.fixed list; current_filter_name : string; current_params : Render.fixed list; } [@@deriving sexp];;
let encode_get_crtc_transform ~(crtc : crtc)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_crtc_transform_reply length buf ~at : (get_crtc_transform_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pending_transform, at = Render.decode_transform buf ~at in
let* has_transforms, at = decode_bool buf ~at in
let at = at + 3 in
let* current_transform, at = Render.decode_transform buf ~at in
let at = at + 4 in
let* pending_len, at = decode_uint16 buf ~at in let pending_len = pending_len in
let* pending_nparams, at = decode_uint16 buf ~at in let pending_nparams = pending_nparams in
let* current_len, at = decode_uint16 buf ~at in let current_len = current_len in
let* current_nparams, at = decode_uint16 buf ~at in let current_nparams = current_nparams in
let* pending_filter_name, at = decode_string pending_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* pending_params, at = decode_list (Render.decode_fixed) pending_nparams buf ~at in
let* current_filter_name, at = decode_string current_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* current_params, at = decode_list (Render.decode_fixed) current_nparams buf ~at in
ignore orig;
Some ({ pending_transform; has_transforms; current_transform; pending_filter_name; pending_params; current_filter_name; current_params }, at);;
type get_panning_reply = { status : set_config_enum; timestamp : Xproto.timestamp; left : int; top : int; width : int; height : int; track_left : int; track_top : int; track_width : int; track_height : int; border_left : int; border_top : int; border_right : int; border_bottom : int; } [@@deriving sexp];;
let encode_get_panning ~(crtc : crtc)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_panning_reply length buf ~at : (get_panning_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_uint8 identity set_config_enum_of_int buf ~at in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* left, at = decode_uint16 buf ~at in
let* top, at = decode_uint16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* track_left, at = decode_uint16 buf ~at in
let* track_top, at = decode_uint16 buf ~at in
let* track_width, at = decode_uint16 buf ~at in
let* track_height, at = decode_uint16 buf ~at in
let* border_left, at = decode_int16 buf ~at in
let* border_top, at = decode_int16 buf ~at in
let* border_right, at = decode_int16 buf ~at in
let* border_bottom, at = decode_int16 buf ~at in
ignore orig;
Some ({ status; timestamp; left; top; width; height; track_left; track_top; track_width; track_height; border_left; border_top; border_right; border_bottom }, at);;
type set_panning_reply = { status : set_config_enum; timestamp : Xproto.timestamp; } [@@deriving sexp];;
let encode_set_panning ~(crtc : crtc) ~(timestamp : Xproto.timestamp) ~(left : int) ~(top : int) ~(width : int) ~(height : int) ~(track_left : int) ~(track_top : int) ~(track_width : int) ~(track_height : int) ~(border_left : int) ~(border_top : int) ~(border_right : int) ~(border_bottom : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = encode_crtc buf crtc ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_timestamp buf timestamp ~at in
let* at = encode_uint16 buf left ~at in
let* at = encode_uint16 buf top ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint16 buf track_left ~at in
let* at = encode_uint16 buf track_top ~at in
let* at = encode_uint16 buf track_width ~at in
let* at = encode_uint16 buf track_height ~at in
let* at = encode_int16 buf border_left ~at in
let* at = encode_int16 buf border_top ~at in
let* at = encode_int16 buf border_right ~at in
let* at = encode_int16 buf border_bottom ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_panning_reply length buf ~at : (set_panning_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_enum decode_uint8 identity set_config_enum_of_int buf ~at in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
ignore orig;
Some ({ status; timestamp }, at);;
let encode_set_output_primary ~(window : Xproto.window) ~(output : output)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_output buf output ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_output_primary_reply = { output : output; } [@@deriving sexp];;
let encode_get_output_primary ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_output_primary_reply length buf ~at : (get_output_primary_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* output, at = decode_output buf ~at in
ignore orig;
Some ({ output }, at);;
type get_providers_reply = { timestamp : Xproto.timestamp; providers : provider list; } [@@deriving sexp];;
let encode_get_providers ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_providers_reply length buf ~at : (get_providers_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* num_providers, at = decode_uint16 buf ~at in let num_providers = num_providers in
let at = at + 18 in
let* providers, at = decode_list (decode_provider) num_providers buf ~at in
ignore orig;
Some ({ timestamp; providers }, at);;
type provider_capability_mask = [ `Source_output | `Sink_output | `Source_offload | `Sink_offload ] list [@@deriving sexp];;
let provider_capability_mask_of_int64 mask : provider_capability_mask option = let of_int = function 0 -> Some `Source_output | 1 -> Some `Sink_output | 2 -> Some `Source_offload | 3 -> Some `Sink_offload | _ -> None in mask_of_int of_int mask;;
let provider_capability_int_of_mask : provider_capability_mask -> int = let to_bit = function `Source_output -> 0 | `Sink_output -> 1 | `Source_offload -> 2 | `Sink_offload -> 3 in int_of_mask to_bit;;
type get_provider_info_reply = { status : int; timestamp : Xproto.timestamp; capabilities : provider_capability_mask; crtcs : crtc list; outputs : output list; associated_providers : provider list; associated_capability : int list; name : string; } [@@deriving sexp];;
let encode_get_provider_info ~(provider : provider) ~(config_timestamp : Xproto.timestamp)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 33 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_provider_info_reply length buf ~at : (get_provider_info_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_uint8 buf ~at in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* capabilities, at = decode_mask decode_int32 Int64.of_int provider_capability_mask_of_int64 buf ~at in
let* num_crtcs, at = decode_uint16 buf ~at in let num_crtcs = num_crtcs in
let* num_outputs, at = decode_uint16 buf ~at in let num_outputs = num_outputs in
let* num_associated_providers, at = decode_uint16 buf ~at in let num_associated_providers = num_associated_providers in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let at = at + 8 in
let* crtcs, at = decode_list (decode_crtc) num_crtcs buf ~at in
let* outputs, at = decode_list (decode_output) num_outputs buf ~at in
let* associated_providers, at = decode_list (decode_provider) num_associated_providers buf ~at in
let* associated_capability, at = decode_list (decode_int32) num_associated_providers buf ~at in
let* name, at = decode_string name_len buf ~at in
ignore orig;
Some ({ status; timestamp; capabilities; crtcs; outputs; associated_providers; associated_capability; name }, at);;
let encode_set_provider_offload_sink ~(provider : provider) ~(sink_provider : provider) ~(config_timestamp : Xproto.timestamp)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 34 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_provider buf sink_provider ~at in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_provider_output_source ~(provider : provider) ~(source_provider : provider) ~(config_timestamp : Xproto.timestamp)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 35 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_provider buf source_provider ~at in
let* at = Xproto.encode_timestamp buf config_timestamp ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type list_provider_properties_reply = { atoms : Xproto.atom list; } [@@deriving sexp];;
let encode_list_provider_properties ~(provider : provider)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 36 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_provider_properties_reply length buf ~at : (list_provider_properties_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_atoms, at = decode_uint16 buf ~at in let num_atoms = num_atoms in
let at = at + 22 in
let* atoms, at = decode_list (Xproto.decode_atom) num_atoms buf ~at in
ignore orig;
Some ({ atoms }, at);;
type query_provider_property_reply = { pending : bool; range : bool; immutable : bool; valid_values : int list; } [@@deriving sexp];;
let encode_query_provider_property ~(provider : provider) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 37 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_provider_property_reply length buf ~at : (query_provider_property_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* pending, at = decode_bool buf ~at in
let* range, at = decode_bool buf ~at in
let* immutable, at = decode_bool buf ~at in
let at = at + 21 in
let* valid_values, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ pending; range; immutable; valid_values }, at);;
let encode_configure_provider_property ~(provider : provider) ~(property : Xproto.atom) ~(pending : bool) ~(range : bool) ~(values : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 38 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
let* at = encode_bool buf pending ~at in
let* at = encode_bool buf range ~at in
let at = at + 2 in
let* at = encode_list encode_int32 buf values ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_provider_property ~(provider : provider) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(format : int) ~(mode : int) ~(num_items : int) ~(data : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 39 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_uint8 buf format ~at in
let* at = encode_uint8 buf mode ~at in
let at = at + 2 in
let* at = encode_int32 buf num_items ~at in
let* at = encode_string buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_provider_property ~(provider : provider) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 40 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_provider_property_reply = { format : int; type_ : Xproto.atom; bytes_after : int; num_items : int; data : string; } [@@deriving sexp];;
let encode_get_provider_property ~(provider : provider) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(long_offset : int) ~(long_length : int) ~(delete : bool) ~(pending : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 41 ~at in
let* at = encode_provider buf provider ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_int32 buf long_offset ~at in
let* at = encode_int32 buf long_length ~at in
let* at = encode_bool buf delete ~at in
let* at = encode_bool buf pending ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_provider_property_reply length buf ~at : (get_provider_property_reply * int) option = let orig = at in let at = at + 1 in
let* format, at = decode_uint8 buf ~at in
let at = at + 6 in
let* type_, at = Xproto.decode_atom buf ~at in
let* bytes_after, at = decode_int32 buf ~at in
let* num_items, at = decode_int32 buf ~at in
let at = at + 12 in
let* data, at = let length = (num_items) * ((format) / (8)) in decode_string length buf ~at in
ignore orig;
Some ({ format; type_; bytes_after; num_items; data }, at);;
type screen_change_notify_event = { rotation : rotation_mask; timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; root : Xproto.window; request_window : Xproto.window; size_id : int; subpixel_order : Render.sub_pixel_enum; width : int; height : int; mwidth : int; mheight : int; } [@@deriving sexp];;
type notify_enum = [ `Crtc_change | `Output_change | `Output_property | `Provider_change | `Provider_property | `Resource_change | `Lease ] [@@deriving sexp];;
let notify_enum_of_int : int -> [> notify_enum ] option = function 0 -> Some `Crtc_change | 1 -> Some `Output_change | 2 -> Some `Output_property | 3 -> Some `Provider_change | 4 -> Some `Provider_property | 5 -> Some `Resource_change | 6 -> Some `Lease | n -> Printf.printf "unknown notify_enum: %d\n" n; None;;
let notify_int_of_enum : notify_enum -> int = function `Crtc_change -> 0 | `Output_change -> 1 | `Output_property -> 2 | `Provider_change -> 3 | `Provider_property -> 4 | `Resource_change -> 5 | `Lease -> 6;;
type crtc_change = { timestamp : Xproto.timestamp; window : Xproto.window; crtc : crtc; mode : mode; rotation : rotation_mask; x : int; y : int; width : int; height : int; } [@@deriving sexp];;
let decode_crtc_change buf ~at : (crtc_change * int) option = let orig = at in let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* window, at = Xproto.decode_window buf ~at in
let* crtc, at = decode_crtc buf ~at in
let* mode, at = decode_mode buf ~at in
let* rotation, at = decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at in
let at = at + 2 in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ timestamp; window; crtc; mode; rotation; x; y; width; height }, at);;
let encode_crtc_change buf (v : crtc_change) ~at : int option = let orig = at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_crtc buf v.crtc ~at in let* at = encode_mode buf v.mode ~at in let* at = encode_mask encode_uint16 identity rotation_int_of_mask buf v.rotation ~at in let at = at + 2 in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in ignore orig; Some at;;

type output_change = { timestamp : Xproto.timestamp; config_timestamp : Xproto.timestamp; window : Xproto.window; output : output; crtc : crtc; mode : mode; rotation : rotation_mask; connection : connection_enum; subpixel_order : Render.sub_pixel_enum; } [@@deriving sexp];;
let decode_output_change buf ~at : (output_change * int) option = let orig = at in let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
let* window, at = Xproto.decode_window buf ~at in
let* output, at = decode_output buf ~at in
let* crtc, at = decode_crtc buf ~at in
let* mode, at = decode_mode buf ~at in
let* rotation, at = decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at in
let* connection, at = decode_enum decode_uint8 identity connection_enum_of_int buf ~at in
let* subpixel_order, at = decode_enum decode_uint8 identity Render.sub_pixel_enum_of_int buf ~at in
ignore orig;
Some ({ timestamp; config_timestamp; window; output; crtc; mode; rotation; connection; subpixel_order }, at);;
let encode_output_change buf (v : output_change) ~at : int option = let orig = at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = Xproto.encode_timestamp buf v.config_timestamp ~at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_output buf v.output ~at in let* at = encode_crtc buf v.crtc ~at in let* at = encode_mode buf v.mode ~at in let* at = encode_mask encode_uint16 identity rotation_int_of_mask buf v.rotation ~at in let* at = encode_enum encode_uint8 identity connection_int_of_enum buf v.connection ~at in let* at = encode_enum encode_uint8 identity Render.sub_pixel_int_of_enum buf v.subpixel_order ~at in ignore orig; Some at;;

type output_property = { window : Xproto.window; output : output; atom : Xproto.atom; timestamp : Xproto.timestamp; status : Xproto.property_enum; } [@@deriving sexp];;
let decode_output_property buf ~at : (output_property * int) option = let orig = at in let* window, at = Xproto.decode_window buf ~at in
let* output, at = decode_output buf ~at in
let* atom, at = Xproto.decode_atom buf ~at in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* status, at = decode_enum decode_uint8 identity Xproto.property_enum_of_int buf ~at in
let at = at + 11 in
ignore orig;
Some ({ window; output; atom; timestamp; status }, at);;
let encode_output_property buf (v : output_property) ~at : int option = let orig = at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_output buf v.output ~at in let* at = Xproto.encode_atom buf v.atom ~at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = encode_enum encode_uint8 identity Xproto.property_int_of_enum buf v.status ~at in let at = at + 11 in ignore orig; Some at;;

type provider_change = { timestamp : Xproto.timestamp; window : Xproto.window; provider : provider; } [@@deriving sexp];;
let decode_provider_change buf ~at : (provider_change * int) option = let orig = at in let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* window, at = Xproto.decode_window buf ~at in
let* provider, at = decode_provider buf ~at in
let at = at + 16 in
ignore orig;
Some ({ timestamp; window; provider }, at);;
let encode_provider_change buf (v : provider_change) ~at : int option = let orig = at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_provider buf v.provider ~at in let at = at + 16 in ignore orig; Some at;;

type provider_property = { window : Xproto.window; provider : provider; atom : Xproto.atom; timestamp : Xproto.timestamp; state : int; } [@@deriving sexp];;
let decode_provider_property buf ~at : (provider_property * int) option = let orig = at in let* window, at = Xproto.decode_window buf ~at in
let* provider, at = decode_provider buf ~at in
let* atom, at = Xproto.decode_atom buf ~at in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* state, at = decode_uint8 buf ~at in
let at = at + 11 in
ignore orig;
Some ({ window; provider; atom; timestamp; state }, at);;
let encode_provider_property buf (v : provider_property) ~at : int option = let orig = at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_provider buf v.provider ~at in let* at = Xproto.encode_atom buf v.atom ~at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = encode_uint8 buf v.state ~at in let at = at + 11 in ignore orig; Some at;;

type resource_change = { timestamp : Xproto.timestamp; window : Xproto.window; } [@@deriving sexp];;
let decode_resource_change buf ~at : (resource_change * int) option = let orig = at in let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* window, at = Xproto.decode_window buf ~at in
let at = at + 20 in
ignore orig;
Some ({ timestamp; window }, at);;
let encode_resource_change buf (v : resource_change) ~at : int option = let orig = at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = Xproto.encode_window buf v.window ~at in let at = at + 20 in ignore orig; Some at;;

type monitor_info = { name : Xproto.atom; primary : bool; automatic : bool; x : int; y : int; width : int; height : int; width_in_millimeters : int; height_in_millimeters : int; outputs : output list; } [@@deriving sexp];;
let decode_monitor_info buf ~at : (monitor_info * int) option = let orig = at in let* name, at = Xproto.decode_atom buf ~at in
let* primary, at = decode_bool buf ~at in
let* automatic, at = decode_bool buf ~at in
let* n_output, at = decode_uint16 buf ~at in let n_output = n_output in
let* x, at = decode_int16 buf ~at in
let* y, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* width_in_millimeters, at = decode_int32 buf ~at in
let* height_in_millimeters, at = decode_int32 buf ~at in
let* outputs, at = decode_list (decode_output) n_output buf ~at in
ignore orig;
Some ({ name; primary; automatic; x; y; width; height; width_in_millimeters; height_in_millimeters; outputs }, at);;
let encode_monitor_info buf (v : monitor_info) ~at : int option = let orig = at in let* at = Xproto.encode_atom buf v.name ~at in let* at = encode_bool buf v.primary ~at in let* at = encode_bool buf v.automatic ~at in let* at = encode_uint16 buf (identity ((* Parsetree.Xid *) List.length v.outputs)) ~at in let* at = encode_int16 buf v.x ~at in let* at = encode_int16 buf v.y ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_int32 buf v.width_in_millimeters ~at in let* at = encode_int32 buf v.height_in_millimeters ~at in let* at = encode_list encode_output buf v.outputs ~at in ignore orig; Some at;;

type get_monitors_reply = { timestamp : Xproto.timestamp; n_outputs : int; monitors : monitor_info list; } [@@deriving sexp];;
let encode_get_monitors ~(window : Xproto.window) ~(get_active : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 42 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_bool buf get_active ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_monitors_reply length buf ~at : (get_monitors_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* n_monitors, at = decode_int32 buf ~at in let n_monitors = n_monitors in
let* n_outputs, at = decode_int32 buf ~at in
let at = at + 12 in
let* monitors, at = decode_list (decode_monitor_info) n_monitors buf ~at in
ignore orig;
Some ({ timestamp; n_outputs; monitors }, at);;
let encode_set_monitor ~(window : Xproto.window) ~(monitorinfo : monitor_info)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 43 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_monitor_info buf monitorinfo ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_monitor ~(window : Xproto.window) ~(name : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 44 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type create_lease_reply = { nfd : int; master_fd : Unix.file_descr; } [@@deriving sexp];;
let encode_create_lease ~(window : Xproto.window) ~(lid : lease) ~(crtcs : crtc list) ~(outputs : output list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 45 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_lease buf lid ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Xid *) List.length crtcs)) ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Xid *) List.length outputs)) ~at in
let* at = encode_list encode_crtc buf crtcs ~at in
let* at = encode_list encode_output buf outputs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_lease_reply length buf ~at : (create_lease_reply * int) option = let orig = at in let at = at + 1 in
let* nfd, at = decode_uint8 buf ~at in
let at = at + 6 in
let* master_fd, at = decode_file_descr buf ~at in
let at = at + 24 in
ignore orig;
Some ({ nfd; master_fd }, at);;
let encode_free_lease ~(lid : lease) ~(terminate : char)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 46 ~at in
let* at = encode_lease buf lid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_char buf terminate ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type lease_notify = { timestamp : Xproto.timestamp; window : Xproto.window; lease : lease; created : int; } [@@deriving sexp];;
let decode_lease_notify buf ~at : (lease_notify * int) option = let orig = at in let* timestamp, at = Xproto.decode_timestamp buf ~at in
let* window, at = Xproto.decode_window buf ~at in
let* lease, at = decode_lease buf ~at in
let* created, at = decode_uint8 buf ~at in
let at = at + 15 in
ignore orig;
Some ({ timestamp; window; lease; created }, at);;
let encode_lease_notify buf (v : lease_notify) ~at : int option = let orig = at in let* at = Xproto.encode_timestamp buf v.timestamp ~at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_lease buf v.lease ~at in let* at = encode_uint8 buf v.created ~at in let at = at + 15 in ignore orig; Some at;;

type notify_variant = Crtc_change of { cc : crtc_change; } | Output_change of { oc : output_change; } | Output_property of { op : output_property; } | Provider_change of { pc : provider_change; } | Provider_property of { pp : provider_property; } | Resource_change of { rc : resource_change; } | Lease of { lc : lease_notify; } [@@deriving sexp];;
type notify_event = { u : notify_variant; } [@@deriving sexp];;
end
module[@warning "-27"] Sync = struct
type alarm = xid [@@deriving sexp];;
let decode_alarm = decode_xid;;
let encode_alarm = encode_xid;;

type alarmstate_enum = [ `Active | `Inactive | `Destroyed ] [@@deriving sexp];;
let alarmstate_enum_of_int : int -> [> alarmstate_enum ] option = function 0 -> Some `Active | 1 -> Some `Inactive | 2 -> Some `Destroyed | n -> Printf.printf "unknown alarmstate_enum: %d\n" n; None;;
let alarmstate_int_of_enum : alarmstate_enum -> int = function `Active -> 0 | `Inactive -> 1 | `Destroyed -> 2;;
type counter = xid [@@deriving sexp];;
let decode_counter = decode_xid;;
let encode_counter = encode_xid;;

type fence = xid [@@deriving sexp];;
let decode_fence = decode_xid;;
let encode_fence = encode_xid;;

type testtype_enum = [ `Positive_transition | `Negative_transition | `Positive_comparison | `Negative_comparison ] [@@deriving sexp];;
let testtype_enum_of_int : int -> [> testtype_enum ] option = function 0 -> Some `Positive_transition | 1 -> Some `Negative_transition | 2 -> Some `Positive_comparison | 3 -> Some `Negative_comparison | n -> Printf.printf "unknown testtype_enum: %d\n" n; None;;
let testtype_int_of_enum : testtype_enum -> int = function `Positive_transition -> 0 | `Negative_transition -> 1 | `Positive_comparison -> 2 | `Negative_comparison -> 3;;
type valuetype_enum = [ `Absolute | `Relative ] [@@deriving sexp];;
let valuetype_enum_of_int : int -> [> valuetype_enum ] option = function 0 -> Some `Absolute | 1 -> Some `Relative | n -> Printf.printf "unknown valuetype_enum: %d\n" n; None;;
let valuetype_int_of_enum : valuetype_enum -> int = function `Absolute -> 0 | `Relative -> 1;;
type ca_mask = [ `Counter | `Value_type | `Value | `Test_type | `Delta | `Events ] list [@@deriving sexp];;
let ca_mask_of_int64 mask : ca_mask option = let of_int = function 0 -> Some `Counter | 1 -> Some `Value_type | 2 -> Some `Value | 3 -> Some `Test_type | 4 -> Some `Delta | 5 -> Some `Events | _ -> None in mask_of_int of_int mask;;
let ca_int_of_mask : ca_mask -> int = let to_bit = function `Counter -> 0 | `Value_type -> 1 | `Value -> 2 | `Test_type -> 3 | `Delta -> 4 | `Events -> 5 in int_of_mask to_bit;;
type int64 = { hi : int; lo : int; } [@@deriving sexp];;
let decode_int64 buf ~at : (int64 * int) option = let orig = at in let* hi, at = decode_int32 buf ~at in
let* lo, at = decode_int32 buf ~at in
ignore orig;
Some ({ hi; lo }, at);;
let encode_int64 buf (v : int64) ~at : int option = let orig = at in let* at = encode_int32 buf v.hi ~at in let* at = encode_int32 buf v.lo ~at in ignore orig; Some at;;

type systemcounter = { counter : counter; resolution : int64; name : string; } [@@deriving sexp];;
let decode_systemcounter buf ~at : (systemcounter * int) option = let orig = at in let* counter, at = decode_counter buf ~at in
let* resolution, at = decode_int64 buf ~at in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let* name, at = decode_string name_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ counter; resolution; name }, at);;
let encode_systemcounter buf (v : systemcounter) ~at : int option = let orig = at in let* at = encode_counter buf v.counter ~at in let* at = encode_int64 buf v.resolution ~at in let* at = encode_uint16 buf (identity (String.length v.name)) ~at in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type trigger = { counter : counter; wait_type : valuetype_enum; wait_value : int64; test_type : testtype_enum; } [@@deriving sexp];;
let decode_trigger buf ~at : (trigger * int) option = let orig = at in let* counter, at = decode_counter buf ~at in
let* wait_type, at = decode_enum decode_int32 identity valuetype_enum_of_int buf ~at in
let* wait_value, at = decode_int64 buf ~at in
let* test_type, at = decode_enum decode_int32 identity testtype_enum_of_int buf ~at in
ignore orig;
Some ({ counter; wait_type; wait_value; test_type }, at);;
let encode_trigger buf (v : trigger) ~at : int option = let orig = at in let* at = encode_counter buf v.counter ~at in let* at = encode_enum encode_int32 identity valuetype_int_of_enum buf v.wait_type ~at in let* at = encode_int64 buf v.wait_value ~at in let* at = encode_enum encode_int32 identity testtype_int_of_enum buf v.test_type ~at in ignore orig; Some at;;

type waitcondition = { trigger : trigger; event_threshold : int64; } [@@deriving sexp];;
let decode_waitcondition buf ~at : (waitcondition * int) option = let orig = at in let* trigger, at = decode_trigger buf ~at in
let* event_threshold, at = decode_int64 buf ~at in
ignore orig;
Some ({ trigger; event_threshold }, at);;
let encode_waitcondition buf (v : waitcondition) ~at : int option = let orig = at in let* at = encode_trigger buf v.trigger ~at in let* at = encode_int64 buf v.event_threshold ~at in ignore orig; Some at;;

type counter_error = { bad_counter : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type alarm_error = { bad_alarm : int; minor_opcode : int; major_opcode : int; } [@@deriving sexp];;
type initialize_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_initialize ~(desired_major_version : int) ~(desired_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint8 buf desired_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf desired_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_initialize_reply length buf ~at : (initialize_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint8 buf ~at in
let* minor_version, at = decode_uint8 buf ~at in
let at = at + 22 in
ignore orig;
Some ({ major_version; minor_version }, at);;
type list_system_counters_reply = { counters : systemcounter list; } [@@deriving sexp];;
let encode_list_system_counters  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_system_counters_reply length buf ~at : (list_system_counters_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* counters_len, at = decode_int32 buf ~at in let counters_len = counters_len in
let at = at + 20 in
let* counters, at = decode_list (decode_systemcounter) counters_len buf ~at in
ignore orig;
Some ({ counters }, at);;
let encode_create_counter ~(id : counter) ~(initial_value : int64)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_counter buf id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int64 buf initial_value ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_counter ~(counter : counter)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_counter buf counter ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_counter_reply = { counter_value : int64; } [@@deriving sexp];;
let encode_query_counter ~(counter : counter)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_counter buf counter ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_counter_reply length buf ~at : (query_counter_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* counter_value, at = decode_int64 buf ~at in
ignore orig;
Some ({ counter_value }, at);;
let encode_await ~(wait_list : waitcondition list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_list encode_waitcondition buf wait_list ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_counter ~(counter : counter) ~(amount : int64)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_counter buf counter ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int64 buf amount ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_counter ~(counter : counter) ~(value : int64)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_counter buf counter ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int64 buf value ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_alarm ~(id : alarm) ?(counter : counter option) ?(value_type : valuetype_enum option) ?(value : int64 option) ?(test_type : testtype_enum option) ?(delta : int64 option) ?(events : int option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_alarm buf id ~at in
(* reserve request length *)
let at = at + 2 in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_change_alarm ~(id : alarm) ?(counter : counter option) ?(value_type : valuetype_enum option) ?(value : int64 option) ?(test_type : testtype_enum option) ?(delta : int64 option) ?(events : int option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_alarm buf id ~at in
(* reserve request length *)
let at = at + 2 in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_alarm ~(alarm : alarm)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_alarm buf alarm ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_alarm_reply = { trigger : trigger; delta : int64; events : bool; state : alarmstate_enum; } [@@deriving sexp];;
let encode_query_alarm ~(alarm : alarm)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_alarm buf alarm ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_alarm_reply length buf ~at : (query_alarm_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* trigger, at = decode_trigger buf ~at in
let* delta, at = decode_int64 buf ~at in
let* events, at = decode_bool buf ~at in
let* state, at = decode_enum decode_uint8 identity alarmstate_enum_of_int buf ~at in
let at = at + 2 in
ignore orig;
Some ({ trigger; delta; events; state }, at);;
let encode_set_priority ~(id : int) ~(priority : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_int32 buf id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf priority ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_priority_reply = { priority : int; } [@@deriving sexp];;
let encode_get_priority ~(id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_int32 buf id ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_priority_reply length buf ~at : (get_priority_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* priority, at = decode_int32 buf ~at in
ignore orig;
Some ({ priority }, at);;
let encode_create_fence ~(drawable : Xproto.drawable) ~(fence : fence) ~(initially_triggered : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_fence buf fence ~at in
let* at = encode_bool buf initially_triggered ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_trigger_fence ~(fence : fence)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_fence buf fence ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_reset_fence ~(fence : fence)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_fence buf fence ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_destroy_fence ~(fence : fence)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_fence buf fence ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_fence_reply = { triggered : bool; } [@@deriving sexp];;
let encode_query_fence ~(fence : fence)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_fence buf fence ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_fence_reply length buf ~at : (query_fence_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* triggered, at = decode_bool buf ~at in
let at = at + 23 in
ignore orig;
Some ({ triggered }, at);;
let encode_await_fence ~(fence_list : fence list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_list encode_fence buf fence_list ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type counter_notify_event = { kind : int; counter : counter; wait_value : int64; counter_value : int64; timestamp : Xproto.timestamp; count : int; destroyed : bool; } [@@deriving sexp];;
type alarm_notify_event = { kind : int; alarm : alarm; counter_value : int64; alarm_value : int64; timestamp : Xproto.timestamp; state : alarmstate_enum; } [@@deriving sexp];;
end
module[@warning "-27"] Present = struct
type event_enum = [ `Configure_notify | `Complete_notify | `Idle_notify | `Redirect_notify ] [@@deriving sexp];;
let event_enum_of_int : int -> [> event_enum ] option = function 0 -> Some `Configure_notify | 1 -> Some `Complete_notify | 2 -> Some `Idle_notify | 3 -> Some `Redirect_notify | n -> Printf.printf "unknown event_enum: %d\n" n; None;;
let event_int_of_enum : event_enum -> int = function `Configure_notify -> 0 | `Complete_notify -> 1 | `Idle_notify -> 2 | `Redirect_notify -> 3;;
type event_mask = ([ `Configure_notify | `Complete_notify | `Idle_notify | `Redirect_notify ] list, [ `No_event ]) mask [@@deriving sexp];;let event_mask_mask_of_int64 mask : event_mask option = let of_enum = function 0L -> Some `No_event | _ -> None in let of_mask = function 0 -> Some `Configure_notify | 1 -> Some `Complete_notify | 2 -> Some `Idle_notify | 3 -> Some `Redirect_notify | _ -> None in mask_value_of_int of_mask of_enum mask;;
let event_mask_int_of_mask (mask : event_mask) : int = let to_enum = function `No_event -> 0 in let to_mask = function `Configure_notify -> 0 | `Complete_notify -> 1 | `Idle_notify -> 2 | `Redirect_notify -> 3 in mask_value_to_int to_mask to_enum mask;;
type option_mask = ([ `Async | `Copy | `Ust | `Suboptimal ] list, [ `None ]) mask [@@deriving sexp];;let option_mask_of_int64 mask : option_mask option = let of_enum = function 0L -> Some `None | _ -> None in let of_mask = function 0 -> Some `Async | 1 -> Some `Copy | 2 -> Some `Ust | 3 -> Some `Suboptimal | _ -> None in mask_value_of_int of_mask of_enum mask;;
let option_int_of_mask (mask : option_mask) : int = let to_enum = function `None -> 0 in let to_mask = function `Async -> 0 | `Copy -> 1 | `Ust -> 2 | `Suboptimal -> 3 in mask_value_to_int to_mask to_enum mask;;
type capability_mask = ([ `Async | `Fence | `Ust ] list, [ `None ]) mask [@@deriving sexp];;let capability_mask_of_int64 mask : capability_mask option = let of_enum = function 0L -> Some `None | _ -> None in let of_mask = function 0 -> Some `Async | 1 -> Some `Fence | 2 -> Some `Ust | _ -> None in mask_value_of_int of_mask of_enum mask;;
let capability_int_of_mask (mask : capability_mask) : int = let to_enum = function `None -> 0 in let to_mask = function `Async -> 0 | `Fence -> 1 | `Ust -> 2 in mask_value_to_int to_mask to_enum mask;;
type complete_kind_enum = [ `Pixmap | `Notify_msc ] [@@deriving sexp];;
let complete_kind_enum_of_int : int -> [> complete_kind_enum ] option = function 0 -> Some `Pixmap | 1 -> Some `Notify_msc | n -> Printf.printf "unknown complete_kind_enum: %d\n" n; None;;
let complete_kind_int_of_enum : complete_kind_enum -> int = function `Pixmap -> 0 | `Notify_msc -> 1;;
type complete_mode_enum = [ `Copy | `Flip | `Skip | `Suboptimal_copy ] [@@deriving sexp];;
let complete_mode_enum_of_int : int -> [> complete_mode_enum ] option = function 0 -> Some `Copy | 1 -> Some `Flip | 2 -> Some `Skip | 3 -> Some `Suboptimal_copy | n -> Printf.printf "unknown complete_mode_enum: %d\n" n; None;;
let complete_mode_int_of_enum : complete_mode_enum -> int = function `Copy -> 0 | `Flip -> 1 | `Skip -> 2 | `Suboptimal_copy -> 3;;
type notify = { window : Xproto.window; serial : int; } [@@deriving sexp];;
let decode_notify buf ~at : (notify * int) option = let orig = at in let* window, at = Xproto.decode_window buf ~at in
let* serial, at = decode_int32 buf ~at in
ignore orig;
Some ({ window; serial }, at);;
let encode_notify buf (v : notify) ~at : int option = let orig = at in let* at = Xproto.encode_window buf v.window ~at in let* at = encode_int32 buf v.serial ~at in ignore orig; Some at;;

type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_int32 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_int32 buf ~at in
let* minor_version, at = decode_int32 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
let encode_pixmap ~(window : Xproto.window) ~(pixmap : Xproto.pixmap) ~(serial : int) ~(valid : Xfixes.region) ~(update : Xfixes.region) ~(x_off : int) ~(y_off : int) ~(target_crtc : Randr.crtc) ~(wait_fence : Sync.fence) ~(idle_fence : Sync.fence) ~(options : int) ~(target_msc : int64) ~(divisor : int64) ~(remainder : int64) ~(notifies : notify list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_pixmap buf pixmap ~at in
let* at = encode_int32 buf serial ~at in
let* at = Xfixes.encode_region buf valid ~at in
let* at = Xfixes.encode_region buf update ~at in
let* at = encode_int16 buf x_off ~at in
let* at = encode_int16 buf y_off ~at in
let* at = Randr.encode_crtc buf target_crtc ~at in
let* at = Sync.encode_fence buf wait_fence ~at in
let* at = Sync.encode_fence buf idle_fence ~at in
let* at = encode_int32 buf options ~at in
let at = at + 4 in
let* at = encode_int64 buf target_msc ~at in
let* at = encode_int64 buf divisor ~at in
let* at = encode_int64 buf remainder ~at in
let* at = encode_list encode_notify buf notifies ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_notify_msc ~(window : Xproto.window) ~(serial : int) ~(target_msc : int64) ~(divisor : int64) ~(remainder : int64)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf serial ~at in
let at = at + 4 in
let* at = encode_int64 buf target_msc ~at in
let* at = encode_int64 buf divisor ~at in
let* at = encode_int64 buf remainder ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type event = xid [@@deriving sexp];;
let decode_event = decode_xid;;
let encode_event = encode_xid;;

let encode_select_input ~(eid : event) ~(window : Xproto.window) ~(event_mask : event_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_event buf eid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf window ~at in
let* at = encode_mask encode_int32 identity event_mask_int_of_mask buf event_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_capabilities_reply = { capabilities : int; } [@@deriving sexp];;
let encode_query_capabilities ~(target : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_int32 buf target ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_capabilities_reply length buf ~at : (query_capabilities_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* capabilities, at = decode_int32 buf ~at in
ignore orig;
Some ({ capabilities }, at);;
type generic_event = { extension : int; length : int; evtype : int; event : event; } [@@deriving sexp];;
type configure_notify_event = { event : event; window : Xproto.window; x : int; y : int; width : int; height : int; off_x : int; off_y : int; pixmap_width : int; pixmap_height : int; pixmap_flags : int; } [@@deriving sexp];;
type complete_notify_event = { kind : complete_kind_enum; mode : complete_mode_enum; event : event; window : Xproto.window; serial : int; ust : int64; msc : int64; } [@@deriving sexp];;
type idle_notify_event = { event : event; window : Xproto.window; serial : int; pixmap : Xproto.pixmap; idle_fence : Sync.fence; } [@@deriving sexp];;
type redirect_notify_event = { update_window : bool; event : event; event_window : Xproto.window; window : Xproto.window; pixmap : Xproto.pixmap; serial : int; valid_region : Xfixes.region; update_region : Xfixes.region; valid_rect : Xproto.rectangle; update_rect : Xproto.rectangle; x_off : int; y_off : int; target_crtc : Randr.crtc; wait_fence : Sync.fence; idle_fence : Sync.fence; options : int; target_msc : int64; divisor : int64; remainder : int64; notifies : notify list; } [@@deriving sexp];;
end
module[@warning "-27"] Record = struct
type context = xid [@@deriving sexp];;
let decode_context = decode_xid;;
let encode_context = encode_xid;;

type range8 = { first : int; last : int; } [@@deriving sexp];;
let decode_range8 buf ~at : (range8 * int) option = let orig = at in let* first, at = decode_uint8 buf ~at in
let* last, at = decode_uint8 buf ~at in
ignore orig;
Some ({ first; last }, at);;
let encode_range8 buf (v : range8) ~at : int option = let orig = at in let* at = encode_uint8 buf v.first ~at in let* at = encode_uint8 buf v.last ~at in ignore orig; Some at;;

type range16 = { first : int; last : int; } [@@deriving sexp];;
let decode_range16 buf ~at : (range16 * int) option = let orig = at in let* first, at = decode_uint16 buf ~at in
let* last, at = decode_uint16 buf ~at in
ignore orig;
Some ({ first; last }, at);;
let encode_range16 buf (v : range16) ~at : int option = let orig = at in let* at = encode_uint16 buf v.first ~at in let* at = encode_uint16 buf v.last ~at in ignore orig; Some at;;

type ext_range = { major : range8; minor : range16; } [@@deriving sexp];;
let decode_ext_range buf ~at : (ext_range * int) option = let orig = at in let* major, at = decode_range8 buf ~at in
let* minor, at = decode_range16 buf ~at in
ignore orig;
Some ({ major; minor }, at);;
let encode_ext_range buf (v : ext_range) ~at : int option = let orig = at in let* at = encode_range8 buf v.major ~at in let* at = encode_range16 buf v.minor ~at in ignore orig; Some at;;

type range = { core_requests : range8; core_replies : range8; ext_requests : ext_range; ext_replies : ext_range; delivered_events : range8; device_events : range8; errors : range8; client_started : bool; client_died : bool; } [@@deriving sexp];;
let decode_range buf ~at : (range * int) option = let orig = at in let* core_requests, at = decode_range8 buf ~at in
let* core_replies, at = decode_range8 buf ~at in
let* ext_requests, at = decode_ext_range buf ~at in
let* ext_replies, at = decode_ext_range buf ~at in
let* delivered_events, at = decode_range8 buf ~at in
let* device_events, at = decode_range8 buf ~at in
let* errors, at = decode_range8 buf ~at in
let* client_started, at = decode_bool buf ~at in
let* client_died, at = decode_bool buf ~at in
ignore orig;
Some ({ core_requests; core_replies; ext_requests; ext_replies; delivered_events; device_events; errors; client_started; client_died }, at);;
let encode_range buf (v : range) ~at : int option = let orig = at in let* at = encode_range8 buf v.core_requests ~at in let* at = encode_range8 buf v.core_replies ~at in let* at = encode_ext_range buf v.ext_requests ~at in let* at = encode_ext_range buf v.ext_replies ~at in let* at = encode_range8 buf v.delivered_events ~at in let* at = encode_range8 buf v.device_events ~at in let* at = encode_range8 buf v.errors ~at in let* at = encode_bool buf v.client_started ~at in let* at = encode_bool buf v.client_died ~at in ignore orig; Some at;;

type element_header = int [@@deriving sexp];;
let decode_element_header = decode_uint8;;
let encode_element_header = encode_uint8;;

type h_type_mask = [ `From_server_time | `From_client_time | `From_client_sequence ] list [@@deriving sexp];;
let h_type_mask_of_int64 mask : h_type_mask option = let of_int = function 0 -> Some `From_server_time | 1 -> Some `From_client_time | 2 -> Some `From_client_sequence | _ -> None in mask_of_int of_int mask;;
let h_type_int_of_mask : h_type_mask -> int = let to_bit = function `From_server_time -> 0 | `From_client_time -> 1 | `From_client_sequence -> 2 in int_of_mask to_bit;;
type client_spec = int [@@deriving sexp];;
let decode_client_spec = decode_int32;;
let encode_client_spec = encode_int32;;

type cs_enum = [ `Current_clients | `Future_clients | `All_clients ] [@@deriving sexp];;
let cs_enum_of_int : int -> [> cs_enum ] option = function 1 -> Some `Current_clients | 2 -> Some `Future_clients | 3 -> Some `All_clients | n -> Printf.printf "unknown cs_enum: %d\n" n; None;;
let cs_int_of_enum : cs_enum -> int = function `Current_clients -> 1 | `Future_clients -> 2 | `All_clients -> 3;;
type client_info = { client_resource : client_spec; ranges : range list; } [@@deriving sexp];;
let decode_client_info buf ~at : (client_info * int) option = let orig = at in let* client_resource, at = decode_client_spec buf ~at in
let* num_ranges, at = decode_int32 buf ~at in let num_ranges = num_ranges in
let* ranges, at = decode_list (decode_range) num_ranges buf ~at in
ignore orig;
Some ({ client_resource; ranges }, at);;
let encode_client_info buf (v : client_info) ~at : int option = let orig = at in let* at = encode_client_spec buf v.client_resource ~at in let* at = encode_int32 buf (identity ((* invalid_argument *) List.length v.ranges)) ~at in let* at = encode_list encode_range buf v.ranges ~at in ignore orig; Some at;;

type bad_context_error = { invalid_record : int; } [@@deriving sexp];;
type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint16 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
let encode_create_context ~(context : context) ~(element_header : element_header) ~(client_specs : client_spec list) ~(ranges : range list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_element_header buf element_header ~at in
let at = at + 3 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length client_specs)) ~at in
let* at = encode_int32 buf (identity ((* invalid_argument *) List.length ranges)) ~at in
let* at = encode_list encode_client_spec buf client_specs ~at in
let* at = encode_list encode_range buf ranges ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_register_clients ~(context : context) ~(element_header : element_header) ~(client_specs : client_spec list) ~(ranges : range list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_element_header buf element_header ~at in
let at = at + 3 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length client_specs)) ~at in
let* at = encode_int32 buf (identity ((* invalid_argument *) List.length ranges)) ~at in
let* at = encode_list encode_client_spec buf client_specs ~at in
let* at = encode_list encode_range buf ranges ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_unregister_clients ~(context : context) ~(client_specs : client_spec list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length client_specs)) ~at in
let* at = encode_list encode_client_spec buf client_specs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_context_reply = { enabled : bool; element_header : element_header; intercepted_clients : client_info list; } [@@deriving sexp];;
let encode_get_context ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_context_reply length buf ~at : (get_context_reply * int) option = let orig = at in let at = at + 1 in
let* enabled, at = decode_bool buf ~at in
let at = at + 6 in
let* element_header, at = decode_element_header buf ~at in
let at = at + 3 in
let* num_intercepted_clients, at = decode_int32 buf ~at in let num_intercepted_clients = num_intercepted_clients in
let at = at + 16 in
let* intercepted_clients, at = decode_list (decode_client_info) num_intercepted_clients buf ~at in
ignore orig;
Some ({ enabled; element_header; intercepted_clients }, at);;
type enable_context_reply = { category : int; element_header : element_header; client_swapped : bool; xid_base : int; server_time : int; rec_sequence_num : int; data : char list; } [@@deriving sexp];;
let encode_enable_context ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_enable_context_reply length buf ~at : (enable_context_reply * int) option = let orig = at in let at = at + 1 in
let* category, at = decode_uint8 buf ~at in
let at = at + 6 in
let* element_header, at = decode_element_header buf ~at in
let* client_swapped, at = decode_bool buf ~at in
let at = at + 2 in
let* xid_base, at = decode_int32 buf ~at in
let* server_time, at = decode_int32 buf ~at in
let* rec_sequence_num, at = decode_int32 buf ~at in
let at = at + 8 in
let* data, at = let length = (length) * (4) in decode_list (decode_char) length buf ~at in
ignore orig;
Some ({ category; element_header; client_swapped; xid_base; server_time; rec_sequence_num; data }, at);;
let encode_disable_context ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_free_context ~(context : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_context buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
end
module[@warning "-27"] Res = struct
type client = { resource_base : int; resource_mask : int; } [@@deriving sexp];;
let decode_client buf ~at : (client * int) option = let orig = at in let* resource_base, at = decode_int32 buf ~at in
let* resource_mask, at = decode_int32 buf ~at in
ignore orig;
Some ({ resource_base; resource_mask }, at);;
let encode_client buf (v : client) ~at : int option = let orig = at in let* at = encode_int32 buf v.resource_base ~at in let* at = encode_int32 buf v.resource_mask ~at in ignore orig; Some at;;

type type_ = { resource_type : Xproto.atom; count : int; } [@@deriving sexp];;
let decode_type buf ~at : (type_ * int) option = let orig = at in let* resource_type, at = Xproto.decode_atom buf ~at in
let* count, at = decode_int32 buf ~at in
ignore orig;
Some ({ resource_type; count }, at);;
let encode_type buf (v : type_) ~at : int option = let orig = at in let* at = Xproto.encode_atom buf v.resource_type ~at in let* at = encode_int32 buf v.count ~at in ignore orig; Some at;;

type client_id_mask = [ `Client_xid | `Local_client_pid ] list [@@deriving sexp];;
let client_id_mask_mask_of_int64 mask : client_id_mask option = let of_int = function 0 -> Some `Client_xid | 1 -> Some `Local_client_pid | _ -> None in mask_of_int of_int mask;;
let client_id_mask_int_of_mask : client_id_mask -> int = let to_bit = function `Client_xid -> 0 | `Local_client_pid -> 1 in int_of_mask to_bit;;
type client_id_spec = { client : int; mask : client_id_mask; } [@@deriving sexp];;
let decode_client_id_spec buf ~at : (client_id_spec * int) option = let orig = at in let* client, at = decode_int32 buf ~at in
let* mask, at = decode_mask decode_int32 Int64.of_int client_id_mask_mask_of_int64 buf ~at in
ignore orig;
Some ({ client; mask }, at);;
let encode_client_id_spec buf (v : client_id_spec) ~at : int option = let orig = at in let* at = encode_int32 buf v.client ~at in let* at = encode_mask encode_int32 identity client_id_mask_int_of_mask buf v.mask ~at in ignore orig; Some at;;

type client_id_value = { spec : client_id_spec; value : int list; } [@@deriving sexp];;
let decode_client_id_value buf ~at : (client_id_value * int) option = let orig = at in let* spec, at = decode_client_id_spec buf ~at in
let* length, at = decode_int32 buf ~at in let length = (length) * (4) in
let* value, at = decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ spec; value }, at);;
let encode_client_id_value buf (v : client_id_value) ~at : int option = let orig = at in let* at = encode_client_id_spec buf v.spec ~at in let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length v.value)) ~at in let* at = encode_list encode_int32 buf v.value ~at in ignore orig; Some at;;

type resource_id_spec = { resource : int; type_ : int; } [@@deriving sexp];;
let decode_resource_id_spec buf ~at : (resource_id_spec * int) option = let orig = at in let* resource, at = decode_int32 buf ~at in
let* type_, at = decode_int32 buf ~at in
ignore orig;
Some ({ resource; type_ }, at);;
let encode_resource_id_spec buf (v : resource_id_spec) ~at : int option = let orig = at in let* at = encode_int32 buf v.resource ~at in let* at = encode_int32 buf v.type_ ~at in ignore orig; Some at;;

type resource_size_spec = { spec : resource_id_spec; bytes : int; ref_count : int; use_count : int; } [@@deriving sexp];;
let decode_resource_size_spec buf ~at : (resource_size_spec * int) option = let orig = at in let* spec, at = decode_resource_id_spec buf ~at in
let* bytes, at = decode_int32 buf ~at in
let* ref_count, at = decode_int32 buf ~at in
let* use_count, at = decode_int32 buf ~at in
ignore orig;
Some ({ spec; bytes; ref_count; use_count }, at);;
let encode_resource_size_spec buf (v : resource_size_spec) ~at : int option = let orig = at in let* at = encode_resource_id_spec buf v.spec ~at in let* at = encode_int32 buf v.bytes ~at in let* at = encode_int32 buf v.ref_count ~at in let* at = encode_int32 buf v.use_count ~at in ignore orig; Some at;;

type resource_size_value = { size : resource_size_spec; cross_references : resource_size_spec list; } [@@deriving sexp];;
let decode_resource_size_value buf ~at : (resource_size_value * int) option = let orig = at in let* size, at = decode_resource_size_spec buf ~at in
let* num_cross_references, at = decode_int32 buf ~at in let num_cross_references = num_cross_references in
let* cross_references, at = decode_list (decode_resource_size_spec) num_cross_references buf ~at in
ignore orig;
Some ({ size; cross_references }, at);;
let encode_resource_size_value buf (v : resource_size_value) ~at : int option = let orig = at in let* at = encode_resource_size_spec buf v.size ~at in let* at = encode_int32 buf (identity ((* invalid_argument *) List.length v.cross_references)) ~at in let* at = encode_list encode_resource_size_spec buf v.cross_references ~at in ignore orig; Some at;;

type query_version_reply = { server_major : int; server_minor : int; } [@@deriving sexp];;
let encode_query_version ~(client_major : int) ~(client_minor : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint8 buf client_major ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf client_minor ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* server_major, at = decode_uint16 buf ~at in
let* server_minor, at = decode_uint16 buf ~at in
ignore orig;
Some ({ server_major; server_minor }, at);;
type query_clients_reply = { clients : client list; } [@@deriving sexp];;
let encode_query_clients  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_clients_reply length buf ~at : (query_clients_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_clients, at = decode_int32 buf ~at in let num_clients = num_clients in
let at = at + 20 in
let* clients, at = decode_list (decode_client) num_clients buf ~at in
ignore orig;
Some ({ clients }, at);;
type query_client_resources_reply = { types : type_ list; } [@@deriving sexp];;
let encode_query_client_resources ~(xid : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_int32 buf xid ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_client_resources_reply length buf ~at : (query_client_resources_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_types, at = decode_int32 buf ~at in let num_types = num_types in
let at = at + 20 in
let* types, at = decode_list (decode_type) num_types buf ~at in
ignore orig;
Some ({ types }, at);;
type query_client_pixmap_bytes_reply = { bytes : int; bytes_overflow : int; } [@@deriving sexp];;
let encode_query_client_pixmap_bytes ~(xid : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_int32 buf xid ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_client_pixmap_bytes_reply length buf ~at : (query_client_pixmap_bytes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* bytes, at = decode_int32 buf ~at in
let* bytes_overflow, at = decode_int32 buf ~at in
ignore orig;
Some ({ bytes; bytes_overflow }, at);;
type query_client_ids_reply = { ids : client_id_value list; } [@@deriving sexp];;
let encode_query_client_ids ~(specs : client_id_spec list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_int32 buf (identity ((* invalid_argument *) List.length specs)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_client_id_spec buf specs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_client_ids_reply length buf ~at : (query_client_ids_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_ids, at = decode_int32 buf ~at in let num_ids = num_ids in
let at = at + 20 in
let* ids, at = decode_list (decode_client_id_value) num_ids buf ~at in
ignore orig;
Some ({ ids }, at);;
type query_resource_bytes_reply = { sizes : resource_size_value list; } [@@deriving sexp];;
let encode_query_resource_bytes ~(client : int) ~(specs : resource_id_spec list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_int32 buf client ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* invalid_argument *) List.length specs)) ~at in
let* at = encode_list encode_resource_id_spec buf specs ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_resource_bytes_reply length buf ~at : (query_resource_bytes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_sizes, at = decode_int32 buf ~at in let num_sizes = num_sizes in
let at = at + 20 in
let* sizes, at = decode_list (decode_resource_size_value) num_sizes buf ~at in
ignore orig;
Some ({ sizes }, at);;
end
module[@warning "-27"] Screensaver = struct
type kind_enum = [ `Blanked | `Internal | `External ] [@@deriving sexp];;
let kind_enum_of_int : int -> [> kind_enum ] option = function 0 -> Some `Blanked | 1 -> Some `Internal | 2 -> Some `External | n -> Printf.printf "unknown kind_enum: %d\n" n; None;;
let kind_int_of_enum : kind_enum -> int = function `Blanked -> 0 | `Internal -> 1 | `External -> 2;;
type event_mask = [ `Notify_mask | `Cycle_mask ] list [@@deriving sexp];;
let event_mask_of_int64 mask : event_mask option = let of_int = function 0 -> Some `Notify_mask | 1 -> Some `Cycle_mask | _ -> None in mask_of_int of_int mask;;
let event_int_of_mask : event_mask -> int = let to_bit = function `Notify_mask -> 0 | `Cycle_mask -> 1 in int_of_mask to_bit;;
type state_enum = [ `Off | `On | `Cycle | `Disabled ] [@@deriving sexp];;
let state_enum_of_int : int -> [> state_enum ] option = function 0 -> Some `Off | 1 -> Some `On | 2 -> Some `Cycle | 3 -> Some `Disabled | n -> Printf.printf "unknown state_enum: %d\n" n; None;;
let state_int_of_enum : state_enum -> int = function `Off -> 0 | `On -> 1 | `Cycle -> 2 | `Disabled -> 3;;
type query_version_reply = { server_major_version : int; server_minor_version : int; } [@@deriving sexp];;
let encode_query_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint8 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf client_minor_version ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* server_major_version, at = decode_uint16 buf ~at in
let* server_minor_version, at = decode_uint16 buf ~at in
let at = at + 20 in
ignore orig;
Some ({ server_major_version; server_minor_version }, at);;
type query_info_reply = { state : int; saver_window : Xproto.window; ms_until_server : int; ms_since_user_input : int; event_mask : int; kind : kind_enum; } [@@deriving sexp];;
let encode_query_info ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_info_reply length buf ~at : (query_info_reply * int) option = let orig = at in let at = at + 1 in
let* state, at = decode_uint8 buf ~at in
let at = at + 6 in
let* saver_window, at = Xproto.decode_window buf ~at in
let* ms_until_server, at = decode_int32 buf ~at in
let* ms_since_user_input, at = decode_int32 buf ~at in
let* event_mask, at = decode_int32 buf ~at in
let* kind, at = decode_enum decode_char Char.code kind_enum_of_int buf ~at in
let at = at + 7 in
ignore orig;
Some ({ state; saver_window; ms_until_server; ms_since_user_input; event_mask; kind }, at);;
let encode_select_input ~(drawable : Xproto.drawable) ~(event_mask : event_mask)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mask encode_int32 identity event_int_of_mask buf event_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_attributes ~(drawable : Xproto.drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(border_width : int) ~(class_ : Xproto.window_class_enum) ~(depth : int) ~(visual : Xproto.visualid) ?(background_pixmap : Xproto.back_pixmap_enum alt_enum option) ?(background_pixel : int option) ?(border_pixmap : Xproto.pixmap_enum alt_enum option) ?(border_pixel : int option) ?(bit_gravity : Xproto.gravity_enum option) ?(win_gravity : Xproto.gravity_enum option) ?(backing_store : Xproto.backing_store_enum option) ?(backing_planes : int option) ?(backing_pixel : int option) ?(override_redirect : Xproto.bool32 option) ?(save_under : Xproto.bool32 option) ?(event_mask : Xproto.event_mask option) ?(do_not_propogate_mask : Xproto.event_mask option) ?(colormap : Xproto.colormap_enum alt_enum option) ?(cursor : Xproto.cursor_enum alt_enum option)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint16 buf border_width ~at in
let* at = encode_enum encode_char Char.chr Xproto.window_class_int_of_enum buf class_ ~at in
let* at = encode_uint8 buf depth ~at in
let* at = Xproto.encode_visualid buf visual ~at in
(* field_optional_mask *)let* at = encode_int32 buf 0 ~at in
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* field_optional *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_unset_attributes ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_suspend ~(suspend : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_int32 buf suspend ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type notify_event = { state : state_enum; time : Xproto.timestamp; root : Xproto.window; window : Xproto.window; kind : kind_enum; forced : bool; } [@@deriving sexp];;
end
module[@warning "-27"] Shm = struct
type seg = xid [@@deriving sexp];;
let decode_seg = decode_xid;;
let encode_seg = encode_xid;;

type completion_event = { drawable : Xproto.drawable; minor_event : int; major_event : char; shmseg : seg; offset : int; } [@@deriving sexp];;
type bad_seg_error = Xproto.value_error [@@deriving sexp];;
type query_version_reply = { shared_pixmaps : bool; major_version : int; minor_version : int; uid : int; gid : int; pixmap_format : int; } [@@deriving sexp];;
let encode_query_version  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let* shared_pixmaps, at = decode_bool buf ~at in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
let* uid, at = decode_uint16 buf ~at in
let* gid, at = decode_uint16 buf ~at in
let* pixmap_format, at = decode_uint8 buf ~at in
let at = at + 15 in
ignore orig;
Some ({ shared_pixmaps; major_version; minor_version; uid; gid; pixmap_format }, at);;
let encode_attach ~(shmseg : seg) ~(shmid : int) ~(read_only : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_seg buf shmseg ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf shmid ~at in
let* at = encode_bool buf read_only ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_detach ~(shmseg : seg)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_seg buf shmseg ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_put_image ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(total_width : int) ~(total_height : int) ~(src_x : int) ~(src_y : int) ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int) ~(depth : int) ~(format : int) ~(send_event : bool) ~(shmseg : seg) ~(offset : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = encode_uint16 buf total_width ~at in
let* at = encode_uint16 buf total_height ~at in
let* at = encode_uint16 buf src_x ~at in
let* at = encode_uint16 buf src_y ~at in
let* at = encode_uint16 buf src_width ~at in
let* at = encode_uint16 buf src_height ~at in
let* at = encode_int16 buf dst_x ~at in
let* at = encode_int16 buf dst_y ~at in
let* at = encode_uint8 buf depth ~at in
let* at = encode_uint8 buf format ~at in
let* at = encode_bool buf send_event ~at in
let at = at + 1 in
let* at = encode_seg buf shmseg ~at in
let* at = encode_int32 buf offset ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_image_reply = { depth : int; visual : Xproto.visualid; size : int; } [@@deriving sexp];;
let encode_get_image ~(drawable : Xproto.drawable) ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(plane_mask : int) ~(format : int) ~(shmseg : seg) ~(offset : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int16 buf x ~at in
let* at = encode_int16 buf y ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf plane_mask ~at in
let* at = encode_uint8 buf format ~at in
let at = at + 3 in
let* at = encode_seg buf shmseg ~at in
let* at = encode_int32 buf offset ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_image_reply length buf ~at : (get_image_reply * int) option = let orig = at in let at = at + 1 in
let* depth, at = decode_uint8 buf ~at in
let at = at + 6 in
let* visual, at = Xproto.decode_visualid buf ~at in
let* size, at = decode_int32 buf ~at in
ignore orig;
Some ({ depth; visual; size }, at);;
let encode_create_pixmap ~(pid : Xproto.pixmap) ~(drawable : Xproto.drawable) ~(width : int) ~(height : int) ~(depth : int) ~(shmseg : seg) ~(offset : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = Xproto.encode_pixmap buf pid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint8 buf depth ~at in
let at = at + 3 in
let* at = encode_seg buf shmseg ~at in
let* at = encode_int32 buf offset ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_attach_fd ~(shmseg : seg) ~(shm_fd : Unix.file_descr) ~(read_only : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_seg buf shmseg ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_file_descriptor buf shm_fd ~at in
let* at = encode_bool buf read_only ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type create_segment_reply = { nfd : int; shm_fd : Unix.file_descr; } [@@deriving sexp];;
let encode_create_segment ~(shmseg : seg) ~(size : int) ~(read_only : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_seg buf shmseg ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf size ~at in
let* at = encode_bool buf read_only ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_segment_reply length buf ~at : (create_segment_reply * int) option = let orig = at in let at = at + 1 in
let* nfd, at = decode_uint8 buf ~at in
let at = at + 6 in
let* shm_fd, at = decode_file_descr buf ~at in
let at = at + 24 in
ignore orig;
Some ({ nfd; shm_fd }, at);;
end
module[@warning "-27"] Xc_misc = struct
type get_version_reply = { server_major_version : int; server_minor_version : int; } [@@deriving sexp];;
let encode_get_version ~(client_major_version : int) ~(client_minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint16 buf client_major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf client_minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_version_reply length buf ~at : (get_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* server_major_version, at = decode_uint16 buf ~at in
let* server_minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ server_major_version; server_minor_version }, at);;
type get_xid_range_reply = { start_id : int; count : int; } [@@deriving sexp];;
let encode_get_xid_range  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_xid_range_reply length buf ~at : (get_xid_range_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* start_id, at = decode_int32 buf ~at in
let* count, at = decode_int32 buf ~at in
ignore orig;
Some ({ start_id; count }, at);;
type get_xid_list_reply = { ids : int list; } [@@deriving sexp];;
let encode_get_xid_list ~(count : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_int32 buf count ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_xid_list_reply length buf ~at : (get_xid_list_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* ids_len, at = decode_int32 buf ~at in let ids_len = ids_len in
let at = at + 20 in
let* ids, at = decode_list (decode_int32) ids_len buf ~at in
ignore orig;
Some ({ ids }, at);;
end
module[@warning "-27"] Xf86dri = struct
type drm_clip_rect = { x1 : int; y1 : int; x2 : int; x3 : int; } [@@deriving sexp];;
let decode_drm_clip_rect buf ~at : (drm_clip_rect * int) option = let orig = at in let* x1, at = decode_int16 buf ~at in
let* y1, at = decode_int16 buf ~at in
let* x2, at = decode_int16 buf ~at in
let* x3, at = decode_int16 buf ~at in
ignore orig;
Some ({ x1; y1; x2; x3 }, at);;
let encode_drm_clip_rect buf (v : drm_clip_rect) ~at : int option = let orig = at in let* at = encode_int16 buf v.x1 ~at in let* at = encode_int16 buf v.y1 ~at in let* at = encode_int16 buf v.x2 ~at in let* at = encode_int16 buf v.x3 ~at in ignore orig; Some at;;

type query_version_reply = { dri_major_version : int; dri_minor_version : int; dri_minor_patch : int; } [@@deriving sexp];;
let encode_query_version  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* dri_major_version, at = decode_uint16 buf ~at in
let* dri_minor_version, at = decode_uint16 buf ~at in
let* dri_minor_patch, at = decode_int32 buf ~at in
ignore orig;
Some ({ dri_major_version; dri_minor_version; dri_minor_patch }, at);;
type query_direct_rendering_capable_reply = { is_capable : bool; } [@@deriving sexp];;
let encode_query_direct_rendering_capable ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_direct_rendering_capable_reply length buf ~at : (query_direct_rendering_capable_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* is_capable, at = decode_bool buf ~at in
ignore orig;
Some ({ is_capable }, at);;
type open_connection_reply = { sarea_handle_low : int; sarea_handle_high : int; bus_id : string; } [@@deriving sexp];;
let encode_open_connection ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_open_connection_reply length buf ~at : (open_connection_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* sarea_handle_low, at = decode_int32 buf ~at in
let* sarea_handle_high, at = decode_int32 buf ~at in
let* bus_id_len, at = decode_int32 buf ~at in let bus_id_len = bus_id_len in
let at = at + 12 in
let* bus_id, at = decode_string bus_id_len buf ~at in
ignore orig;
Some ({ sarea_handle_low; sarea_handle_high; bus_id }, at);;
let encode_close_connection ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_client_driver_name_reply = { client_driver_major_version : int; client_driver_minor_version : int; client_driver_patch_version : int; client_driver_name : string; } [@@deriving sexp];;
let encode_get_client_driver_name ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_client_driver_name_reply length buf ~at : (get_client_driver_name_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* client_driver_major_version, at = decode_int32 buf ~at in
let* client_driver_minor_version, at = decode_int32 buf ~at in
let* client_driver_patch_version, at = decode_int32 buf ~at in
let* client_driver_name_len, at = decode_int32 buf ~at in let client_driver_name_len = client_driver_name_len in
let at = at + 8 in
let* client_driver_name, at = decode_string client_driver_name_len buf ~at in
ignore orig;
Some ({ client_driver_major_version; client_driver_minor_version; client_driver_patch_version; client_driver_name }, at);;
type create_context_reply = { hw_context : int; } [@@deriving sexp];;
let encode_create_context ~(screen : int) ~(visual : int) ~(context : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf visual ~at in
let* at = encode_int32 buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_context_reply length buf ~at : (create_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* hw_context, at = decode_int32 buf ~at in
ignore orig;
Some ({ hw_context }, at);;
let encode_destroy_context ~(screen : int) ~(context : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type create_drawable_reply = { hw_drawable_handle : int; } [@@deriving sexp];;
let encode_create_drawable ~(screen : int) ~(drawable : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_drawable_reply length buf ~at : (create_drawable_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* hw_drawable_handle, at = decode_int32 buf ~at in
ignore orig;
Some ({ hw_drawable_handle }, at);;
let encode_destroy_drawable ~(screen : int) ~(drawable : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_drawable_info_reply = { drawable_table_index : int; drawable_table_stamp : int; drawable_origin_x : int; drawable_origin_y : int; drawable_size_w : int; drawable_size_h : int; back_x : int; back_y : int; clip_rects : drm_clip_rect list; back_clip_rects : drm_clip_rect list; } [@@deriving sexp];;
let encode_get_drawable_info ~(screen : int) ~(drawable : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_drawable_info_reply length buf ~at : (get_drawable_info_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* drawable_table_index, at = decode_int32 buf ~at in
let* drawable_table_stamp, at = decode_int32 buf ~at in
let* drawable_origin_x, at = decode_int16 buf ~at in
let* drawable_origin_y, at = decode_int16 buf ~at in
let* drawable_size_w, at = decode_int16 buf ~at in
let* drawable_size_h, at = decode_int16 buf ~at in
let* num_clip_rects, at = decode_int32 buf ~at in let num_clip_rects = num_clip_rects in
let* back_x, at = decode_int16 buf ~at in
let* back_y, at = decode_int16 buf ~at in
let* num_back_clip_rects, at = decode_int32 buf ~at in let num_back_clip_rects = num_back_clip_rects in
let* clip_rects, at = decode_list (decode_drm_clip_rect) num_clip_rects buf ~at in
let* back_clip_rects, at = decode_list (decode_drm_clip_rect) num_back_clip_rects buf ~at in
ignore orig;
Some ({ drawable_table_index; drawable_table_stamp; drawable_origin_x; drawable_origin_y; drawable_size_w; drawable_size_h; back_x; back_y; clip_rects; back_clip_rects }, at);;
type get_device_info_reply = { framebuffer_handle_low : int; framebuffer_handle_high : int; framebuffer_origin_offset : int; framebuffer_size : int; framebuffer_stride : int; device_private : int list; } [@@deriving sexp];;
let encode_get_device_info ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_info_reply length buf ~at : (get_device_info_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* framebuffer_handle_low, at = decode_int32 buf ~at in
let* framebuffer_handle_high, at = decode_int32 buf ~at in
let* framebuffer_origin_offset, at = decode_int32 buf ~at in
let* framebuffer_size, at = decode_int32 buf ~at in
let* framebuffer_stride, at = decode_int32 buf ~at in
let* device_private_size, at = decode_int32 buf ~at in let device_private_size = device_private_size in
let* device_private, at = decode_list (decode_int32) device_private_size buf ~at in
ignore orig;
Some ({ framebuffer_handle_low; framebuffer_handle_high; framebuffer_origin_offset; framebuffer_size; framebuffer_stride; device_private }, at);;
type auth_connection_reply = { authenticated : int; } [@@deriving sexp];;
let encode_auth_connection ~(screen : int) ~(magic : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf magic ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_auth_connection_reply length buf ~at : (auth_connection_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* authenticated, at = decode_int32 buf ~at in
ignore orig;
Some ({ authenticated }, at);;
end
module[@warning "-27"] Xf86vidmode = struct
type syncrange = int [@@deriving sexp];;
let decode_syncrange = decode_int32;;
let encode_syncrange = encode_int32;;

type dotclock = int [@@deriving sexp];;
let decode_dotclock = decode_int32;;
let encode_dotclock = encode_int32;;

type mode_flag_mask = [ `Positive_h_sync | `Negative_h_sync | `Positive_v_sync | `Negative_v_sync | `Interlace | `Composite_sync | `Positive_c_sync | `Negative_c_sync | `H_skew | `Broadcast | `Pixmux | `Double_clock | `Half_clock ] list [@@deriving sexp];;
let mode_flag_mask_of_int64 mask : mode_flag_mask option = let of_int = function 0 -> Some `Positive_h_sync | 1 -> Some `Negative_h_sync | 2 -> Some `Positive_v_sync | 3 -> Some `Negative_v_sync | 4 -> Some `Interlace | 5 -> Some `Composite_sync | 6 -> Some `Positive_c_sync | 7 -> Some `Negative_c_sync | 8 -> Some `H_skew | 9 -> Some `Broadcast | 10 -> Some `Pixmux | 11 -> Some `Double_clock | 12 -> Some `Half_clock | _ -> None in mask_of_int of_int mask;;
let mode_flag_int_of_mask : mode_flag_mask -> int = let to_bit = function `Positive_h_sync -> 0 | `Negative_h_sync -> 1 | `Positive_v_sync -> 2 | `Negative_v_sync -> 3 | `Interlace -> 4 | `Composite_sync -> 5 | `Positive_c_sync -> 6 | `Negative_c_sync -> 7 | `H_skew -> 8 | `Broadcast -> 9 | `Pixmux -> 10 | `Double_clock -> 11 | `Half_clock -> 12 in int_of_mask to_bit;;
type clock_flag_mask = [ `Programable ] list [@@deriving sexp];;
let clock_flag_mask_of_int64 mask : clock_flag_mask option = let of_int = function 0 -> Some `Programable | _ -> None in mask_of_int of_int mask;;
let clock_flag_int_of_mask : clock_flag_mask -> int = let to_bit = function `Programable -> 0 in int_of_mask to_bit;;
type permission_mask = [ `Read | `Write ] list [@@deriving sexp];;
let permission_mask_of_int64 mask : permission_mask option = let of_int = function 0 -> Some `Read | 1 -> Some `Write | _ -> None in mask_of_int of_int mask;;
let permission_int_of_mask : permission_mask -> int = let to_bit = function `Read -> 0 | `Write -> 1 in int_of_mask to_bit;;
type mode_info = { dotclock : dotclock; hdisplay : int; hsyncstart : int; hsyncend : int; htotal : int; hskew : int; vdisplay : int; vsyncstart : int; vsyncend : int; vtotal : int; flags : mode_flag_mask; privsize : int; } [@@deriving sexp];;
let decode_mode_info buf ~at : (mode_info * int) option = let orig = at in let* dotclock, at = decode_dotclock buf ~at in
let* hdisplay, at = decode_uint16 buf ~at in
let* hsyncstart, at = decode_uint16 buf ~at in
let* hsyncend, at = decode_uint16 buf ~at in
let* htotal, at = decode_uint16 buf ~at in
let* hskew, at = decode_int32 buf ~at in
let* vdisplay, at = decode_uint16 buf ~at in
let* vsyncstart, at = decode_uint16 buf ~at in
let* vsyncend, at = decode_uint16 buf ~at in
let* vtotal, at = decode_uint16 buf ~at in
let at = at + 4 in
let* flags, at = decode_mask decode_int32 Int64.of_int mode_flag_mask_of_int64 buf ~at in
let at = at + 12 in
let* privsize, at = decode_int32 buf ~at in
ignore orig;
Some ({ dotclock; hdisplay; hsyncstart; hsyncend; htotal; hskew; vdisplay; vsyncstart; vsyncend; vtotal; flags; privsize }, at);;
let encode_mode_info buf (v : mode_info) ~at : int option = let orig = at in let* at = encode_dotclock buf v.dotclock ~at in let* at = encode_uint16 buf v.hdisplay ~at in let* at = encode_uint16 buf v.hsyncstart ~at in let* at = encode_uint16 buf v.hsyncend ~at in let* at = encode_uint16 buf v.htotal ~at in let* at = encode_int32 buf v.hskew ~at in let* at = encode_uint16 buf v.vdisplay ~at in let* at = encode_uint16 buf v.vsyncstart ~at in let* at = encode_uint16 buf v.vsyncend ~at in let* at = encode_uint16 buf v.vtotal ~at in let at = at + 4 in let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf v.flags ~at in let at = at + 12 in let* at = encode_int32 buf v.privsize ~at in ignore orig; Some at;;

type query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_query_version  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
type get_mode_line_reply = { dotclock : dotclock; hdisplay : int; hsyncstart : int; hsyncend : int; htotal : int; hskew : int; vdisplay : int; vsyncstart : int; vsyncend : int; vtotal : int; flags : mode_flag_mask; private_ : int list; } [@@deriving sexp];;
let encode_get_mode_line ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_mode_line_reply length buf ~at : (get_mode_line_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* dotclock, at = decode_dotclock buf ~at in
let* hdisplay, at = decode_uint16 buf ~at in
let* hsyncstart, at = decode_uint16 buf ~at in
let* hsyncend, at = decode_uint16 buf ~at in
let* htotal, at = decode_uint16 buf ~at in
let* hskew, at = decode_uint16 buf ~at in
let* vdisplay, at = decode_uint16 buf ~at in
let* vsyncstart, at = decode_uint16 buf ~at in
let* vsyncend, at = decode_uint16 buf ~at in
let* vtotal, at = decode_uint16 buf ~at in
let at = at + 2 in
let* flags, at = decode_mask decode_int32 Int64.of_int mode_flag_mask_of_int64 buf ~at in
let at = at + 12 in
let* privsize, at = decode_int32 buf ~at in let privsize = privsize in
let* private_, at = decode_list (decode_uint8) privsize buf ~at in
ignore orig;
Some ({ dotclock; hdisplay; hsyncstart; hsyncend; htotal; hskew; vdisplay; vsyncstart; vsyncend; vtotal; flags; private_ }, at);;
let encode_mod_mode_line ~(screen : int) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf hdisplay ~at in
let* at = encode_uint16 buf hsyncstart ~at in
let* at = encode_uint16 buf hsyncend ~at in
let* at = encode_uint16 buf htotal ~at in
let* at = encode_uint16 buf hskew ~at in
let* at = encode_uint16 buf vdisplay ~at in
let* at = encode_uint16 buf vsyncstart ~at in
let* at = encode_uint16 buf vsyncend ~at in
let* at = encode_uint16 buf vtotal ~at in
let at = at + 2 in
let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf flags ~at in
let at = at + 12 in
let* at = encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_)) ~at in
let* at = encode_list encode_uint8 buf private_ ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_switch_mode ~(screen : int) ~(zoom : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf zoom ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_monitor_reply = { hsync : syncrange list; vsync : syncrange list; vendor : string; alignment_pad : string; model : string; } [@@deriving sexp];;
let encode_get_monitor ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_monitor_reply length buf ~at : (get_monitor_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* vendor_length, at = decode_uint8 buf ~at in let vendor_length = vendor_length in
let* model_length, at = decode_uint8 buf ~at in let model_length = model_length in
let* num_hsync, at = decode_uint8 buf ~at in let num_hsync = num_hsync in
let* num_vsync, at = decode_uint8 buf ~at in let num_vsync = num_vsync in
let at = at + 20 in
let* hsync, at = decode_list (decode_syncrange) num_hsync buf ~at in
let* vsync, at = decode_list (decode_syncrange) num_vsync buf ~at in
let* vendor, at = decode_string vendor_length buf ~at in
let* alignment_pad, at = let length = (((vendor_length) + (3)) land (lnot (3))) - (vendor_length) in decode_string length buf ~at in
let* model, at = decode_string model_length buf ~at in
ignore orig;
Some ({ hsync; vsync; vendor; alignment_pad; model }, at);;
let encode_lock_mode_switch ~(screen : int) ~(lock : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf lock ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_all_mode_lines_reply = { modeinfo : mode_info list; } [@@deriving sexp];;
let encode_get_all_mode_lines ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_all_mode_lines_reply length buf ~at : (get_all_mode_lines_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* modecount, at = decode_int32 buf ~at in let modecount = modecount in
let at = at + 20 in
let* modeinfo, at = decode_list (decode_mode_info) modecount buf ~at in
ignore orig;
Some ({ modeinfo }, at);;
let encode_add_mode_line ~(screen : int) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(after_dotclock : dotclock) ~(after_hdisplay : int) ~(after_hsyncstart : int) ~(after_hsyncend : int) ~(after_htotal : int) ~(after_hskew : int) ~(after_vdisplay : int) ~(after_vsyncstart : int) ~(after_vsyncend : int) ~(after_vtotal : int) ~(after_flags : mode_flag_mask) ~(private_ : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_dotclock buf dotclock ~at in
let* at = encode_uint16 buf hdisplay ~at in
let* at = encode_uint16 buf hsyncstart ~at in
let* at = encode_uint16 buf hsyncend ~at in
let* at = encode_uint16 buf htotal ~at in
let* at = encode_uint16 buf hskew ~at in
let* at = encode_uint16 buf vdisplay ~at in
let* at = encode_uint16 buf vsyncstart ~at in
let* at = encode_uint16 buf vsyncend ~at in
let* at = encode_uint16 buf vtotal ~at in
let at = at + 2 in
let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf flags ~at in
let at = at + 12 in
let* at = encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_)) ~at in
let* at = encode_dotclock buf after_dotclock ~at in
let* at = encode_uint16 buf after_hdisplay ~at in
let* at = encode_uint16 buf after_hsyncstart ~at in
let* at = encode_uint16 buf after_hsyncend ~at in
let* at = encode_uint16 buf after_htotal ~at in
let* at = encode_uint16 buf after_hskew ~at in
let* at = encode_uint16 buf after_vdisplay ~at in
let* at = encode_uint16 buf after_vsyncstart ~at in
let* at = encode_uint16 buf after_vsyncend ~at in
let* at = encode_uint16 buf after_vtotal ~at in
let at = at + 2 in
let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf after_flags ~at in
let at = at + 12 in
let* at = encode_list encode_uint8 buf private_ ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_mode_line ~(screen : int) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_dotclock buf dotclock ~at in
let* at = encode_uint16 buf hdisplay ~at in
let* at = encode_uint16 buf hsyncstart ~at in
let* at = encode_uint16 buf hsyncend ~at in
let* at = encode_uint16 buf htotal ~at in
let* at = encode_uint16 buf hskew ~at in
let* at = encode_uint16 buf vdisplay ~at in
let* at = encode_uint16 buf vsyncstart ~at in
let* at = encode_uint16 buf vsyncend ~at in
let* at = encode_uint16 buf vtotal ~at in
let at = at + 2 in
let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf flags ~at in
let at = at + 12 in
let* at = encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_)) ~at in
let* at = encode_list encode_uint8 buf private_ ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type validate_mode_line_reply = { status : int; } [@@deriving sexp];;
let encode_validate_mode_line ~(screen : int) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_dotclock buf dotclock ~at in
let* at = encode_uint16 buf hdisplay ~at in
let* at = encode_uint16 buf hsyncstart ~at in
let* at = encode_uint16 buf hsyncend ~at in
let* at = encode_uint16 buf htotal ~at in
let* at = encode_uint16 buf hskew ~at in
let* at = encode_uint16 buf vdisplay ~at in
let* at = encode_uint16 buf vsyncstart ~at in
let* at = encode_uint16 buf vsyncend ~at in
let* at = encode_uint16 buf vtotal ~at in
let at = at + 2 in
let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf flags ~at in
let at = at + 12 in
let* at = encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_)) ~at in
let* at = encode_list encode_uint8 buf private_ ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_validate_mode_line_reply length buf ~at : (validate_mode_line_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* status, at = decode_int32 buf ~at in
let at = at + 20 in
ignore orig;
Some ({ status }, at);;
let encode_switch_to_mode ~(screen : int) ~(dotclock : dotclock) ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_int32 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_dotclock buf dotclock ~at in
let* at = encode_uint16 buf hdisplay ~at in
let* at = encode_uint16 buf hsyncstart ~at in
let* at = encode_uint16 buf hsyncend ~at in
let* at = encode_uint16 buf htotal ~at in
let* at = encode_uint16 buf hskew ~at in
let* at = encode_uint16 buf vdisplay ~at in
let* at = encode_uint16 buf vsyncstart ~at in
let* at = encode_uint16 buf vsyncend ~at in
let* at = encode_uint16 buf vtotal ~at in
let at = at + 2 in
let* at = encode_mask encode_int32 identity mode_flag_int_of_mask buf flags ~at in
let at = at + 12 in
let* at = encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_)) ~at in
let* at = encode_list encode_uint8 buf private_ ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_view_port_reply = { x : int; y : int; } [@@deriving sexp];;
let encode_get_view_port ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_view_port_reply length buf ~at : (get_view_port_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* x, at = decode_int32 buf ~at in
let* y, at = decode_int32 buf ~at in
let at = at + 16 in
ignore orig;
Some ({ x; y }, at);;
let encode_set_view_port ~(screen : int) ~(x : int) ~(y : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
let* at = encode_int32 buf x ~at in
let* at = encode_int32 buf y ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_dot_clocks_reply = { flags : clock_flag_mask; clocks : int; maxclocks : int; clock : int list; } [@@deriving sexp];;
let encode_get_dot_clocks ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_dot_clocks_reply length buf ~at : (get_dot_clocks_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* flags, at = decode_mask decode_int32 Int64.of_int clock_flag_mask_of_int64 buf ~at in
let* clocks, at = decode_int32 buf ~at in
let* maxclocks, at = decode_int32 buf ~at in
let at = at + 12 in
let* clock, at = let length = ((1) - ((flags) land (1))) * (clocks) in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ flags; clocks; maxclocks; clock }, at);;
let encode_set_client_version ~(major : int) ~(minor : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_uint16 buf major ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf minor ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_set_gamma ~(screen : int) ~(red : int) ~(green : int) ~(blue : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
let* at = encode_int32 buf red ~at in
let* at = encode_int32 buf green ~at in
let* at = encode_int32 buf blue ~at in
let at = at + 12 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_gamma_reply = { red : int; green : int; blue : int; } [@@deriving sexp];;
let encode_get_gamma ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 26 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_gamma_reply length buf ~at : (get_gamma_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* red, at = decode_int32 buf ~at in
let* green, at = decode_int32 buf ~at in
let* blue, at = decode_int32 buf ~at in
let at = at + 12 in
ignore orig;
Some ({ red; green; blue }, at);;
type get_gamma_ramp_reply = { size : int; red : int list; green : int list; blue : int list; } [@@deriving sexp];;
let encode_get_gamma_ramp ~(screen : int) ~(size : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf size ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_gamma_ramp_reply length buf ~at : (get_gamma_ramp_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* size, at = decode_uint16 buf ~at in
let at = at + 22 in
let* red, at = let length = ((size) + (1)) land (lnot (1)) in decode_list (decode_uint16) length buf ~at in
let* green, at = let length = ((size) + (1)) land (lnot (1)) in decode_list (decode_uint16) length buf ~at in
let* blue, at = let length = ((size) + (1)) land (lnot (1)) in decode_list (decode_uint16) length buf ~at in
ignore orig;
Some ({ size; red; green; blue }, at);;
let encode_set_gamma_ramp ~(screen : int) ~(size : int) ~(red : int list) ~(green : int list) ~(blue : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf size ~at in
let* at = encode_list encode_uint16 buf red ~at in
let* at = encode_list encode_uint16 buf green ~at in
let* at = encode_list encode_uint16 buf blue ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_gamma_ramp_size_reply = { size : int; } [@@deriving sexp];;
let encode_get_gamma_ramp_size ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_gamma_ramp_size_reply length buf ~at : (get_gamma_ramp_size_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* size, at = decode_uint16 buf ~at in
let at = at + 22 in
ignore orig;
Some ({ size }, at);;
type get_permissions_reply = { permissions : permission_mask; } [@@deriving sexp];;
let encode_get_permissions ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_uint16 buf screen ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_permissions_reply length buf ~at : (get_permissions_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* permissions, at = decode_mask decode_int32 Int64.of_int permission_mask_of_int64 buf ~at in
let at = at + 20 in
ignore orig;
Some ({ permissions }, at);;
type bad_clock_error = unit [@@deriving sexp];;
type bad_h_timings_error = unit [@@deriving sexp];;
type bad_v_timings_error = unit [@@deriving sexp];;
type mode_unsuitable_error = unit [@@deriving sexp];;
type extension_disabled_error = unit [@@deriving sexp];;
type client_not_local_error = unit [@@deriving sexp];;
type zoom_locked_error = unit [@@deriving sexp];;
end
module[@warning "-27"] Xinerama = struct
type screen_info = { x_org : int; y_org : int; width : int; height : int; } [@@deriving sexp];;
let decode_screen_info buf ~at : (screen_info * int) option = let orig = at in let* x_org, at = decode_int16 buf ~at in
let* y_org, at = decode_int16 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ x_org; y_org; width; height }, at);;
let encode_screen_info buf (v : screen_info) ~at : int option = let orig = at in let* at = encode_int16 buf v.x_org ~at in let* at = encode_int16 buf v.y_org ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in ignore orig; Some at;;

type query_version_reply = { major : int; minor : int; } [@@deriving sexp];;
let encode_query_version ~(major : int) ~(minor : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint8 buf major ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf minor ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major, at = decode_uint16 buf ~at in
let* minor, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major; minor }, at);;
type get_state_reply = { state : char; window : Xproto.window; } [@@deriving sexp];;
let encode_get_state ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_state_reply length buf ~at : (get_state_reply * int) option = let orig = at in let at = at + 1 in
let* state, at = decode_char buf ~at in
let at = at + 6 in
let* window, at = Xproto.decode_window buf ~at in
ignore orig;
Some ({ state; window }, at);;
type get_screen_count_reply = { screen_count : char; window : Xproto.window; } [@@deriving sexp];;
let encode_get_screen_count ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_count_reply length buf ~at : (get_screen_count_reply * int) option = let orig = at in let at = at + 1 in
let* screen_count, at = decode_char buf ~at in
let at = at + 6 in
let* window, at = Xproto.decode_window buf ~at in
ignore orig;
Some ({ screen_count; window }, at);;
type get_screen_size_reply = { width : int; height : int; window : Xproto.window; screen : int; } [@@deriving sexp];;
let encode_get_screen_size ~(window : Xproto.window) ~(screen : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf screen ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_screen_size_reply length buf ~at : (get_screen_size_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let* window, at = Xproto.decode_window buf ~at in
let* screen, at = decode_int32 buf ~at in
ignore orig;
Some ({ width; height; window; screen }, at);;
type is_active_reply = { state : int; } [@@deriving sexp];;
let encode_is_active  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_is_active_reply length buf ~at : (is_active_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* state, at = decode_int32 buf ~at in
ignore orig;
Some ({ state }, at);;
type query_screens_reply = { screen_info : screen_info list; } [@@deriving sexp];;
let encode_query_screens  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_screens_reply length buf ~at : (query_screens_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* number, at = decode_int32 buf ~at in let number = number in
let at = at + 20 in
let* screen_info, at = decode_list (decode_screen_info) number buf ~at in
ignore orig;
Some ({ screen_info }, at);;
end
module[@warning "-27"] Xinput = struct
type event_class = int [@@deriving sexp];;
let decode_event_class = decode_int32;;
let encode_event_class = encode_int32;;

type key_code = int [@@deriving sexp];;
let decode_key_code = decode_uint8;;
let encode_key_code = encode_uint8;;

type device_id = int [@@deriving sexp];;
let decode_device_id = decode_uint16;;
let encode_device_id = encode_uint16;;

type fp1616 = int [@@deriving sexp];;
let decode_fp1616 = decode_int32;;
let encode_fp1616 = encode_int32;;

type fp3232 = { integral : int; frac : int; } [@@deriving sexp];;
let decode_fp3232 buf ~at : (fp3232 * int) option = let orig = at in let* integral, at = decode_int32 buf ~at in
let* frac, at = decode_int32 buf ~at in
ignore orig;
Some ({ integral; frac }, at);;
let encode_fp3232 buf (v : fp3232) ~at : int option = let orig = at in let* at = encode_int32 buf v.integral ~at in let* at = encode_int32 buf v.frac ~at in ignore orig; Some at;;

type get_extension_version_reply = { xi_reply_type : int; server_major : int; server_minor : int; present : bool; } [@@deriving sexp];;
let encode_get_extension_version ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_uint16 buf (identity (String.length name)) ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_extension_version_reply length buf ~at : (get_extension_version_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* server_major, at = decode_uint16 buf ~at in
let* server_minor, at = decode_uint16 buf ~at in
let* present, at = decode_bool buf ~at in
let at = at + 19 in
ignore orig;
Some ({ xi_reply_type; server_major; server_minor; present }, at);;
type device_use_enum = [ `Is_x_pointer | `Is_x_keyboard | `Is_x_extension_device | `Is_x_extension_keyboard | `Is_x_extension_pointer ] [@@deriving sexp];;
let device_use_enum_of_int : int -> [> device_use_enum ] option = function 0 -> Some `Is_x_pointer | 1 -> Some `Is_x_keyboard | 2 -> Some `Is_x_extension_device | 3 -> Some `Is_x_extension_keyboard | 4 -> Some `Is_x_extension_pointer | n -> Printf.printf "unknown device_use_enum: %d\n" n; None;;
let device_use_int_of_enum : device_use_enum -> int = function `Is_x_pointer -> 0 | `Is_x_keyboard -> 1 | `Is_x_extension_device -> 2 | `Is_x_extension_keyboard -> 3 | `Is_x_extension_pointer -> 4;;
type input_class_enum = [ `Key | `Button | `Valuator | `Feedback | `Proximity | `Focus | `Other ] [@@deriving sexp];;
let input_class_enum_of_int : int -> [> input_class_enum ] option = function 0 -> Some `Key | 1 -> Some `Button | 2 -> Some `Valuator | 3 -> Some `Feedback | 4 -> Some `Proximity | 5 -> Some `Focus | 6 -> Some `Other | n -> Printf.printf "unknown input_class_enum: %d\n" n; None;;
let input_class_int_of_enum : input_class_enum -> int = function `Key -> 0 | `Button -> 1 | `Valuator -> 2 | `Feedback -> 3 | `Proximity -> 4 | `Focus -> 5 | `Other -> 6;;
type valuator_mode_enum = [ `Relative | `Absolute ] [@@deriving sexp];;
let valuator_mode_enum_of_int : int -> [> valuator_mode_enum ] option = function 0 -> Some `Relative | 1 -> Some `Absolute | n -> Printf.printf "unknown valuator_mode_enum: %d\n" n; None;;
let valuator_mode_int_of_enum : valuator_mode_enum -> int = function `Relative -> 0 | `Absolute -> 1;;
type device_info = { device_type : Xproto.atom; device_id : int; num_class_info : int; device_use : device_use_enum; } [@@deriving sexp];;
let decode_device_info buf ~at : (device_info * int) option = let orig = at in let* device_type, at = Xproto.decode_atom buf ~at in
let* device_id, at = decode_uint8 buf ~at in
let* num_class_info, at = decode_uint8 buf ~at in
let* device_use, at = decode_enum decode_uint8 identity device_use_enum_of_int buf ~at in
let at = at + 1 in
ignore orig;
Some ({ device_type; device_id; num_class_info; device_use }, at);;
let encode_device_info buf (v : device_info) ~at : int option = let orig = at in let* at = Xproto.encode_atom buf v.device_type ~at in let* at = encode_uint8 buf v.device_id ~at in let* at = encode_uint8 buf v.num_class_info ~at in let* at = encode_enum encode_uint8 identity device_use_int_of_enum buf v.device_use ~at in let at = at + 1 in ignore orig; Some at;;

type key_info = { class_id : input_class_enum; len : int; min_keycode : key_code; max_keycode : key_code; num_keys : int; } [@@deriving sexp];;
let decode_key_info buf ~at : (key_info * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* len, at = decode_uint8 buf ~at in
let* min_keycode, at = decode_key_code buf ~at in
let* max_keycode, at = decode_key_code buf ~at in
let* num_keys, at = decode_uint16 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ class_id; len; min_keycode; max_keycode; num_keys }, at);;
let encode_key_info buf (v : key_info) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.len ~at in let* at = encode_key_code buf v.min_keycode ~at in let* at = encode_key_code buf v.max_keycode ~at in let* at = encode_uint16 buf v.num_keys ~at in let at = at + 2 in ignore orig; Some at;;

type button_info = { class_id : input_class_enum; len : int; num_buttons : int; } [@@deriving sexp];;
let decode_button_info buf ~at : (button_info * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* len, at = decode_uint8 buf ~at in
let* num_buttons, at = decode_uint16 buf ~at in
ignore orig;
Some ({ class_id; len; num_buttons }, at);;
let encode_button_info buf (v : button_info) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.len ~at in let* at = encode_uint16 buf v.num_buttons ~at in ignore orig; Some at;;

type axis_info = { resolution : int; minimum : int; maximum : int; } [@@deriving sexp];;
let decode_axis_info buf ~at : (axis_info * int) option = let orig = at in let* resolution, at = decode_int32 buf ~at in
let* minimum, at = decode_int32 buf ~at in
let* maximum, at = decode_int32 buf ~at in
ignore orig;
Some ({ resolution; minimum; maximum }, at);;
let encode_axis_info buf (v : axis_info) ~at : int option = let orig = at in let* at = encode_int32 buf v.resolution ~at in let* at = encode_int32 buf v.minimum ~at in let* at = encode_int32 buf v.maximum ~at in ignore orig; Some at;;

type valuator_info = { class_id : input_class_enum; len : int; mode : valuator_mode_enum; motion_size : int; axes : axis_info list; } [@@deriving sexp];;
let decode_valuator_info buf ~at : (valuator_info * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* len, at = decode_uint8 buf ~at in
let* axes_len, at = decode_uint8 buf ~at in let axes_len = axes_len in
let* mode, at = decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at in
let* motion_size, at = decode_int32 buf ~at in
let* axes, at = decode_list (decode_axis_info) axes_len buf ~at in
ignore orig;
Some ({ class_id; len; mode; motion_size; axes }, at);;
let encode_valuator_info buf (v : valuator_info) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.len ~at in let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length v.axes)) ~at in let* at = encode_enum encode_uint8 identity valuator_mode_int_of_enum buf v.mode ~at in let* at = encode_int32 buf v.motion_size ~at in let* at = encode_list encode_axis_info buf v.axes ~at in ignore orig; Some at;;

type input_class_variant = Key of { min_keycode : key_code; max_keycode : key_code; num_keys : int; } | Button of { num_buttons : int; } | Valuator of { mode : valuator_mode_enum; motion_size : int; axes : axis_info list; } [@@deriving sexp];;
type input_info = { len : int; info : input_class_variant; } [@@deriving sexp];;
let decode_input_info buf ~at : (input_info * int) option = let orig = at in 
let* len, at = decode_uint8 buf ~at in

ignore orig;
Some ({ len; info }, at);;
let encode_input_info buf (v : input_info) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint8 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

type device_name = { string : string; } [@@deriving sexp];;
let decode_device_name buf ~at : (device_name * int) option = let orig = at in let* len, at = decode_uint8 buf ~at in let len = len in
let* string, at = decode_string len buf ~at in
ignore orig;
Some ({ string }, at);;
let encode_device_name buf (v : device_name) ~at : int option = let orig = at in let* at = encode_uint8 buf (identity (String.length v.string)) ~at in let* at = encode_string buf v.string ~at in ignore orig; Some at;;

type list_input_devices_reply = { xi_reply_type : int; devices : device_info list; infos : input_info list; names : Xproto.str list; } [@@deriving sexp];;
let encode_list_input_devices  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_input_devices_reply length buf ~at : (list_input_devices_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* devices_len, at = decode_uint8 buf ~at in let devices_len = devices_len in
let at = at + 23 in
let* devices, at = decode_list (decode_device_info) devices_len buf ~at in
let* infos, at = let length = List.fold_left (fun acc list_element_ref -> acc + (list_element_ref.num_class_info)) 0 devices in decode_list (decode_input_info) length buf ~at in
let* names, at = decode_list (Xproto.decode_str) devices_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ xi_reply_type; devices; infos; names }, at);;
type event_type_base = int [@@deriving sexp];;
let decode_event_type_base = decode_uint8;;
let encode_event_type_base = encode_uint8;;

type input_class_info = { class_id : input_class_enum; event_type_base : event_type_base; } [@@deriving sexp];;
let decode_input_class_info buf ~at : (input_class_info * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* event_type_base, at = decode_event_type_base buf ~at in
ignore orig;
Some ({ class_id; event_type_base }, at);;
let encode_input_class_info buf (v : input_class_info) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_event_type_base buf v.event_type_base ~at in ignore orig; Some at;;

type open_device_reply = { xi_reply_type : int; class_info : input_class_info list; } [@@deriving sexp];;
let encode_open_device ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_open_device_reply length buf ~at : (open_device_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_classes, at = decode_uint8 buf ~at in let num_classes = num_classes in
let at = at + 23 in
let* class_info, at = decode_list (decode_input_class_info) num_classes buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ xi_reply_type; class_info }, at);;
let encode_close_device ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type set_device_mode_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; } [@@deriving sexp];;
let encode_set_device_mode ~(device_id : int) ~(mode : valuator_mode_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity valuator_mode_int_of_enum buf mode ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_device_mode_reply length buf ~at : (set_device_mode_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
let encode_select_extension_event ~(window : Xproto.window) ~(classes : event_class list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes)) ~at in
let at = at + 2 in
let* at = encode_list encode_event_class buf classes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_selected_extension_events_reply = { xi_reply_type : int; this_classes : event_class list; all_classes : event_class list; } [@@deriving sexp];;
let encode_get_selected_extension_events ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_selected_extension_events_reply length buf ~at : (get_selected_extension_events_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_this_classes, at = decode_uint16 buf ~at in let num_this_classes = num_this_classes in
let* num_all_classes, at = decode_uint16 buf ~at in let num_all_classes = num_all_classes in
let at = at + 20 in
let* this_classes, at = decode_list (decode_event_class) num_this_classes buf ~at in
let* all_classes, at = decode_list (decode_event_class) num_all_classes buf ~at in
ignore orig;
Some ({ xi_reply_type; this_classes; all_classes }, at);;
type propagate_mode_enum = [ `Add_to_list | `Delete_from_list ] [@@deriving sexp];;
let propagate_mode_enum_of_int : int -> [> propagate_mode_enum ] option = function 0 -> Some `Add_to_list | 1 -> Some `Delete_from_list | n -> Printf.printf "unknown propagate_mode_enum: %d\n" n; None;;
let propagate_mode_int_of_enum : propagate_mode_enum -> int = function `Add_to_list -> 0 | `Delete_from_list -> 1;;
let encode_change_device_dont_propagate_list ~(window : Xproto.window) ~(mode : propagate_mode_enum) ~(classes : event_class list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes)) ~at in
let* at = encode_enum encode_uint8 identity propagate_mode_int_of_enum buf mode ~at in
let at = at + 1 in
let* at = encode_list encode_event_class buf classes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_dont_propagate_list_reply = { xi_reply_type : int; classes : event_class list; } [@@deriving sexp];;
let encode_get_device_dont_propagate_list ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_dont_propagate_list_reply length buf ~at : (get_device_dont_propagate_list_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_classes, at = decode_uint16 buf ~at in let num_classes = num_classes in
let at = at + 22 in
let* classes, at = decode_list (decode_event_class) num_classes buf ~at in
ignore orig;
Some ({ xi_reply_type; classes }, at);;
type device_time_coord = { time : Xproto.timestamp; axisvalues : int list; } [@@deriving sexp];;
let decode_device_time_coord buf ~at : (device_time_coord * int) option = let orig = at in let* time, at = Xproto.decode_timestamp buf ~at in
let* axisvalues, at = let length = num_axes in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ time; axisvalues }, at);;
let encode_device_time_coord buf (v : device_time_coord) ~at : int option = let orig = at in let* at = Xproto.encode_timestamp buf v.time ~at in let* at = encode_list encode_int32 buf v.axisvalues ~at in ignore orig; Some at;;

type get_device_motion_events_reply = { xi_reply_type : int; num_axes : int; device_mode : valuator_mode_enum; events : device_time_coord list; } [@@deriving sexp];;
let encode_get_device_motion_events ~(start : Xproto.timestamp) ~(stop : Xproto.time_enum alt_enum) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = Xproto.encode_timestamp buf start ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf stop ~at in
let* at = encode_uint8 buf device_id ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_motion_events_reply length buf ~at : (get_device_motion_events_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_events, at = decode_int32 buf ~at in let num_events = num_events in
let* num_axes, at = decode_uint8 buf ~at in
let* device_mode, at = decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at in
let at = at + 18 in
let* events, at = decode_list (decode_device_time_coord) num_events buf ~at in
ignore orig;
Some ({ xi_reply_type; num_axes; device_mode; events }, at);;
type change_keyboard_device_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; } [@@deriving sexp];;
let encode_change_keyboard_device ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_change_keyboard_device_reply length buf ~at : (change_keyboard_device_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
type change_pointer_device_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; } [@@deriving sexp];;
let encode_change_pointer_device ~(x_axis : int) ~(y_axis : int) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_uint8 buf x_axis ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf y_axis ~at in
let* at = encode_uint8 buf device_id ~at in
let at = at + 1 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_change_pointer_device_reply length buf ~at : (change_pointer_device_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
type grab_device_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; } [@@deriving sexp];;
let encode_grab_device ~(grab_window : Xproto.window) ~(time : Xproto.time_enum alt_enum) ~(this_device_mode : Xproto.grab_mode_enum) ~(other_device_mode : Xproto.grab_mode_enum) ~(owner_events : bool) ~(device_id : int) ~(classes : event_class list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes)) ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf this_device_mode ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf other_device_mode ~at in
let* at = encode_bool buf owner_events ~at in
let* at = encode_uint8 buf device_id ~at in
let at = at + 2 in
let* at = encode_list encode_event_class buf classes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_grab_device_reply length buf ~at : (grab_device_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
let encode_ungrab_device ~(time : Xproto.time_enum alt_enum) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf device_id ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type modifier_device_enum = [ `Use_x_keyboard ] [@@deriving sexp];;
let modifier_device_enum_of_int : int -> [> modifier_device_enum ] option = function 255 -> Some `Use_x_keyboard | n -> Printf.printf "unknown modifier_device_enum: %d\n" n; None;;
let modifier_device_int_of_enum : modifier_device_enum -> int = function `Use_x_keyboard -> 255;;
let encode_grab_device_key ~(grab_window : Xproto.window) ~(modifiers : Xproto.mod_mask) ~(modifier_device : modifier_device_enum alt_enum) ~(grabbed_device : int) ~(key : Xproto.grab_enum alt_enum) ~(this_device_mode : Xproto.grab_mode_enum) ~(other_device_mode : Xproto.grab_mode_enum) ~(owner_events : bool) ~(classes : event_class list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes)) ~at in
let* at = encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers ~at in
let* at = encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf modifier_device ~at in
let* at = encode_uint8 buf grabbed_device ~at in
let* at = encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf key ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf this_device_mode ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf other_device_mode ~at in
let* at = encode_bool buf owner_events ~at in
let at = at + 2 in
let* at = encode_list encode_event_class buf classes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_ungrab_device_key ~(grab_window : Xproto.window) ~(modifiers : Xproto.mod_mask) ~(modifier_device : modifier_device_enum alt_enum) ~(key : Xproto.grab_enum alt_enum) ~(grabbed_device : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers ~at in
let* at = encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf modifier_device ~at in
let* at = encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf key ~at in
let* at = encode_uint8 buf grabbed_device ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_grab_device_button ~(grab_window : Xproto.window) ~(grabbed_device : int) ~(modifier_device : modifier_device_enum alt_enum) ~(modifiers : Xproto.mod_mask) ~(this_device_mode : Xproto.grab_mode_enum) ~(other_device_mode : Xproto.grab_mode_enum) ~(button : Xproto.grab_enum alt_enum) ~(owner_events : bool) ~(classes : event_class list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf grabbed_device ~at in
let* at = encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf modifier_device ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes)) ~at in
let* at = encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf this_device_mode ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf other_device_mode ~at in
let* at = encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf button ~at in
let* at = encode_bool buf owner_events ~at in
let at = at + 2 in
let* at = encode_list encode_event_class buf classes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_ungrab_device_button ~(grab_window : Xproto.window) ~(modifiers : Xproto.mod_mask) ~(modifier_device : modifier_device_enum alt_enum) ~(button : Xproto.grab_enum alt_enum) ~(grabbed_device : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers ~at in
let* at = encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf modifier_device ~at in
let* at = encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf button ~at in
let* at = encode_uint8 buf grabbed_device ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type device_input_mode_enum = [ `Async_this_device | `Sync_this_device | `Replay_this_device | `Async_other_devices | `Async_all | `Sync_all ] [@@deriving sexp];;
let device_input_mode_enum_of_int : int -> [> device_input_mode_enum ] option = function 0 -> Some `Async_this_device | 1 -> Some `Sync_this_device | 2 -> Some `Replay_this_device | 3 -> Some `Async_other_devices | 4 -> Some `Async_all | 5 -> Some `Sync_all | n -> Printf.printf "unknown device_input_mode_enum: %d\n" n; None;;
let device_input_mode_int_of_enum : device_input_mode_enum -> int = function `Async_this_device -> 0 | `Sync_this_device -> 1 | `Replay_this_device -> 2 | `Async_other_devices -> 3 | `Async_all -> 4 | `Sync_all -> 5;;
let encode_allow_device_events ~(time : Xproto.time_enum alt_enum) ~(mode : device_input_mode_enum) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity device_input_mode_int_of_enum buf mode ~at in
let* at = encode_uint8 buf device_id ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_focus_reply = { xi_reply_type : int; focus : Xproto.input_focus_enum alt_enum; time : Xproto.timestamp; revert_to : Xproto.input_focus_enum; } [@@deriving sexp];;
let encode_get_device_focus ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_focus_reply length buf ~at : (get_device_focus_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* focus, at = decode_alt_enum Xproto.decode_window identity Xproto.input_focus_enum_of_int buf ~at in
let* time, at = Xproto.decode_timestamp buf ~at in
let* revert_to, at = decode_enum decode_uint8 identity Xproto.input_focus_enum_of_int buf ~at in
let at = at + 15 in
ignore orig;
Some ({ xi_reply_type; focus; time; revert_to }, at);;
let encode_set_device_focus ~(focus : Xproto.input_focus_enum alt_enum) ~(time : Xproto.time_enum alt_enum) ~(revert_to : Xproto.input_focus_enum) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let* at = encode_alt_enum Xproto.encode_window identity Xproto.input_focus_int_of_enum buf focus ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
let* at = encode_enum encode_uint8 identity Xproto.input_focus_int_of_enum buf revert_to ~at in
let* at = encode_uint8 buf device_id ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type feedback_class_enum = [ `Keyboard | `Pointer | `String | `Integer | `Led | `Bell ] [@@deriving sexp];;
let feedback_class_enum_of_int : int -> [> feedback_class_enum ] option = function 0 -> Some `Keyboard | 1 -> Some `Pointer | 2 -> Some `String | 3 -> Some `Integer | 4 -> Some `Led | 5 -> Some `Bell | n -> Printf.printf "unknown feedback_class_enum: %d\n" n; None;;
let feedback_class_int_of_enum : feedback_class_enum -> int = function `Keyboard -> 0 | `Pointer -> 1 | `String -> 2 | `Integer -> 3 | `Led -> 4 | `Bell -> 5;;
type kbd_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; pitch : int; duration : int; led_mask : int; led_values : int; global_auto_repeat : bool; click : int; percent : int; auto_repeats : int list; } [@@deriving sexp];;
let decode_kbd_feedback_state buf ~at : (kbd_feedback_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* pitch, at = decode_uint16 buf ~at in
let* duration, at = decode_uint16 buf ~at in
let* led_mask, at = decode_int32 buf ~at in
let* led_values, at = decode_int32 buf ~at in
let* global_auto_repeat, at = decode_bool buf ~at in
let* click, at = decode_uint8 buf ~at in
let* percent, at = decode_uint8 buf ~at in
let at = at + 1 in
let* auto_repeats, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; pitch; duration; led_mask; led_values; global_auto_repeat; click; percent; auto_repeats }, at);;
let encode_kbd_feedback_state buf (v : kbd_feedback_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint16 buf v.pitch ~at in let* at = encode_uint16 buf v.duration ~at in let* at = encode_int32 buf v.led_mask ~at in let* at = encode_int32 buf v.led_values ~at in let* at = encode_bool buf v.global_auto_repeat ~at in let* at = encode_uint8 buf v.click ~at in let* at = encode_uint8 buf v.percent ~at in let at = at + 1 in let* at = encode_list encode_uint8 buf v.auto_repeats ~at in ignore orig; Some at;;

type ptr_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; accel_num : int; accel_denom : int; threshold : int; } [@@deriving sexp];;
let decode_ptr_feedback_state buf ~at : (ptr_feedback_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let at = at + 2 in
let* accel_num, at = decode_uint16 buf ~at in
let* accel_denom, at = decode_uint16 buf ~at in
let* threshold, at = decode_uint16 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; accel_num; accel_denom; threshold }, at);;
let encode_ptr_feedback_state buf (v : ptr_feedback_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let at = at + 2 in let* at = encode_uint16 buf v.accel_num ~at in let* at = encode_uint16 buf v.accel_denom ~at in let* at = encode_uint16 buf v.threshold ~at in ignore orig; Some at;;

type integer_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; resolution : int; min_value : int; max_value : int; } [@@deriving sexp];;
let decode_integer_feedback_state buf ~at : (integer_feedback_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* resolution, at = decode_int32 buf ~at in
let* min_value, at = decode_int32 buf ~at in
let* max_value, at = decode_int32 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; resolution; min_value; max_value }, at);;
let encode_integer_feedback_state buf (v : integer_feedback_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.resolution ~at in let* at = encode_int32 buf v.min_value ~at in let* at = encode_int32 buf v.max_value ~at in ignore orig; Some at;;

type string_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; max_symbols : int; keysyms : Xproto.keysym list; } [@@deriving sexp];;
let decode_string_feedback_state buf ~at : (string_feedback_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* max_symbols, at = decode_uint16 buf ~at in
let* num_keysyms, at = decode_uint16 buf ~at in let num_keysyms = num_keysyms in
let* keysyms, at = decode_list (Xproto.decode_keysym) num_keysyms buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; max_symbols; keysyms }, at);;
let encode_string_feedback_state buf (v : string_feedback_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint16 buf v.max_symbols ~at in let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.keysyms)) ~at in let* at = encode_list Xproto.encode_keysym buf v.keysyms ~at in ignore orig; Some at;;

type bell_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; percent : int; pitch : int; duration : int; } [@@deriving sexp];;
let decode_bell_feedback_state buf ~at : (bell_feedback_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* percent, at = decode_uint8 buf ~at in
let at = at + 3 in
let* pitch, at = decode_uint16 buf ~at in
let* duration, at = decode_uint16 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; percent; pitch; duration }, at);;
let encode_bell_feedback_state buf (v : bell_feedback_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint8 buf v.percent ~at in let at = at + 3 in let* at = encode_uint16 buf v.pitch ~at in let* at = encode_uint16 buf v.duration ~at in ignore orig; Some at;;

type led_feedback_state = { class_id : feedback_class_enum; feedback_id : int; len : int; led_mask : int; led_values : int; } [@@deriving sexp];;
let decode_led_feedback_state buf ~at : (led_feedback_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* led_mask, at = decode_int32 buf ~at in
let* led_values, at = decode_int32 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; led_mask; led_values }, at);;
let encode_led_feedback_state buf (v : led_feedback_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.led_mask ~at in let* at = encode_int32 buf v.led_values ~at in ignore orig; Some at;;

type feedback_class_variant = Keyboard of { pitch : int; duration : int; led_mask : int; led_values : int; global_auto_repeat : bool; click : int; percent : int; auto_repeats : int list; } | Pointer of { accel_num : int; accel_denom : int; threshold : int; } | String of { max_symbols : int; keysyms : Xproto.keysym list; } | Integer of { resolution : int; min_value : int; max_value : int; } | Led of { led_mask : int; led_values : int; } | Bell of { percent : int; pitch : int; duration : int; } [@@deriving sexp];;
type feedback_state = { feedback_id : int; len : int; data : feedback_class_variant; } [@@deriving sexp];;
let decode_feedback_state buf ~at : (feedback_state * int) option = let orig = at in 
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in

ignore orig;
Some ({ feedback_id; len; data }, at);;
let encode_feedback_state buf (v : feedback_state) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

type get_feedback_control_reply = { xi_reply_type : int; feedbacks : feedback_state list; } [@@deriving sexp];;
let encode_get_feedback_control ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_feedback_control_reply length buf ~at : (get_feedback_control_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_feedbacks, at = decode_uint16 buf ~at in let num_feedbacks = num_feedbacks in
let at = at + 22 in
let* feedbacks, at = decode_list (decode_feedback_state) num_feedbacks buf ~at in
ignore orig;
Some ({ xi_reply_type; feedbacks }, at);;
type kbd_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; key : key_code; auto_repeat_mode : int; key_click_percent : int; bell_percent : int; bell_pitch : int; bell_duration : int; led_mask : int; led_values : int; } [@@deriving sexp];;
let decode_kbd_feedback_ctl buf ~at : (kbd_feedback_ctl * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* key, at = decode_key_code buf ~at in
let* auto_repeat_mode, at = decode_uint8 buf ~at in
let* key_click_percent, at = decode_int8 buf ~at in
let* bell_percent, at = decode_int8 buf ~at in
let* bell_pitch, at = decode_int16 buf ~at in
let* bell_duration, at = decode_int16 buf ~at in
let* led_mask, at = decode_int32 buf ~at in
let* led_values, at = decode_int32 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; key; auto_repeat_mode; key_click_percent; bell_percent; bell_pitch; bell_duration; led_mask; led_values }, at);;
let encode_kbd_feedback_ctl buf (v : kbd_feedback_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_key_code buf v.key ~at in let* at = encode_uint8 buf v.auto_repeat_mode ~at in let* at = encode_int8 buf v.key_click_percent ~at in let* at = encode_int8 buf v.bell_percent ~at in let* at = encode_int16 buf v.bell_pitch ~at in let* at = encode_int16 buf v.bell_duration ~at in let* at = encode_int32 buf v.led_mask ~at in let* at = encode_int32 buf v.led_values ~at in ignore orig; Some at;;

type ptr_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; num : int; denom : int; threshold : int; } [@@deriving sexp];;
let decode_ptr_feedback_ctl buf ~at : (ptr_feedback_ctl * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let at = at + 2 in
let* num, at = decode_int16 buf ~at in
let* denom, at = decode_int16 buf ~at in
let* threshold, at = decode_int16 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; num; denom; threshold }, at);;
let encode_ptr_feedback_ctl buf (v : ptr_feedback_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let at = at + 2 in let* at = encode_int16 buf v.num ~at in let* at = encode_int16 buf v.denom ~at in let* at = encode_int16 buf v.threshold ~at in ignore orig; Some at;;

type integer_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; int_to_display : int; } [@@deriving sexp];;
let decode_integer_feedback_ctl buf ~at : (integer_feedback_ctl * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* int_to_display, at = decode_int32 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; int_to_display }, at);;
let encode_integer_feedback_ctl buf (v : integer_feedback_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.int_to_display ~at in ignore orig; Some at;;

type string_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; keysyms : Xproto.keysym list; } [@@deriving sexp];;
let decode_string_feedback_ctl buf ~at : (string_feedback_ctl * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let at = at + 2 in
let* num_keysyms, at = decode_uint16 buf ~at in let num_keysyms = num_keysyms in
let* keysyms, at = decode_list (Xproto.decode_keysym) num_keysyms buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; keysyms }, at);;
let encode_string_feedback_ctl buf (v : string_feedback_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let at = at + 2 in let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.keysyms)) ~at in let* at = encode_list Xproto.encode_keysym buf v.keysyms ~at in ignore orig; Some at;;

type bell_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; percent : int; pitch : int; duration : int; } [@@deriving sexp];;
let decode_bell_feedback_ctl buf ~at : (bell_feedback_ctl * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* percent, at = decode_int8 buf ~at in
let at = at + 3 in
let* pitch, at = decode_int16 buf ~at in
let* duration, at = decode_int16 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; percent; pitch; duration }, at);;
let encode_bell_feedback_ctl buf (v : bell_feedback_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int8 buf v.percent ~at in let at = at + 3 in let* at = encode_int16 buf v.pitch ~at in let* at = encode_int16 buf v.duration ~at in ignore orig; Some at;;

type led_feedback_ctl = { class_id : feedback_class_enum; feedback_id : int; len : int; led_mask : int; led_values : int; } [@@deriving sexp];;
let decode_led_feedback_ctl buf ~at : (led_feedback_ctl * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at in
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in
let* led_mask, at = decode_int32 buf ~at in
let* led_values, at = decode_int32 buf ~at in
ignore orig;
Some ({ class_id; feedback_id; len; led_mask; led_values }, at);;
let encode_led_feedback_ctl buf (v : led_feedback_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.led_mask ~at in let* at = encode_int32 buf v.led_values ~at in ignore orig; Some at;;

type feedback_ctl = { feedback_id : int; len : int; data : feedback_class_variant; } [@@deriving sexp];;
let decode_feedback_ctl buf ~at : (feedback_ctl * int) option = let orig = at in 
let* feedback_id, at = decode_uint8 buf ~at in
let* len, at = decode_uint16 buf ~at in

ignore orig;
Some ({ feedback_id; len; data }, at);;
let encode_feedback_ctl buf (v : feedback_ctl) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint8 buf v.feedback_id ~at in let* at = encode_uint16 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

type change_feedback_control_mask = [ `Key_click_percent | `Percent | `Pitch | `Duration | `Led | `Led_mode | `Key | `Auto_repeat_mode | `String | `Integer | `Accel_num | `Accel_denom | `Threshold ] list [@@deriving sexp];;
let change_feedback_control_mask_mask_of_int64 mask : change_feedback_control_mask option = let of_int = function 0 -> Some `Key_click_percent | 1 -> Some `Percent | 2 -> Some `Pitch | 3 -> Some `Duration | 4 -> Some `Led | 5 -> Some `Led_mode | 6 -> Some `Key | 7 -> Some `Auto_repeat_mode | 0 -> Some `String | 0 -> Some `Integer | 0 -> Some `Accel_num | 1 -> Some `Accel_denom | 2 -> Some `Threshold | _ -> None in mask_of_int of_int mask;;
let change_feedback_control_mask_int_of_mask : change_feedback_control_mask -> int = let to_bit = function `Key_click_percent -> 0 | `Percent -> 1 | `Pitch -> 2 | `Duration -> 3 | `Led -> 4 | `Led_mode -> 5 | `Key -> 6 | `Auto_repeat_mode -> 7 | `String -> 0 | `Integer -> 0 | `Accel_num -> 0 | `Accel_denom -> 1 | `Threshold -> 2 in int_of_mask to_bit;;
let encode_change_feedback_control ~(mask : change_feedback_control_mask) ~(device_id : int) ~(feedback_id : int) ~(feedback : feedback_ctl)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let* at = encode_mask encode_int32 identity change_feedback_control_mask_int_of_mask buf mask ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf device_id ~at in
let* at = encode_uint8 buf feedback_id ~at in
let at = at + 2 in
let* at = encode_feedback_ctl buf feedback ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_key_mapping_reply = { xi_reply_type : int; keysyms_per_keycode : int; keysyms : Xproto.keysym list; } [@@deriving sexp];;
let encode_get_device_key_mapping ~(device_id : int) ~(first_keycode : key_code) ~(count : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_key_code buf first_keycode ~at in
let* at = encode_uint8 buf count ~at in
let at = at + 1 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_key_mapping_reply length buf ~at : (get_device_key_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* keysyms_per_keycode, at = decode_uint8 buf ~at in
let at = at + 23 in
let* keysyms, at = let length = length in decode_list (Xproto.decode_keysym) length buf ~at in
ignore orig;
Some ({ xi_reply_type; keysyms_per_keycode; keysyms }, at);;
let encode_change_device_key_mapping ~(device_id : int) ~(first_keycode : key_code) ~(keysyms_per_keycode : int) ~(keycode_count : int) ~(keysyms : Xproto.keysym list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 25 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_key_code buf first_keycode ~at in
let* at = encode_uint8 buf keysyms_per_keycode ~at in
let* at = encode_uint8 buf keycode_count ~at in
let* at = encode_list Xproto.encode_keysym buf keysyms ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_modifier_mapping_reply = { xi_reply_type : int; keymaps : int list; } [@@deriving sexp];;
let encode_get_device_modifier_mapping ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 26 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_modifier_mapping_reply length buf ~at : (get_device_modifier_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* keycodes_per_modifier, at = decode_uint8 buf ~at in let keycodes_per_modifier = (keycodes_per_modifier) / (8) in
let at = at + 23 in
let* keymaps, at = decode_list (decode_uint8) keycodes_per_modifier buf ~at in
ignore orig;
Some ({ xi_reply_type; keymaps }, at);;
type set_device_modifier_mapping_reply = { xi_reply_type : int; status : Xproto.mapping_status_enum; } [@@deriving sexp];;
let encode_set_device_modifier_mapping ~(device_id : int) ~(keymaps : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 27 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length keymaps)) ~at in
let at = at + 2 in
let* at = encode_list encode_uint8 buf keymaps ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_device_modifier_mapping_reply length buf ~at : (set_device_modifier_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.mapping_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
type get_device_button_mapping_reply = { xi_reply_type : int; map : int list; } [@@deriving sexp];;
let encode_get_device_button_mapping ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 28 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_button_mapping_reply length buf ~at : (get_device_button_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* map_size, at = decode_uint8 buf ~at in let map_size = map_size in
let at = at + 23 in
let* map, at = decode_list (decode_uint8) map_size buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ xi_reply_type; map }, at);;
type set_device_button_mapping_reply = { xi_reply_type : int; status : Xproto.mapping_status_enum; } [@@deriving sexp];;
let encode_set_device_button_mapping ~(device_id : int) ~(map : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 29 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length map)) ~at in
let at = at + 2 in
let* at = encode_list encode_uint8 buf map ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_device_button_mapping_reply length buf ~at : (set_device_button_mapping_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.mapping_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
type key_state = { class_id : input_class_enum; len : int; num_keys : int; keys : int list; } [@@deriving sexp];;
let decode_key_state buf ~at : (key_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* len, at = decode_uint8 buf ~at in
let* num_keys, at = decode_uint8 buf ~at in
let at = at + 1 in
let* keys, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ class_id; len; num_keys; keys }, at);;
let encode_key_state buf (v : key_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.len ~at in let* at = encode_uint8 buf v.num_keys ~at in let at = at + 1 in let* at = encode_list encode_uint8 buf v.keys ~at in ignore orig; Some at;;

type button_state = { class_id : input_class_enum; len : int; num_buttons : int; buttons : int list; } [@@deriving sexp];;
let decode_button_state buf ~at : (button_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* len, at = decode_uint8 buf ~at in
let* num_buttons, at = decode_uint8 buf ~at in
let at = at + 1 in
let* buttons, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
ignore orig;
Some ({ class_id; len; num_buttons; buttons }, at);;
let encode_button_state buf (v : button_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.len ~at in let* at = encode_uint8 buf v.num_buttons ~at in let at = at + 1 in let* at = encode_list encode_uint8 buf v.buttons ~at in ignore orig; Some at;;

type valuator_state_mode_mask = [ `Device_mode_absolute | `Out_of_proximity ] list [@@deriving sexp];;
let valuator_state_mode_mask_mask_of_int64 mask : valuator_state_mode_mask option = let of_int = function 0 -> Some `Device_mode_absolute | 1 -> Some `Out_of_proximity | _ -> None in mask_of_int of_int mask;;
let valuator_state_mode_mask_int_of_mask : valuator_state_mode_mask -> int = let to_bit = function `Device_mode_absolute -> 0 | `Out_of_proximity -> 1 in int_of_mask to_bit;;
type valuator_state = { class_id : input_class_enum; len : int; mode : valuator_state_mode_mask; valuators : int list; } [@@deriving sexp];;
let decode_valuator_state buf ~at : (valuator_state * int) option = let orig = at in let* class_id, at = decode_enum decode_uint8 identity input_class_enum_of_int buf ~at in
let* len, at = decode_uint8 buf ~at in
let* num_valuators, at = decode_uint8 buf ~at in let num_valuators = num_valuators in
let* mode, at = decode_mask decode_uint8 Int64.of_int valuator_state_mode_mask_mask_of_int64 buf ~at in
let* valuators, at = decode_list (decode_int32) num_valuators buf ~at in
ignore orig;
Some ({ class_id; len; mode; valuators }, at);;
let encode_valuator_state buf (v : valuator_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id ~at in let* at = encode_uint8 buf v.len ~at in let* at = encode_uint8 buf (identity ((* Parsetree.Int32 *) List.length v.valuators)) ~at in let* at = encode_mask encode_uint8 identity valuator_state_mode_mask_int_of_mask buf v.mode ~at in let* at = encode_list encode_int32 buf v.valuators ~at in ignore orig; Some at;;

type input_state = { len : int; data : input_class_variant; } [@@deriving sexp];;
let decode_input_state buf ~at : (input_state * int) option = let orig = at in 
let* len, at = decode_uint8 buf ~at in

ignore orig;
Some ({ len; data }, at);;
let encode_input_state buf (v : input_state) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint8 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

type query_device_state_reply = { xi_reply_type : int; classes : input_state list; } [@@deriving sexp];;
let encode_query_device_state ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 30 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_device_state_reply length buf ~at : (query_device_state_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_classes, at = decode_uint8 buf ~at in let num_classes = num_classes in
let at = at + 23 in
let* classes, at = decode_list (decode_input_state) num_classes buf ~at in
ignore orig;
Some ({ xi_reply_type; classes }, at);;
let encode_device_bell ~(device_id : int) ~(feedback_id : int) ~(feedback_class : int) ~(percent : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 32 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf feedback_id ~at in
let* at = encode_uint8 buf feedback_class ~at in
let* at = encode_int8 buf percent ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type set_device_valuators_reply = { xi_reply_type : int; status : Xproto.grab_status_enum; } [@@deriving sexp];;
let encode_set_device_valuators ~(device_id : int) ~(first_valuator : int) ~(valuators : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 33 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf first_valuator ~at in
let* at = encode_uint8 buf (identity ((* Parsetree.Int32 *) List.length valuators)) ~at in
let at = at + 1 in
let* at = encode_list encode_int32 buf valuators ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_set_device_valuators_reply length buf ~at : (set_device_valuators_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
type device_control_enum = [ `Resolution | `Abs_calib | `Core | `Enable | `Abs_area ] [@@deriving sexp];;
let device_control_enum_of_int : int -> [> device_control_enum ] option = function 1 -> Some `Resolution | 2 -> Some `Abs_calib | 3 -> Some `Core | 4 -> Some `Enable | 5 -> Some `Abs_area | n -> Printf.printf "unknown device_control_enum: %d\n" n; None;;
let device_control_int_of_enum : device_control_enum -> int = function `Resolution -> 1 | `Abs_calib -> 2 | `Core -> 3 | `Enable -> 4 | `Abs_area -> 5;;
type device_resolution_state = { control_id : device_control_enum; len : int; resolution_values : int list; resolution_min : int list; resolution_max : int list; } [@@deriving sexp];;
let decode_device_resolution_state buf ~at : (device_resolution_state * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* num_valuators, at = decode_int32 buf ~at in let num_valuators = num_valuators in
let* resolution_values, at = decode_list (decode_int32) num_valuators buf ~at in
let* resolution_min, at = decode_list (decode_int32) num_valuators buf ~at in
let* resolution_max, at = decode_list (decode_int32) num_valuators buf ~at in
ignore orig;
Some ({ control_id; len; resolution_values; resolution_min; resolution_max }, at);;
let encode_device_resolution_state buf (v : device_resolution_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length v.resolution_values)) ~at in let* at = encode_list encode_int32 buf v.resolution_values ~at in let* at = encode_list encode_int32 buf v.resolution_min ~at in let* at = encode_list encode_int32 buf v.resolution_max ~at in ignore orig; Some at;;

type device_abs_calib_state = { control_id : device_control_enum; len : int; min_x : int; max_x : int; min_y : int; max_y : int; flip_x : int; flip_y : int; rotation : int; button_threshold : int; } [@@deriving sexp];;
let decode_device_abs_calib_state buf ~at : (device_abs_calib_state * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* min_x, at = decode_int32 buf ~at in
let* max_x, at = decode_int32 buf ~at in
let* min_y, at = decode_int32 buf ~at in
let* max_y, at = decode_int32 buf ~at in
let* flip_x, at = decode_int32 buf ~at in
let* flip_y, at = decode_int32 buf ~at in
let* rotation, at = decode_int32 buf ~at in
let* button_threshold, at = decode_int32 buf ~at in
ignore orig;
Some ({ control_id; len; min_x; max_x; min_y; max_y; flip_x; flip_y; rotation; button_threshold }, at);;
let encode_device_abs_calib_state buf (v : device_abs_calib_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.min_x ~at in let* at = encode_int32 buf v.max_x ~at in let* at = encode_int32 buf v.min_y ~at in let* at = encode_int32 buf v.max_y ~at in let* at = encode_int32 buf v.flip_x ~at in let* at = encode_int32 buf v.flip_y ~at in let* at = encode_int32 buf v.rotation ~at in let* at = encode_int32 buf v.button_threshold ~at in ignore orig; Some at;;

type device_abs_area_state = { control_id : device_control_enum; len : int; offset_x : int; offset_y : int; width : int; height : int; screen : int; following : int; } [@@deriving sexp];;
let decode_device_abs_area_state buf ~at : (device_abs_area_state * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* offset_x, at = decode_int32 buf ~at in
let* offset_y, at = decode_int32 buf ~at in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let* screen, at = decode_int32 buf ~at in
let* following, at = decode_int32 buf ~at in
ignore orig;
Some ({ control_id; len; offset_x; offset_y; width; height; screen; following }, at);;
let encode_device_abs_area_state buf (v : device_abs_area_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.offset_x ~at in let* at = encode_int32 buf v.offset_y ~at in let* at = encode_int32 buf v.width ~at in let* at = encode_int32 buf v.height ~at in let* at = encode_int32 buf v.screen ~at in let* at = encode_int32 buf v.following ~at in ignore orig; Some at;;

type device_core_state = { control_id : device_control_enum; len : int; status : int; iscore : int; } [@@deriving sexp];;
let decode_device_core_state buf ~at : (device_core_state * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* status, at = decode_uint8 buf ~at in
let* iscore, at = decode_uint8 buf ~at in
let at = at + 2 in
ignore orig;
Some ({ control_id; len; status; iscore }, at);;
let encode_device_core_state buf (v : device_core_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint8 buf v.status ~at in let* at = encode_uint8 buf v.iscore ~at in let at = at + 2 in ignore orig; Some at;;

type device_enable_state = { control_id : device_control_enum; len : int; enable : int; } [@@deriving sexp];;
let decode_device_enable_state buf ~at : (device_enable_state * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* enable, at = decode_uint8 buf ~at in
let at = at + 3 in
ignore orig;
Some ({ control_id; len; enable }, at);;
let encode_device_enable_state buf (v : device_enable_state) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint8 buf v.enable ~at in let at = at + 3 in ignore orig; Some at;;

type device_control_variant = Resolution of { resolution_values : int list; resolution_min : int list; resolution_max : int list; } | Abs_calib of { min_x : int; max_x : int; min_y : int; max_y : int; flip_x : int; flip_y : int; rotation : int; button_threshold : int; } | Core of { status : int; iscore : int; } | Enable of { enable : int; } | Abs_area of { offset_x : int; offset_y : int; width : int; height : int; screen : int; following : int; } [@@deriving sexp];;
type device_state = { len : int; data : device_control_variant; } [@@deriving sexp];;
let decode_device_state buf ~at : (device_state * int) option = let orig = at in 
let* len, at = decode_uint16 buf ~at in

ignore orig;
Some ({ len; data }, at);;
let encode_device_state buf (v : device_state) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint16 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

type get_device_control_reply = { xi_reply_type : int; status : Xproto.grab_status_enum alt_enum; control : device_state; } [@@deriving sexp];;
let encode_get_device_control ~(control_id : device_control_enum) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 34 ~at in
let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf control_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf device_id ~at in
let at = at + 1 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_control_reply length buf ~at : (get_device_control_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_alt_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
let* control, at = decode_device_state buf ~at in
ignore orig;
Some ({ xi_reply_type; status; control }, at);;
type device_resolution_ctl = { control_id : device_control_enum; len : int; first_valuator : int; resolution_values : int list; } [@@deriving sexp];;
let decode_device_resolution_ctl buf ~at : (device_resolution_ctl * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* first_valuator, at = decode_uint8 buf ~at in
let* num_valuators, at = decode_uint8 buf ~at in let num_valuators = num_valuators in
let at = at + 2 in
let* resolution_values, at = decode_list (decode_int32) num_valuators buf ~at in
ignore orig;
Some ({ control_id; len; first_valuator; resolution_values }, at);;
let encode_device_resolution_ctl buf (v : device_resolution_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint8 buf v.first_valuator ~at in let* at = encode_uint8 buf (identity ((* Parsetree.Card32 *) List.length v.resolution_values)) ~at in let at = at + 2 in let* at = encode_list encode_int32 buf v.resolution_values ~at in ignore orig; Some at;;

type device_abs_calib_ctl = { control_id : device_control_enum; len : int; min_x : int; max_x : int; min_y : int; max_y : int; flip_x : int; flip_y : int; rotation : int; button_threshold : int; } [@@deriving sexp];;
let decode_device_abs_calib_ctl buf ~at : (device_abs_calib_ctl * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* min_x, at = decode_int32 buf ~at in
let* max_x, at = decode_int32 buf ~at in
let* min_y, at = decode_int32 buf ~at in
let* max_y, at = decode_int32 buf ~at in
let* flip_x, at = decode_int32 buf ~at in
let* flip_y, at = decode_int32 buf ~at in
let* rotation, at = decode_int32 buf ~at in
let* button_threshold, at = decode_int32 buf ~at in
ignore orig;
Some ({ control_id; len; min_x; max_x; min_y; max_y; flip_x; flip_y; rotation; button_threshold }, at);;
let encode_device_abs_calib_ctl buf (v : device_abs_calib_ctl) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.min_x ~at in let* at = encode_int32 buf v.max_x ~at in let* at = encode_int32 buf v.min_y ~at in let* at = encode_int32 buf v.max_y ~at in let* at = encode_int32 buf v.flip_x ~at in let* at = encode_int32 buf v.flip_y ~at in let* at = encode_int32 buf v.rotation ~at in let* at = encode_int32 buf v.button_threshold ~at in ignore orig; Some at;;

type device_abs_area_ctrl = { control_id : device_control_enum; len : int; offset_x : int; offset_y : int; width : int; height : int; screen : int; following : int; } [@@deriving sexp];;
let decode_device_abs_area_ctrl buf ~at : (device_abs_area_ctrl * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* offset_x, at = decode_int32 buf ~at in
let* offset_y, at = decode_int32 buf ~at in
let* width, at = decode_int32 buf ~at in
let* height, at = decode_int32 buf ~at in
let* screen, at = decode_int32 buf ~at in
let* following, at = decode_int32 buf ~at in
ignore orig;
Some ({ control_id; len; offset_x; offset_y; width; height; screen; following }, at);;
let encode_device_abs_area_ctrl buf (v : device_abs_area_ctrl) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_int32 buf v.offset_x ~at in let* at = encode_int32 buf v.offset_y ~at in let* at = encode_int32 buf v.width ~at in let* at = encode_int32 buf v.height ~at in let* at = encode_int32 buf v.screen ~at in let* at = encode_int32 buf v.following ~at in ignore orig; Some at;;

type device_core_ctrl = { control_id : device_control_enum; len : int; status : int; } [@@deriving sexp];;
let decode_device_core_ctrl buf ~at : (device_core_ctrl * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* status, at = decode_uint8 buf ~at in
let at = at + 3 in
ignore orig;
Some ({ control_id; len; status }, at);;
let encode_device_core_ctrl buf (v : device_core_ctrl) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint8 buf v.status ~at in let at = at + 3 in ignore orig; Some at;;

type device_enable_ctrl = { control_id : device_control_enum; len : int; enable : int; } [@@deriving sexp];;
let decode_device_enable_ctrl buf ~at : (device_enable_ctrl * int) option = let orig = at in let* control_id, at = decode_enum decode_uint16 identity device_control_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* enable, at = decode_uint8 buf ~at in
let at = at + 3 in
ignore orig;
Some ({ control_id; len; enable }, at);;
let encode_device_enable_ctrl buf (v : device_enable_ctrl) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf v.control_id ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint8 buf v.enable ~at in let at = at + 3 in ignore orig; Some at;;

type device_ctl = { len : int; data : device_control_variant; } [@@deriving sexp];;
let decode_device_ctl buf ~at : (device_ctl * int) option = let orig = at in 
let* len, at = decode_uint16 buf ~at in

ignore orig;
Some ({ len; data }, at);;
let encode_device_ctl buf (v : device_ctl) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint16 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

type change_device_control_reply = { xi_reply_type : int; status : Xproto.grab_status_enum alt_enum; } [@@deriving sexp];;
let encode_change_device_control ~(control_id : device_control_enum) ~(device_id : int) ~(control : device_ctl)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 35 ~at in
let* at = encode_enum encode_uint16 identity device_control_int_of_enum buf control_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf device_id ~at in
let at = at + 1 in
let* at = encode_device_ctl buf control ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_change_device_control_reply length buf ~at : (change_device_control_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* status, at = decode_alt_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ xi_reply_type; status }, at);;
type list_device_properties_reply = { xi_reply_type : int; atoms : Xproto.atom list; } [@@deriving sexp];;
let encode_list_device_properties ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 36 ~at in
let* at = encode_uint8 buf device_id ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_device_properties_reply length buf ~at : (list_device_properties_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* num_atoms, at = decode_uint16 buf ~at in let num_atoms = num_atoms in
let at = at + 22 in
let* atoms, at = decode_list (Xproto.decode_atom) num_atoms buf ~at in
ignore orig;
Some ({ xi_reply_type; atoms }, at);;
type property_format_enum = [ `D8_bits | `D16_bits | `D32_bits ] [@@deriving sexp];;
let property_format_enum_of_int : int -> [> property_format_enum ] option = function 8 -> Some `D8_bits | 16 -> Some `D16_bits | 32 -> Some `D32_bits | n -> Printf.printf "unknown property_format_enum: %d\n" n; None;;
let property_format_int_of_enum : property_format_enum -> int = function `D8_bits -> 8 | `D16_bits -> 16 | `D32_bits -> 32;;
type property_format_variant = D8_bits of { data8 : int list; } | D16_bits of { data16 : int list; } | D32_bits of { data32 : int list; } [@@deriving sexp];;
let encode_change_device_property ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(device_id : int) ~(mode : Xproto.prop_mode_enum) ~(num_items : int) ~(items : property_format_variant)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 37 ~at in
let* at = Xproto.encode_atom buf property ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_uint8 buf device_id ~at in
(* field_variant_tag *)
let* at = encode_enum encode_uint8 identity Xproto.prop_mode_int_of_enum buf mode ~at in
let at = at + 1 in
let* at = encode_int32 buf num_items ~at in
(* field_variant *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_delete_device_property ~(property : Xproto.atom) ~(device_id : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 38 ~at in
let* at = Xproto.encode_atom buf property ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf device_id ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_property_reply = { xi_reply_type : int; type_ : Xproto.atom; bytes_after : int; num_items : int; device_id : int; items : property_format_variant; } [@@deriving sexp];;
let encode_get_device_property ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(offset : int) ~(len : int) ~(device_id : int) ~(delete : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 39 ~at in
let* at = Xproto.encode_atom buf property ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_int32 buf offset ~at in
let* at = encode_int32 buf len ~at in
let* at = encode_uint8 buf device_id ~at in
let* at = encode_bool buf delete ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_property_reply length buf ~at : (get_device_property_reply * int) option = let orig = at in let at = at + 1 in
let* xi_reply_type, at = decode_uint8 buf ~at in
let at = at + 6 in
let* type_, at = Xproto.decode_atom buf ~at in
let* bytes_after, at = decode_int32 buf ~at in
let* num_items, at = decode_int32 buf ~at in

let* device_id, at = decode_uint8 buf ~at in
let at = at + 10 in

ignore orig;
Some ({ xi_reply_type; type_; bytes_after; num_items; device_id; items }, at);;
type device_enum = [ `All | `All_master ] [@@deriving sexp];;
let device_enum_of_int : int -> [> device_enum ] option = function 0 -> Some `All | 1 -> Some `All_master | n -> Printf.printf "unknown device_enum: %d\n" n; None;;
let device_int_of_enum : device_enum -> int = function `All -> 0 | `All_master -> 1;;
type group_info = { base : int; latched : int; locked : int; effective : int; } [@@deriving sexp];;
let decode_group_info buf ~at : (group_info * int) option = let orig = at in let* base, at = decode_uint8 buf ~at in
let* latched, at = decode_uint8 buf ~at in
let* locked, at = decode_uint8 buf ~at in
let* effective, at = decode_uint8 buf ~at in
ignore orig;
Some ({ base; latched; locked; effective }, at);;
let encode_group_info buf (v : group_info) ~at : int option = let orig = at in let* at = encode_uint8 buf v.base ~at in let* at = encode_uint8 buf v.latched ~at in let* at = encode_uint8 buf v.locked ~at in let* at = encode_uint8 buf v.effective ~at in ignore orig; Some at;;

type modifier_info = { base : int; latched : int; locked : int; effective : int; } [@@deriving sexp];;
let decode_modifier_info buf ~at : (modifier_info * int) option = let orig = at in let* base, at = decode_int32 buf ~at in
let* latched, at = decode_int32 buf ~at in
let* locked, at = decode_int32 buf ~at in
let* effective, at = decode_int32 buf ~at in
ignore orig;
Some ({ base; latched; locked; effective }, at);;
let encode_modifier_info buf (v : modifier_info) ~at : int option = let orig = at in let* at = encode_int32 buf v.base ~at in let* at = encode_int32 buf v.latched ~at in let* at = encode_int32 buf v.locked ~at in let* at = encode_int32 buf v.effective ~at in ignore orig; Some at;;

type xi_query_pointer_reply = { root : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; win_x : fp1616; win_y : fp1616; same_screen : bool; mods : modifier_info; group : group_info; buttons : int list; } [@@deriving sexp];;
let encode_xi_query_pointer ~(window : Xproto.window) ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 40 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_query_pointer_reply length buf ~at : (xi_query_pointer_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* root, at = Xproto.decode_window buf ~at in
let* child, at = Xproto.decode_window buf ~at in
let* root_x, at = decode_fp1616 buf ~at in
let* root_y, at = decode_fp1616 buf ~at in
let* win_x, at = decode_fp1616 buf ~at in
let* win_y, at = decode_fp1616 buf ~at in
let* same_screen, at = decode_bool buf ~at in
let at = at + 1 in
let* buttons_len, at = decode_uint16 buf ~at in let buttons_len = buttons_len in
let* mods, at = decode_modifier_info buf ~at in
let* group, at = decode_group_info buf ~at in
let* buttons, at = decode_list (decode_int32) buttons_len buf ~at in
ignore orig;
Some ({ root; child; root_x; root_y; win_x; win_y; same_screen; mods; group; buttons }, at);;
let encode_xi_warp_pointer ~(src_win : Xproto.window) ~(dst_win : Xproto.window) ~(src_x : fp1616) ~(src_y : fp1616) ~(src_width : int) ~(src_height : int) ~(dst_x : fp1616) ~(dst_y : fp1616) ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 41 ~at in
let* at = Xproto.encode_window buf src_win ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf dst_win ~at in
let* at = encode_fp1616 buf src_x ~at in
let* at = encode_fp1616 buf src_y ~at in
let* at = encode_uint16 buf src_width ~at in
let* at = encode_uint16 buf src_height ~at in
let* at = encode_fp1616 buf dst_x ~at in
let* at = encode_fp1616 buf dst_y ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_xi_change_cursor ~(window : Xproto.window) ~(cursor : Xproto.cursor) ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 42 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_cursor buf cursor ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type hierarchy_change_type_enum = [ `Add_master | `Remove_master | `Attach_slave | `Detach_slave ] [@@deriving sexp];;
let hierarchy_change_type_enum_of_int : int -> [> hierarchy_change_type_enum ] option = function 1 -> Some `Add_master | 2 -> Some `Remove_master | 3 -> Some `Attach_slave | 4 -> Some `Detach_slave | n -> Printf.printf "unknown hierarchy_change_type_enum: %d\n" n; None;;
let hierarchy_change_type_int_of_enum : hierarchy_change_type_enum -> int = function `Add_master -> 1 | `Remove_master -> 2 | `Attach_slave -> 3 | `Detach_slave -> 4;;
type change_mode_enum = [ `Attach | `Float ] [@@deriving sexp];;
let change_mode_enum_of_int : int -> [> change_mode_enum ] option = function 1 -> Some `Attach | 2 -> Some `Float | n -> Printf.printf "unknown change_mode_enum: %d\n" n; None;;
let change_mode_int_of_enum : change_mode_enum -> int = function `Attach -> 1 | `Float -> 2;;
type add_master = { type_ : hierarchy_change_type_enum; len : int; send_core : bool; enable : bool; name : string; } [@@deriving sexp];;
let decode_add_master buf ~at : (add_master * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let* send_core, at = decode_bool buf ~at in
let* enable, at = decode_bool buf ~at in
let* name, at = decode_string name_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ type_; len; send_core; enable; name }, at);;
let encode_add_master buf (v : add_master) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_uint16 buf (identity (String.length v.name)) ~at in let* at = encode_bool buf v.send_core ~at in let* at = encode_bool buf v.enable ~at in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type remove_master = { type_ : hierarchy_change_type_enum; len : int; deviceid : device_enum alt_enum; return_mode : change_mode_enum; return_pointer : device_enum alt_enum; return_keyboard : device_enum alt_enum; } [@@deriving sexp];;
let decode_remove_master buf ~at : (remove_master * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* return_mode, at = decode_enum decode_uint8 identity change_mode_enum_of_int buf ~at in
let at = at + 1 in
let* return_pointer, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* return_keyboard, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
ignore orig;
Some ({ type_; len; deviceid; return_mode; return_pointer; return_keyboard }, at);;
let encode_remove_master buf (v : remove_master) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid ~at in let* at = encode_enum encode_uint8 identity change_mode_int_of_enum buf v.return_mode ~at in let at = at + 1 in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.return_pointer ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.return_keyboard ~at in ignore orig; Some at;;

type attach_slave = { type_ : hierarchy_change_type_enum; len : int; deviceid : device_enum alt_enum; master : device_enum alt_enum; } [@@deriving sexp];;
let decode_attach_slave buf ~at : (attach_slave * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* master, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
ignore orig;
Some ({ type_; len; deviceid; master }, at);;
let encode_attach_slave buf (v : attach_slave) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.master ~at in ignore orig; Some at;;

type detach_slave = { type_ : hierarchy_change_type_enum; len : int; deviceid : device_enum alt_enum; } [@@deriving sexp];;
let decode_detach_slave buf ~at : (detach_slave * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let at = at + 2 in
ignore orig;
Some ({ type_; len; deviceid }, at);;
let encode_detach_slave buf (v : detach_slave) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid ~at in let at = at + 2 in ignore orig; Some at;;

type hierarchy_change_type_variant = Add_master of { send_core : bool; enable : bool; name : string; } | Remove_master of { deviceid : device_enum alt_enum; return_mode : change_mode_enum; return_pointer : device_enum alt_enum; return_keyboard : device_enum alt_enum; } | Attach_slave of { deviceid : device_enum alt_enum; master : device_enum alt_enum; } | Detach_slave of { deviceid : device_enum alt_enum; } [@@deriving sexp];;
type hierarchy_change = { len : int; data : hierarchy_change_type_variant; } [@@deriving sexp];;
let decode_hierarchy_change buf ~at : (hierarchy_change * int) option = let orig = at in 
let* len, at = decode_uint16 buf ~at in

ignore orig;
Some ({ len; data }, at);;
let encode_hierarchy_change buf (v : hierarchy_change) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint16 buf v.len ~at in (* field_variant *) ignore orig; Some at;;

let encode_xi_change_hierarchy ~(changes : hierarchy_change list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 43 ~at in
let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length changes)) ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
let* at = encode_list encode_hierarchy_change buf changes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_xi_set_client_pointer ~(window : Xproto.window) ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 44 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type xi_get_client_pointer_reply = { set : bool; deviceid : device_enum alt_enum; } [@@deriving sexp];;
let encode_xi_get_client_pointer ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 45 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_get_client_pointer_reply length buf ~at : (xi_get_client_pointer_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* set, at = decode_bool buf ~at in
let at = at + 1 in
let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let at = at + 20 in
ignore orig;
Some ({ set; deviceid }, at);;
type xi_event_mask = [ `Device_changed | `Key_press | `Key_release | `Button_press | `Button_release | `Motion | `Enter | `Leave | `Focus_in | `Focus_out | `Hierarchy | `Property | `Raw_key_press | `Raw_key_release | `Raw_button_press | `Raw_button_release | `Raw_motion | `Touch_begin | `Touch_update | `Touch_end | `Touch_ownership | `Raw_touch_begin | `Raw_touch_update | `Raw_touch_end | `Barrier_hit | `Barrier_leave ] list [@@deriving sexp];;
let xi_event_mask_mask_of_int64 mask : xi_event_mask option = let of_int = function 1 -> Some `Device_changed | 2 -> Some `Key_press | 3 -> Some `Key_release | 4 -> Some `Button_press | 5 -> Some `Button_release | 6 -> Some `Motion | 7 -> Some `Enter | 8 -> Some `Leave | 9 -> Some `Focus_in | 10 -> Some `Focus_out | 11 -> Some `Hierarchy | 12 -> Some `Property | 13 -> Some `Raw_key_press | 14 -> Some `Raw_key_release | 15 -> Some `Raw_button_press | 16 -> Some `Raw_button_release | 17 -> Some `Raw_motion | 18 -> Some `Touch_begin | 19 -> Some `Touch_update | 20 -> Some `Touch_end | 21 -> Some `Touch_ownership | 22 -> Some `Raw_touch_begin | 23 -> Some `Raw_touch_update | 24 -> Some `Raw_touch_end | 25 -> Some `Barrier_hit | 26 -> Some `Barrier_leave | _ -> None in mask_of_int of_int mask;;
let xi_event_mask_int_of_mask : xi_event_mask -> int = let to_bit = function `Device_changed -> 1 | `Key_press -> 2 | `Key_release -> 3 | `Button_press -> 4 | `Button_release -> 5 | `Motion -> 6 | `Enter -> 7 | `Leave -> 8 | `Focus_in -> 9 | `Focus_out -> 10 | `Hierarchy -> 11 | `Property -> 12 | `Raw_key_press -> 13 | `Raw_key_release -> 14 | `Raw_button_press -> 15 | `Raw_button_release -> 16 | `Raw_motion -> 17 | `Touch_begin -> 18 | `Touch_update -> 19 | `Touch_end -> 20 | `Touch_ownership -> 21 | `Raw_touch_begin -> 22 | `Raw_touch_update -> 23 | `Raw_touch_end -> 24 | `Barrier_hit -> 25 | `Barrier_leave -> 26 in int_of_mask to_bit;;
type event_mask = { deviceid : device_enum alt_enum; mask : xi_event_mask list; } [@@deriving sexp];;
let decode_event_mask buf ~at : (event_mask * int) option = let orig = at in let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* mask_len, at = decode_uint16 buf ~at in let mask_len = mask_len in
let* mask, at = decode_list (decode_mask decode_int32 Int64.of_int xi_event_mask_mask_of_int64) mask_len buf ~at in
ignore orig;
Some ({ deviceid; mask }, at);;
let encode_event_mask buf (v : event_mask) ~at : int option = let orig = at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid ~at in let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.mask)) ~at in let* at = encode_list encode_mask encode_int32 identity xi_event_mask_int_of_mask buf v.mask ~at in ignore orig; Some at;;

let encode_xi_select_events ~(window : Xproto.window) ~(masks : event_mask list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 46 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length masks)) ~at in
let at = at + 2 in
let* at = encode_list encode_event_mask buf masks ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type xi_query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_xi_query_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 47 ~at in
let* at = encode_uint16 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_query_version_reply length buf ~at : (xi_query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
let at = at + 20 in
ignore orig;
Some ({ major_version; minor_version }, at);;
type device_class_type_enum = [ `Key | `Button | `Valuator | `Scroll | `Touch ] [@@deriving sexp];;
let device_class_type_enum_of_int : int -> [> device_class_type_enum ] option = function 0 -> Some `Key | 1 -> Some `Button | 2 -> Some `Valuator | 3 -> Some `Scroll | 8 -> Some `Touch | n -> Printf.printf "unknown device_class_type_enum: %d\n" n; None;;
let device_class_type_int_of_enum : device_class_type_enum -> int = function `Key -> 0 | `Button -> 1 | `Valuator -> 2 | `Scroll -> 3 | `Touch -> 8;;
type device_type_enum = [ `Master_pointer | `Master_keyboard | `Slave_pointer | `Slave_keyboard | `Floating_slave ] [@@deriving sexp];;
let device_type_enum_of_int : int -> [> device_type_enum ] option = function 1 -> Some `Master_pointer | 2 -> Some `Master_keyboard | 3 -> Some `Slave_pointer | 4 -> Some `Slave_keyboard | 5 -> Some `Floating_slave | n -> Printf.printf "unknown device_type_enum: %d\n" n; None;;
let device_type_int_of_enum : device_type_enum -> int = function `Master_pointer -> 1 | `Master_keyboard -> 2 | `Slave_pointer -> 3 | `Slave_keyboard -> 4 | `Floating_slave -> 5;;
type scroll_flags_mask = [ `No_emulation | `Preferred ] list [@@deriving sexp];;
let scroll_flags_mask_of_int64 mask : scroll_flags_mask option = let of_int = function 0 -> Some `No_emulation | 1 -> Some `Preferred | _ -> None in mask_of_int of_int mask;;
let scroll_flags_int_of_mask : scroll_flags_mask -> int = let to_bit = function `No_emulation -> 0 | `Preferred -> 1 in int_of_mask to_bit;;
type scroll_type_enum = [ `Vertical | `Horizontal ] [@@deriving sexp];;
let scroll_type_enum_of_int : int -> [> scroll_type_enum ] option = function 1 -> Some `Vertical | 2 -> Some `Horizontal | n -> Printf.printf "unknown scroll_type_enum: %d\n" n; None;;
let scroll_type_int_of_enum : scroll_type_enum -> int = function `Vertical -> 1 | `Horizontal -> 2;;
type touch_mode_enum = [ `Direct | `Dependent ] [@@deriving sexp];;
let touch_mode_enum_of_int : int -> [> touch_mode_enum ] option = function 1 -> Some `Direct | 2 -> Some `Dependent | n -> Printf.printf "unknown touch_mode_enum: %d\n" n; None;;
let touch_mode_int_of_enum : touch_mode_enum -> int = function `Direct -> 1 | `Dependent -> 2;;
type button_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; state : int list; labels : Xproto.atom list; } [@@deriving sexp];;
let decode_button_class buf ~at : (button_class * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* sourceid, at = decode_device_id buf ~at in
let* num_buttons, at = decode_uint16 buf ~at in let num_buttons = num_buttons in
let* state, at = let length = ((num_buttons) + (31)) / (32) in decode_list (decode_int32) length buf ~at in
let* labels, at = decode_list (Xproto.decode_atom) num_buttons buf ~at in
ignore orig;
Some ({ type_; len; sourceid; state; labels }, at);;
let encode_button_class buf (v : button_class) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_device_id buf v.sourceid ~at in let* at = encode_uint16 buf (identity ((* Parsetree.Xid *) List.length v.labels)) ~at in let* at = encode_list encode_int32 buf v.state ~at in let* at = encode_list Xproto.encode_atom buf v.labels ~at in ignore orig; Some at;;

type key_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; keys : int list; } [@@deriving sexp];;
let decode_key_class buf ~at : (key_class * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* sourceid, at = decode_device_id buf ~at in
let* num_keys, at = decode_uint16 buf ~at in let num_keys = num_keys in
let* keys, at = decode_list (decode_int32) num_keys buf ~at in
ignore orig;
Some ({ type_; len; sourceid; keys }, at);;
let encode_key_class buf (v : key_class) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_device_id buf v.sourceid ~at in let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.keys)) ~at in let* at = encode_list encode_int32 buf v.keys ~at in ignore orig; Some at;;

type scroll_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; number : int; scroll_type : scroll_type_enum; flags : scroll_flags_mask; increment : fp3232; } [@@deriving sexp];;
let decode_scroll_class buf ~at : (scroll_class * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* sourceid, at = decode_device_id buf ~at in
let* number, at = decode_uint16 buf ~at in
let* scroll_type, at = decode_enum decode_uint16 identity scroll_type_enum_of_int buf ~at in
let at = at + 2 in
let* flags, at = decode_mask decode_int32 Int64.of_int scroll_flags_mask_of_int64 buf ~at in
let* increment, at = decode_fp3232 buf ~at in
ignore orig;
Some ({ type_; len; sourceid; number; scroll_type; flags; increment }, at);;
let encode_scroll_class buf (v : scroll_class) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_device_id buf v.sourceid ~at in let* at = encode_uint16 buf v.number ~at in let* at = encode_enum encode_uint16 identity scroll_type_int_of_enum buf v.scroll_type ~at in let at = at + 2 in let* at = encode_mask encode_int32 identity scroll_flags_int_of_mask buf v.flags ~at in let* at = encode_fp3232 buf v.increment ~at in ignore orig; Some at;;

type touch_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; mode : touch_mode_enum; num_touches : int; } [@@deriving sexp];;
let decode_touch_class buf ~at : (touch_class * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* sourceid, at = decode_device_id buf ~at in
let* mode, at = decode_enum decode_uint8 identity touch_mode_enum_of_int buf ~at in
let* num_touches, at = decode_uint8 buf ~at in
ignore orig;
Some ({ type_; len; sourceid; mode; num_touches }, at);;
let encode_touch_class buf (v : touch_class) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_device_id buf v.sourceid ~at in let* at = encode_enum encode_uint8 identity touch_mode_int_of_enum buf v.mode ~at in let* at = encode_uint8 buf v.num_touches ~at in ignore orig; Some at;;

type valuator_class = { type_ : device_class_type_enum; len : int; sourceid : device_id; number : int; label : Xproto.atom; min : fp3232; max : fp3232; value : fp3232; resolution : int; mode : valuator_mode_enum; } [@@deriving sexp];;
let decode_valuator_class buf ~at : (valuator_class * int) option = let orig = at in let* type_, at = decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at in
let* len, at = decode_uint16 buf ~at in
let* sourceid, at = decode_device_id buf ~at in
let* number, at = decode_uint16 buf ~at in
let* label, at = Xproto.decode_atom buf ~at in
let* min, at = decode_fp3232 buf ~at in
let* max, at = decode_fp3232 buf ~at in
let* value, at = decode_fp3232 buf ~at in
let* resolution, at = decode_int32 buf ~at in
let* mode, at = decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at in
let at = at + 3 in
ignore orig;
Some ({ type_; len; sourceid; number; label; min; max; value; resolution; mode }, at);;
let encode_valuator_class buf (v : valuator_class) ~at : int option = let orig = at in let* at = encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_ ~at in let* at = encode_uint16 buf v.len ~at in let* at = encode_device_id buf v.sourceid ~at in let* at = encode_uint16 buf v.number ~at in let* at = Xproto.encode_atom buf v.label ~at in let* at = encode_fp3232 buf v.min ~at in let* at = encode_fp3232 buf v.max ~at in let* at = encode_fp3232 buf v.value ~at in let* at = encode_int32 buf v.resolution ~at in let* at = encode_enum encode_uint8 identity valuator_mode_int_of_enum buf v.mode ~at in let at = at + 3 in ignore orig; Some at;;

type device_class_type_variant = Key of { keys : int list; } | Button of { state : int list; labels : Xproto.atom list; } | Valuator of { number : int; label : Xproto.atom; min : fp3232; max : fp3232; value : fp3232; resolution : int; mode : valuator_mode_enum; } | Scroll of { number : int; scroll_type : scroll_type_enum; flags : scroll_flags_mask; increment : fp3232; } | Touch of { mode : touch_mode_enum; num_touches : int; } [@@deriving sexp];;
type device_class = { len : int; sourceid : device_id; data : device_class_type_variant; } [@@deriving sexp];;
let decode_device_class buf ~at : (device_class * int) option = let orig = at in 
let* len, at = decode_uint16 buf ~at in
let* sourceid, at = decode_device_id buf ~at in

ignore orig;
Some ({ len; sourceid; data }, at);;
let encode_device_class buf (v : device_class) ~at : int option = let orig = at in (* field_variant_tag *) let* at = encode_uint16 buf v.len ~at in let* at = encode_device_id buf v.sourceid ~at in (* field_variant *) ignore orig; Some at;;

type xi_device_info = { deviceid : device_enum alt_enum; type_ : device_type_enum; attachment : device_enum alt_enum; enabled : bool; name : string; classes : device_class list; } [@@deriving sexp];;
let decode_xi_device_info buf ~at : (xi_device_info * int) option = let orig = at in let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* type_, at = decode_enum decode_uint16 identity device_type_enum_of_int buf ~at in
let* attachment, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* num_classes, at = decode_uint16 buf ~at in let num_classes = num_classes in
let* name_len, at = decode_uint16 buf ~at in let name_len = name_len in
let* enabled, at = decode_bool buf ~at in
let at = at + 1 in
let* name, at = decode_string name_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* classes, at = decode_list (decode_device_class) num_classes buf ~at in
ignore orig;
Some ({ deviceid; type_; attachment; enabled; name; classes }, at);;
let encode_xi_device_info buf (v : xi_device_info) ~at : int option = let orig = at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid ~at in let* at = encode_enum encode_uint16 identity device_type_int_of_enum buf v.type_ ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.attachment ~at in let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length v.classes)) ~at in let* at = encode_uint16 buf (identity (String.length v.name)) ~at in let* at = encode_bool buf v.enabled ~at in let at = at + 1 in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in let* at = encode_list encode_device_class buf v.classes ~at in ignore orig; Some at;;

type xi_query_device_reply = { infos : xi_device_info list; } [@@deriving sexp];;
let encode_xi_query_device ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 48 ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_query_device_reply length buf ~at : (xi_query_device_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_infos, at = decode_uint16 buf ~at in let num_infos = num_infos in
let at = at + 22 in
let* infos, at = decode_list (decode_xi_device_info) num_infos buf ~at in
ignore orig;
Some ({ infos }, at);;
let encode_xi_set_focus ~(window : Xproto.window) ~(time : Xproto.time_enum alt_enum) ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 49 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type xi_get_focus_reply = { focus : Xproto.window; } [@@deriving sexp];;
let encode_xi_get_focus ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 50 ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_get_focus_reply length buf ~at : (xi_get_focus_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* focus, at = Xproto.decode_window buf ~at in
let at = at + 20 in
ignore orig;
Some ({ focus }, at);;
type grab_owner_enum = [ `No_owner | `Owner ] [@@deriving sexp];;
let grab_owner_enum_of_int : int -> [> grab_owner_enum ] option = function 0 -> Some `No_owner | 1 -> Some `Owner | n -> Printf.printf "unknown grab_owner_enum: %d\n" n; None;;
let grab_owner_int_of_enum : grab_owner_enum -> int = function `No_owner -> 0 | `Owner -> 1;;
type xi_grab_device_reply = { status : Xproto.grab_status_enum; } [@@deriving sexp];;
let encode_xi_grab_device ~(window : Xproto.window) ~(time : Xproto.time_enum alt_enum) ~(cursor : Xproto.cursor) ~(deviceid : device_enum alt_enum) ~(mode : Xproto.grab_mode_enum) ~(paired_device_mode : Xproto.grab_mode_enum) ~(owner_events : grab_owner_enum) ~(mask : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 51 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
let* at = Xproto.encode_cursor buf cursor ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf mode ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf paired_device_mode ~at in
let* at = encode_enum encode_bool bool_of_int grab_owner_int_of_enum buf owner_events ~at in
let at = at + 1 in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length mask)) ~at in
let* at = encode_list encode_int32 buf mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_grab_device_reply length buf ~at : (xi_grab_device_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 23 in
ignore orig;
Some ({ status }, at);;
let encode_xi_ungrab_device ~(time : Xproto.time_enum alt_enum) ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 52 ~at in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type event_mode_enum = [ `Async_device | `Sync_device | `Replay_device | `Async_paired_device | `Async_pair | `Sync_pair | `Accept_touch | `Reject_touch ] [@@deriving sexp];;
let event_mode_enum_of_int : int -> [> event_mode_enum ] option = function 0 -> Some `Async_device | 1 -> Some `Sync_device | 2 -> Some `Replay_device | 3 -> Some `Async_paired_device | 4 -> Some `Async_pair | 5 -> Some `Sync_pair | 6 -> Some `Accept_touch | 7 -> Some `Reject_touch | n -> Printf.printf "unknown event_mode_enum: %d\n" n; None;;
let event_mode_int_of_enum : event_mode_enum -> int = function `Async_device -> 0 | `Sync_device -> 1 | `Replay_device -> 2 | `Async_paired_device -> 3 | `Async_pair -> 4 | `Sync_pair -> 5 | `Accept_touch -> 6 | `Reject_touch -> 7;;
let encode_xi_allow_events ~(time : Xproto.time_enum alt_enum) ~(deviceid : device_enum alt_enum) ~(event_mode : event_mode_enum) ~(touchid : int) ~(grab_window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 53 ~at in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let* at = encode_enum encode_uint8 identity event_mode_int_of_enum buf event_mode ~at in
let at = at + 1 in
let* at = encode_int32 buf touchid ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type grab_mode22_enum = [ `Sync | `Async | `Touch ] [@@deriving sexp];;
let grab_mode22_enum_of_int : int -> [> grab_mode22_enum ] option = function 0 -> Some `Sync | 1 -> Some `Async | 2 -> Some `Touch | n -> Printf.printf "unknown grab_mode22_enum: %d\n" n; None;;
let grab_mode22_int_of_enum : grab_mode22_enum -> int = function `Sync -> 0 | `Async -> 1 | `Touch -> 2;;
type grab_type_enum = [ `Button | `Keycode | `Enter | `Focus_in | `Touch_begin ] [@@deriving sexp];;
let grab_type_enum_of_int : int -> [> grab_type_enum ] option = function 0 -> Some `Button | 1 -> Some `Keycode | 2 -> Some `Enter | 3 -> Some `Focus_in | 4 -> Some `Touch_begin | n -> Printf.printf "unknown grab_type_enum: %d\n" n; None;;
let grab_type_int_of_enum : grab_type_enum -> int = function `Button -> 0 | `Keycode -> 1 | `Enter -> 2 | `Focus_in -> 3 | `Touch_begin -> 4;;
type modifier_mask = [ `Any ] list [@@deriving sexp];;
let modifier_mask_mask_of_int64 mask : modifier_mask option = let of_int = function 31 -> Some `Any | _ -> None in mask_of_int of_int mask;;
let modifier_mask_int_of_mask : modifier_mask -> int = let to_bit = function `Any -> 31 in int_of_mask to_bit;;
type grab_modifier_info = { modifiers : (modifier_mask, int) mask; status : Xproto.grab_status_enum; } [@@deriving sexp];;
let decode_grab_modifier_info buf ~at : (grab_modifier_info * int) option = let orig = at in let* modifiers, at = decode_alt_mask decode_int32 Int64.of_int modifier_mask_mask_of_int64 buf ~at in
let* status, at = decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at in
let at = at + 3 in
ignore orig;
Some ({ modifiers; status }, at);;
let encode_grab_modifier_info buf (v : grab_modifier_info) ~at : int option = let orig = at in let* at = encode_int32 buf v.modifiers ~at in let* at = encode_enum encode_uint8 identity Xproto.grab_status_int_of_enum buf v.status ~at in let at = at + 3 in ignore orig; Some at;;

type xi_passive_grab_device_reply = { modifiers : grab_modifier_info list; } [@@deriving sexp];;
let encode_xi_passive_grab_device ~(time : Xproto.time_enum alt_enum) ~(grab_window : Xproto.window) ~(cursor : Xproto.cursor) ~(detail : int) ~(deviceid : device_enum alt_enum) ~(grab_type : grab_type_enum) ~(grab_mode : grab_mode22_enum) ~(paired_device_mode : Xproto.grab_mode_enum) ~(owner_events : grab_owner_enum) ~(mask : int list) ~(modifiers : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 54 ~at in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_window buf grab_window ~at in
let* at = Xproto.encode_cursor buf cursor ~at in
let* at = encode_int32 buf detail ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length modifiers)) ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length mask)) ~at in
let* at = encode_enum encode_uint8 identity grab_type_int_of_enum buf grab_type ~at in
let* at = encode_enum encode_uint8 identity grab_mode22_int_of_enum buf grab_mode ~at in
let* at = encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf paired_device_mode ~at in
let* at = encode_enum encode_bool bool_of_int grab_owner_int_of_enum buf owner_events ~at in
let at = at + 2 in
let* at = encode_list encode_int32 buf mask ~at in
let* at = encode_list encode_int32 buf modifiers ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_passive_grab_device_reply length buf ~at : (xi_passive_grab_device_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_modifiers, at = decode_uint16 buf ~at in let num_modifiers = num_modifiers in
let at = at + 22 in
let* modifiers, at = decode_list (decode_grab_modifier_info) num_modifiers buf ~at in
ignore orig;
Some ({ modifiers }, at);;
let encode_xi_passive_ungrab_device ~(grab_window : Xproto.window) ~(detail : int) ~(deviceid : device_enum alt_enum) ~(grab_type : grab_type_enum) ~(modifiers : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 55 ~at in
let* at = Xproto.encode_window buf grab_window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf detail ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length modifiers)) ~at in
let* at = encode_enum encode_uint8 identity grab_type_int_of_enum buf grab_type ~at in
let at = at + 3 in
let* at = encode_list encode_int32 buf modifiers ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type xi_list_properties_reply = { properties : Xproto.atom list; } [@@deriving sexp];;
let encode_xi_list_properties ~(deviceid : device_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 56 ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_list_properties_reply length buf ~at : (xi_list_properties_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_properties, at = decode_uint16 buf ~at in let num_properties = num_properties in
let at = at + 22 in
let* properties, at = decode_list (Xproto.decode_atom) num_properties buf ~at in
ignore orig;
Some ({ properties }, at);;
let encode_xi_change_property ~(deviceid : device_enum alt_enum) ~(mode : Xproto.prop_mode_enum) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(num_items : int) ~(items : property_format_variant)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 57 ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_enum encode_uint8 identity Xproto.prop_mode_int_of_enum buf mode ~at in
(* field_variant_tag *)
let* at = Xproto.encode_atom buf property ~at in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_int32 buf num_items ~at in
(* field_variant *)
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_xi_delete_property ~(deviceid : device_enum alt_enum) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 58 ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type xi_get_property_reply = { type_ : Xproto.atom; bytes_after : int; num_items : int; items : property_format_variant; } [@@deriving sexp];;
let encode_xi_get_property ~(deviceid : device_enum alt_enum) ~(delete : bool) ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(offset : int) ~(len : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 59 ~at in
let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_bool buf delete ~at in
let at = at + 1 in
let* at = Xproto.encode_atom buf property ~at in
let* at = Xproto.encode_atom buf type_ ~at in
let* at = encode_int32 buf offset ~at in
let* at = encode_int32 buf len ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_get_property_reply length buf ~at : (xi_get_property_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* type_, at = Xproto.decode_atom buf ~at in
let* bytes_after, at = decode_int32 buf ~at in
let* num_items, at = decode_int32 buf ~at in

let at = at + 11 in

ignore orig;
Some ({ type_; bytes_after; num_items; items }, at);;
type xi_get_selected_events_reply = { masks : event_mask list; } [@@deriving sexp];;
let encode_xi_get_selected_events ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 60 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_xi_get_selected_events_reply length buf ~at : (xi_get_selected_events_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_masks, at = decode_uint16 buf ~at in let num_masks = num_masks in
let at = at + 22 in
let* masks, at = decode_list (decode_event_mask) num_masks buf ~at in
ignore orig;
Some ({ masks }, at);;
type barrier_release_pointer_info = { deviceid : device_id; barrier : Xfixes.barrier; eventid : int; } [@@deriving sexp];;
let decode_barrier_release_pointer_info buf ~at : (barrier_release_pointer_info * int) option = let orig = at in let* deviceid, at = decode_device_id buf ~at in
let at = at + 2 in
let* barrier, at = Xfixes.decode_barrier buf ~at in
let* eventid, at = decode_int32 buf ~at in
ignore orig;
Some ({ deviceid; barrier; eventid }, at);;
let encode_barrier_release_pointer_info buf (v : barrier_release_pointer_info) ~at : int option = let orig = at in let* at = encode_device_id buf v.deviceid ~at in let at = at + 2 in let* at = Xfixes.encode_barrier buf v.barrier ~at in let* at = encode_int32 buf v.eventid ~at in ignore orig; Some at;;

let encode_xi_barrier_release_pointer ~(barriers : barrier_release_pointer_info list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 61 ~at in
let* at = encode_int32 buf (identity ((* invalid_argument *) List.length barriers)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_list encode_barrier_release_pointer_info buf barriers ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type device_valuator_event = { device_id : int; device_state : int; num_valuators : int; first_valuator : int; valuators : int list; } [@@deriving sexp];;
type more_events_mask = [ `More_events ] list [@@deriving sexp];;
let more_events_mask_mask_of_int64 mask : more_events_mask option = let of_int = function 7 -> Some `More_events | _ -> None in mask_of_int of_int mask;;
let more_events_mask_int_of_mask : more_events_mask -> int = let to_bit = function `More_events -> 7 in int_of_mask to_bit;;
type device_key_press_event = { detail : char; time : Xproto.timestamp; root : Xproto.window; event : Xproto.window; child : Xproto.window_enum alt_enum; root_x : int; root_y : int; event_x : int; event_y : int; state : Xproto.key_but_mask; same_screen : bool; device_id : (more_events_mask, int) mask; } [@@deriving sexp];;
type device_key_release_event = device_key_press_event [@@deriving sexp];;
type device_button_press_event = device_key_press_event [@@deriving sexp];;
type device_button_release_event = device_key_press_event [@@deriving sexp];;
type device_motion_notify_event = device_key_press_event [@@deriving sexp];;
type device_focus_in_event = { detail : Xproto.notify_detail_enum; time : Xproto.timestamp; window : Xproto.window; mode : Xproto.notify_mode_enum; device_id : int; } [@@deriving sexp];;
type device_focus_out_event = device_focus_in_event [@@deriving sexp];;
type proximity_in_event = device_key_press_event [@@deriving sexp];;
type proximity_out_event = device_key_press_event [@@deriving sexp];;
type classes_reported_mask = [ `Out_of_proximity | `Device_mode_absolute | `Reporting_valuators | `Reporting_buttons | `Reporting_keys ] list [@@deriving sexp];;
let classes_reported_mask_mask_of_int64 mask : classes_reported_mask option = let of_int = function 7 -> Some `Out_of_proximity | 6 -> Some `Device_mode_absolute | 2 -> Some `Reporting_valuators | 1 -> Some `Reporting_buttons | 0 -> Some `Reporting_keys | _ -> None in mask_of_int of_int mask;;
let classes_reported_mask_int_of_mask : classes_reported_mask -> int = let to_bit = function `Out_of_proximity -> 7 | `Device_mode_absolute -> 6 | `Reporting_valuators -> 2 | `Reporting_buttons -> 1 | `Reporting_keys -> 0 in int_of_mask to_bit;;
type device_state_notify_event = { device_id : (more_events_mask, char) mask; time : Xproto.timestamp; num_keys : int; num_buttons : int; num_valuators : int; classes_reported : classes_reported_mask; buttons : int list; keys : int list; valuators : int list; } [@@deriving sexp];;
type device_mapping_notify_event = { device_id : char; request : Xproto.mapping_enum; first_keycode : key_code; count : int; time : Xproto.timestamp; } [@@deriving sexp];;
type change_device_enum = [ `New_pointer | `New_keyboard ] [@@deriving sexp];;
let change_device_enum_of_int : int -> [> change_device_enum ] option = function 0 -> Some `New_pointer | 1 -> Some `New_keyboard | n -> Printf.printf "unknown change_device_enum: %d\n" n; None;;
let change_device_int_of_enum : change_device_enum -> int = function `New_pointer -> 0 | `New_keyboard -> 1;;
type change_device_notify_event = { device_id : char; time : Xproto.timestamp; request : change_device_enum; } [@@deriving sexp];;
type device_key_state_notify_event = { device_id : (more_events_mask, char) mask; keys : int list; } [@@deriving sexp];;
type device_button_state_notify_event = { device_id : (more_events_mask, char) mask; buttons : int list; } [@@deriving sexp];;
type device_change_enum = [ `Added | `Removed | `Enabled | `Disabled | `Unrecoverable | `Control_changed ] [@@deriving sexp];;
let device_change_enum_of_int : int -> [> device_change_enum ] option = function 0 -> Some `Added | 1 -> Some `Removed | 2 -> Some `Enabled | 3 -> Some `Disabled | 4 -> Some `Unrecoverable | 5 -> Some `Control_changed | n -> Printf.printf "unknown device_change_enum: %d\n" n; None;;
let device_change_int_of_enum : device_change_enum -> int = function `Added -> 0 | `Removed -> 1 | `Enabled -> 2 | `Disabled -> 3 | `Unrecoverable -> 4 | `Control_changed -> 5;;
type device_presence_notify_event = { time : Xproto.timestamp; devchange : device_change_enum; device_id : char; control : int; } [@@deriving sexp];;
type device_property_notify_event = { state : Xproto.property_enum; time : Xproto.timestamp; property : Xproto.atom; device_id : int; } [@@deriving sexp];;
type change_reason_enum = [ `Slave_switch | `Device_change ] [@@deriving sexp];;
let change_reason_enum_of_int : int -> [> change_reason_enum ] option = function 1 -> Some `Slave_switch | 2 -> Some `Device_change | n -> Printf.printf "unknown change_reason_enum: %d\n" n; None;;
let change_reason_int_of_enum : change_reason_enum -> int = function `Slave_switch -> 1 | `Device_change -> 2;;
type device_changed_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; sourceid : device_enum alt_enum; reason : change_reason_enum; classes : device_class list; } [@@deriving sexp];;
type key_event_flags_mask = [ `Key_repeat ] list [@@deriving sexp];;
let key_event_flags_mask_of_int64 mask : key_event_flags_mask option = let of_int = function 16 -> Some `Key_repeat | _ -> None in mask_of_int of_int mask;;
let key_event_flags_int_of_mask : key_event_flags_mask -> int = let to_bit = function `Key_repeat -> 16 in int_of_mask to_bit;;
type key_press_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; detail : int; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; sourceid : device_enum alt_enum; flags : key_event_flags_mask; mods : modifier_info; group : group_info; button_mask : int list; valuator_mask : int list; axisvalues : fp3232 list; } [@@deriving sexp];;
type key_release_event = key_press_event [@@deriving sexp];;
type pointer_event_flags_mask = [ `Pointer_emulated ] list [@@deriving sexp];;
let pointer_event_flags_mask_of_int64 mask : pointer_event_flags_mask option = let of_int = function 16 -> Some `Pointer_emulated | _ -> None in mask_of_int of_int mask;;
let pointer_event_flags_int_of_mask : pointer_event_flags_mask -> int = let to_bit = function `Pointer_emulated -> 16 in int_of_mask to_bit;;
type button_press_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; detail : int; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; sourceid : device_enum alt_enum; flags : pointer_event_flags_mask; mods : modifier_info; group : group_info; button_mask : int list; valuator_mask : int list; axisvalues : fp3232 list; } [@@deriving sexp];;
type button_release_event = button_press_event [@@deriving sexp];;
type motion_event = button_press_event [@@deriving sexp];;
type notify_mode_enum = [ `Normal | `Grab | `Ungrab | `While_grabbed | `Passive_grab | `Passive_ungrab ] [@@deriving sexp];;
let notify_mode_enum_of_int : int -> [> notify_mode_enum ] option = function 0 -> Some `Normal | 1 -> Some `Grab | 2 -> Some `Ungrab | 3 -> Some `While_grabbed | 4 -> Some `Passive_grab | 5 -> Some `Passive_ungrab | n -> Printf.printf "unknown notify_mode_enum: %d\n" n; None;;
let notify_mode_int_of_enum : notify_mode_enum -> int = function `Normal -> 0 | `Grab -> 1 | `Ungrab -> 2 | `While_grabbed -> 3 | `Passive_grab -> 4 | `Passive_ungrab -> 5;;
type notify_detail_enum = [ `Ancestor | `Virtual | `Inferior | `Nonlinear | `Nonlinear_virtual | `Pointer | `Pointer_root | `None ] [@@deriving sexp];;
let notify_detail_enum_of_int : int -> [> notify_detail_enum ] option = function 0 -> Some `Ancestor | 1 -> Some `Virtual | 2 -> Some `Inferior | 3 -> Some `Nonlinear | 4 -> Some `Nonlinear_virtual | 5 -> Some `Pointer | 6 -> Some `Pointer_root | 7 -> Some `None | n -> Printf.printf "unknown notify_detail_enum: %d\n" n; None;;
let notify_detail_int_of_enum : notify_detail_enum -> int = function `Ancestor -> 0 | `Virtual -> 1 | `Inferior -> 2 | `Nonlinear -> 3 | `Nonlinear_virtual -> 4 | `Pointer -> 5 | `Pointer_root -> 6 | `None -> 7;;
type enter_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; sourceid : device_enum alt_enum; mode : notify_mode_enum; detail : notify_detail_enum; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; same_screen : bool; focus : bool; mods : modifier_info; group : group_info; buttons : int list; } [@@deriving sexp];;
type leave_event = enter_event [@@deriving sexp];;
type focus_in_event = enter_event [@@deriving sexp];;
type focus_out_event = enter_event [@@deriving sexp];;
type hierarchy_mask = [ `Master_added | `Master_removed | `Slave_added | `Slave_removed | `Slave_attached | `Slave_detached | `Device_enabled | `Device_disabled ] list [@@deriving sexp];;
let hierarchy_mask_mask_of_int64 mask : hierarchy_mask option = let of_int = function 0 -> Some `Master_added | 1 -> Some `Master_removed | 2 -> Some `Slave_added | 3 -> Some `Slave_removed | 4 -> Some `Slave_attached | 5 -> Some `Slave_detached | 6 -> Some `Device_enabled | 7 -> Some `Device_disabled | _ -> None in mask_of_int of_int mask;;
let hierarchy_mask_int_of_mask : hierarchy_mask -> int = let to_bit = function `Master_added -> 0 | `Master_removed -> 1 | `Slave_added -> 2 | `Slave_removed -> 3 | `Slave_attached -> 4 | `Slave_detached -> 5 | `Device_enabled -> 6 | `Device_disabled -> 7 in int_of_mask to_bit;;
type hierarchy_info = { deviceid : device_enum alt_enum; attachment : device_enum alt_enum; type_ : device_type_enum; enabled : bool; flags : hierarchy_mask; } [@@deriving sexp];;
let decode_hierarchy_info buf ~at : (hierarchy_info * int) option = let orig = at in let* deviceid, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* attachment, at = decode_alt_enum decode_device_id identity device_enum_of_int buf ~at in
let* type_, at = decode_enum decode_uint8 identity device_type_enum_of_int buf ~at in
let* enabled, at = decode_bool buf ~at in
let at = at + 2 in
let* flags, at = decode_mask decode_int32 Int64.of_int hierarchy_mask_mask_of_int64 buf ~at in
ignore orig;
Some ({ deviceid; attachment; type_; enabled; flags }, at);;
let encode_hierarchy_info buf (v : hierarchy_info) ~at : int option = let orig = at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid ~at in let* at = encode_alt_enum encode_device_id identity device_int_of_enum buf v.attachment ~at in let* at = encode_enum encode_uint8 identity device_type_int_of_enum buf v.type_ ~at in let* at = encode_bool buf v.enabled ~at in let at = at + 2 in let* at = encode_mask encode_int32 identity hierarchy_mask_int_of_mask buf v.flags ~at in ignore orig; Some at;;

type hierarchy_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; flags : hierarchy_mask; infos : hierarchy_info list; } [@@deriving sexp];;
type property_flag_enum = [ `Deleted | `Created | `Modified ] [@@deriving sexp];;
let property_flag_enum_of_int : int -> [> property_flag_enum ] option = function 0 -> Some `Deleted | 1 -> Some `Created | 2 -> Some `Modified | n -> Printf.printf "unknown property_flag_enum: %d\n" n; None;;
let property_flag_int_of_enum : property_flag_enum -> int = function `Deleted -> 0 | `Created -> 1 | `Modified -> 2;;
type property_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; property : Xproto.atom; what : property_flag_enum; } [@@deriving sexp];;
type raw_key_press_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; detail : int; sourceid : device_id; flags : key_event_flags_mask; valuator_mask : int list; axisvalues : fp3232 list; axisvalues_raw : fp3232 list; } [@@deriving sexp];;
type raw_key_release_event = raw_key_press_event [@@deriving sexp];;
type raw_button_press_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; detail : int; sourceid : device_id; flags : pointer_event_flags_mask; valuator_mask : int list; axisvalues : fp3232 list; axisvalues_raw : fp3232 list; } [@@deriving sexp];;
type raw_button_release_event = raw_button_press_event [@@deriving sexp];;
type raw_motion_event = raw_button_press_event [@@deriving sexp];;
type touch_event_flags_mask = [ `Touch_pending_end | `Touch_emulating_pointer ] list [@@deriving sexp];;
let touch_event_flags_mask_of_int64 mask : touch_event_flags_mask option = let of_int = function 16 -> Some `Touch_pending_end | 17 -> Some `Touch_emulating_pointer | _ -> None in mask_of_int of_int mask;;
let touch_event_flags_int_of_mask : touch_event_flags_mask -> int = let to_bit = function `Touch_pending_end -> 16 | `Touch_emulating_pointer -> 17 in int_of_mask to_bit;;
type touch_begin_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; detail : int; root : Xproto.window; event : Xproto.window; child : Xproto.window; root_x : fp1616; root_y : fp1616; event_x : fp1616; event_y : fp1616; sourceid : device_enum alt_enum; flags : touch_event_flags_mask; mods : modifier_info; group : group_info; button_mask : int list; valuator_mask : int list; axisvalues : fp3232 list; } [@@deriving sexp];;
type touch_update_event = touch_begin_event [@@deriving sexp];;
type touch_end_event = touch_begin_event [@@deriving sexp];;
type touch_ownership_flags_enum = [ `None ] [@@deriving sexp];;
let touch_ownership_flags_enum_of_int : int -> [> touch_ownership_flags_enum ] option = function 0 -> Some `None | n -> Printf.printf "unknown touch_ownership_flags_enum: %d\n" n; None;;
let touch_ownership_flags_int_of_enum : touch_ownership_flags_enum -> int = function `None -> 0;;
type touch_ownership_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; touchid : int; root : Xproto.window; event : Xproto.window; child : Xproto.window; sourceid : device_enum alt_enum; flags : touch_ownership_flags_enum; } [@@deriving sexp];;
type raw_touch_begin_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; detail : int; sourceid : device_id; flags : touch_event_flags_mask; valuator_mask : int list; axisvalues : fp3232 list; axisvalues_raw : fp3232 list; } [@@deriving sexp];;
type raw_touch_update_event = raw_touch_begin_event [@@deriving sexp];;
type raw_touch_end_event = raw_touch_begin_event [@@deriving sexp];;
type barrier_flags_mask = [ `Pointer_released | `Device_is_grabbed ] list [@@deriving sexp];;
let barrier_flags_mask_of_int64 mask : barrier_flags_mask option = let of_int = function 0 -> Some `Pointer_released | 1 -> Some `Device_is_grabbed | _ -> None in mask_of_int of_int mask;;
let barrier_flags_int_of_mask : barrier_flags_mask -> int = let to_bit = function `Pointer_released -> 0 | `Device_is_grabbed -> 1 in int_of_mask to_bit;;
type barrier_hit_event = { deviceid : device_enum alt_enum; time : Xproto.time_enum alt_enum; eventid : int; root : Xproto.window; event : Xproto.window; barrier : Xfixes.barrier; dtime : int; flags : barrier_flags_mask; sourceid : device_enum alt_enum; root_x : fp1616; root_y : fp1616; dx : fp3232; dy : fp3232; } [@@deriving sexp];;
type barrier_leave_event = barrier_hit_event [@@deriving sexp];;
type event_for_send = Device_valuator of device_valuator_event | Device_key_press of device_key_press_event | Device_key_release of device_key_release_event | Device_button_press of device_button_press_event | Device_button_release of device_button_release_event | Device_motion_notify of device_motion_notify_event | Device_focus_in of device_focus_in_event | Device_focus_out of device_focus_out_event | Proximity_in of proximity_in_event | Proximity_out of proximity_out_event | Device_state_notify of device_state_notify_event | Device_mapping_notify of device_mapping_notify_event | Change_device_notify of change_device_notify_event | Device_key_state_notify of device_key_state_notify_event | Device_button_state_notify of device_button_state_notify_event | Device_presence_notify of device_presence_notify_event | Device_property_notify of device_property_notify_event [@@deriving sexp];;
let encode_send_extension_event ~(destination : Xproto.window) ~(device_id : int) ~(propagate : bool) ~(events : event_for_send list) ~(classes : event_class list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 31 ~at in
let* at = Xproto.encode_window buf destination ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf device_id ~at in
let* at = encode_bool buf propagate ~at in
let* at = encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes)) ~at in
let* at = encode_uint8 buf (identity ((* invalid_argument *) List.length events)) ~at in
let at = at + 3 in
let* at = encode_list encode_event_for_send buf events ~at in
let* at = encode_list encode_event_class buf classes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type device_error = unit [@@deriving sexp];;
type event_error = unit [@@deriving sexp];;
type mode_error = unit [@@deriving sexp];;
type device_busy_error = unit [@@deriving sexp];;
type class_error = unit [@@deriving sexp];;
end
module[@warning "-27"] Xprint = struct
type string8 = char [@@deriving sexp];;
let decode_string8 = decode_char;;
let encode_string8 = encode_char;;

type printer = { name : string; description : string; } [@@deriving sexp];;
let decode_printer buf ~at : (printer * int) option = let orig = at in let* name_len, at = decode_int32 buf ~at in let name_len = name_len in
let* name, at = decode_string name_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* desc_len, at = decode_int32 buf ~at in let desc_len = desc_len in
let* description, at = decode_string desc_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ name; description }, at);;
let encode_printer buf (v : printer) ~at : int option = let orig = at in let* at = encode_int32 buf (identity (String.length v.name)) ~at in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in let* at = encode_int32 buf (identity (String.length v.description)) ~at in let* at = encode_string buf v.description ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type pcontext = xid [@@deriving sexp];;
let decode_pcontext = decode_xid;;
let encode_pcontext = encode_xid;;

type get_doc_enum = [ `Finished | `Second_consumer ] [@@deriving sexp];;
let get_doc_enum_of_int : int -> [> get_doc_enum ] option = function 0 -> Some `Finished | 1 -> Some `Second_consumer | n -> Printf.printf "unknown get_doc_enum: %d\n" n; None;;
let get_doc_int_of_enum : get_doc_enum -> int = function `Finished -> 0 | `Second_consumer -> 1;;
type ev_mask = ([ `Print_mask | `Attribute_mask ] list, [ `No_event_mask ]) mask [@@deriving sexp];;let ev_mask_mask_of_int64 mask : ev_mask option = let of_enum = function 0L -> Some `No_event_mask | _ -> None in let of_mask = function 0 -> Some `Print_mask | 1 -> Some `Attribute_mask | _ -> None in mask_value_of_int of_mask of_enum mask;;
let ev_mask_int_of_mask (mask : ev_mask) : int = let to_enum = function `No_event_mask -> 0 in let to_mask = function `Print_mask -> 0 | `Attribute_mask -> 1 in mask_value_to_int to_mask to_enum mask;;
type detail_enum = [ `Start_job_notify | `End_job_notify | `Start_doc_notify | `End_doc_notify | `Start_page_notify | `End_page_notify ] [@@deriving sexp];;
let detail_enum_of_int : int -> [> detail_enum ] option = function 1 -> Some `Start_job_notify | 2 -> Some `End_job_notify | 3 -> Some `Start_doc_notify | 4 -> Some `End_doc_notify | 5 -> Some `Start_page_notify | 6 -> Some `End_page_notify | n -> Printf.printf "unknown detail_enum: %d\n" n; None;;
let detail_int_of_enum : detail_enum -> int = function `Start_job_notify -> 1 | `End_job_notify -> 2 | `Start_doc_notify -> 3 | `End_doc_notify -> 4 | `Start_page_notify -> 5 | `End_page_notify -> 6;;
type attr_enum = [ `Job_attr | `Doc_attr | `Page_attr | `Printer_attr | `Server_attr | `Medium_attr | `Spooler_attr ] [@@deriving sexp];;
let attr_enum_of_int : int -> [> attr_enum ] option = function 1 -> Some `Job_attr | 2 -> Some `Doc_attr | 3 -> Some `Page_attr | 4 -> Some `Printer_attr | 5 -> Some `Server_attr | 6 -> Some `Medium_attr | 7 -> Some `Spooler_attr | n -> Printf.printf "unknown attr_enum: %d\n" n; None;;
let attr_int_of_enum : attr_enum -> int = function `Job_attr -> 1 | `Doc_attr -> 2 | `Page_attr -> 3 | `Printer_attr -> 4 | `Server_attr -> 5 | `Medium_attr -> 6 | `Spooler_attr -> 7;;
type print_query_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_print_query_version  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_query_version_reply length buf ~at : (print_query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major_version, at = decode_uint16 buf ~at in
let* minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
type print_get_printer_list_reply = { printers : printer list; } [@@deriving sexp];;
let encode_print_get_printer_list ~(printer_name : string) ~(locale : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_int32 buf (identity (String.length printer_name)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity (String.length locale)) ~at in
let* at = encode_string buf printer_name ~at in
let* at = encode_string buf locale ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_printer_list_reply length buf ~at : (print_get_printer_list_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* list_count, at = decode_int32 buf ~at in let list_count = list_count in
let at = at + 20 in
let* printers, at = decode_list (decode_printer) list_count buf ~at in
ignore orig;
Some ({ printers }, at);;
let encode_print_rehash_printer_list  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_create_context ~(context_id : int) ~(printer_name : string) ~(locale : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_int32 buf context_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity (String.length printer_name)) ~at in
let* at = encode_int32 buf (identity (String.length locale)) ~at in
let* at = encode_string buf printer_name ~at in
let* at = encode_string buf locale ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_set_context ~(context : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_int32 buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type print_get_context_reply = { context : int; } [@@deriving sexp];;
let encode_print_get_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_context_reply length buf ~at : (print_get_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context, at = decode_int32 buf ~at in
ignore orig;
Some ({ context }, at);;
let encode_print_destroy_context ~(context : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_int32 buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type print_get_screen_of_context_reply = { root : Xproto.window; } [@@deriving sexp];;
let encode_print_get_screen_of_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_screen_of_context_reply length buf ~at : (print_get_screen_of_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* root, at = Xproto.decode_window buf ~at in
ignore orig;
Some ({ root }, at);;
let encode_print_start_job ~(output_mode : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_uint8 buf output_mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_end_job ~(cancel : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_bool buf cancel ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_start_doc ~(driver_mode : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_uint8 buf driver_mode ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_end_doc ~(cancel : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_bool buf cancel ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_put_document_data ~(drawable : Xproto.drawable) ~(data : char list) ~(doc_format : string) ~(options : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity ((* Parsetree.Byte *) List.length data)) ~at in
let* at = encode_uint16 buf (identity (String.length doc_format)) ~at in
let* at = encode_uint16 buf (identity (String.length options)) ~at in
let* at = encode_list encode_char buf data ~at in
let* at = encode_string buf doc_format ~at in
let* at = encode_string buf options ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type print_get_document_data_reply = { status_code : int; finished_flag : int; data : char list; } [@@deriving sexp];;
let encode_print_get_document_data ~(context : pcontext) ~(max_bytes : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf max_bytes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_document_data_reply length buf ~at : (print_get_document_data_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* status_code, at = decode_int32 buf ~at in
let* finished_flag, at = decode_int32 buf ~at in
let* data_len, at = decode_int32 buf ~at in let data_len = data_len in
let at = at + 12 in
let* data, at = decode_list (decode_char) data_len buf ~at in
ignore orig;
Some ({ status_code; finished_flag; data }, at);;
let encode_print_start_page ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_end_page ~(cancel : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_bool buf cancel ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_print_select_input ~(context : pcontext) ~(event_mask : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf event_mask ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type print_input_selected_reply = { event_mask : int; all_events_mask : int; } [@@deriving sexp];;
let encode_print_input_selected ~(context : pcontext)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_input_selected_reply length buf ~at : (print_input_selected_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* event_mask, at = decode_int32 buf ~at in
let* all_events_mask, at = decode_int32 buf ~at in
ignore orig;
Some ({ event_mask; all_events_mask }, at);;
type print_get_attributes_reply = { attributes : string; } [@@deriving sexp];;
let encode_print_get_attributes ~(context : pcontext) ~(pool : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf pool ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_attributes_reply length buf ~at : (print_get_attributes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* string_len, at = decode_int32 buf ~at in let string_len = string_len in
let at = at + 20 in
let* attributes, at = decode_string string_len buf ~at in
ignore orig;
Some ({ attributes }, at);;
type print_get_one_attributes_reply = { value : string; } [@@deriving sexp];;
let encode_print_get_one_attributes ~(context : pcontext) ~(pool : int) ~(name : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity (String.length name)) ~at in
let* at = encode_uint8 buf pool ~at in
let at = at + 3 in
let* at = encode_string buf name ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_one_attributes_reply length buf ~at : (print_get_one_attributes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* value_len, at = decode_int32 buf ~at in let value_len = value_len in
let at = at + 20 in
let* value, at = decode_string value_len buf ~at in
ignore orig;
Some ({ value }, at);;
let encode_print_set_attributes ~(context : pcontext) ~(string_len : int) ~(pool : int) ~(rule : int) ~(attributes : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf string_len ~at in
let* at = encode_uint8 buf pool ~at in
let* at = encode_uint8 buf rule ~at in
let at = at + 2 in
let* at = encode_string buf attributes ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type print_get_page_dimensions_reply = { width : int; height : int; offset_x : int; offset_y : int; reproducible_width : int; reproducible_height : int; } [@@deriving sexp];;
let encode_print_get_page_dimensions ~(context : pcontext)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_page_dimensions_reply length buf ~at : (print_get_page_dimensions_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* offset_x, at = decode_uint16 buf ~at in
let* offset_y, at = decode_uint16 buf ~at in
let* reproducible_width, at = decode_uint16 buf ~at in
let* reproducible_height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ width; height; offset_x; offset_y; reproducible_width; reproducible_height }, at);;
type print_query_screens_reply = { roots : Xproto.window list; } [@@deriving sexp];;
let encode_print_query_screens  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_query_screens_reply length buf ~at : (print_query_screens_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* list_count, at = decode_int32 buf ~at in let list_count = list_count in
let at = at + 20 in
let* roots, at = decode_list (Xproto.decode_window) list_count buf ~at in
ignore orig;
Some ({ roots }, at);;
type print_set_image_resolution_reply = { status : bool; previous_resolutions : int; } [@@deriving sexp];;
let encode_print_set_image_resolution ~(context : pcontext) ~(image_resolution : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 23 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf image_resolution ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_set_image_resolution_reply length buf ~at : (print_set_image_resolution_reply * int) option = let orig = at in let at = at + 1 in
let* status, at = decode_bool buf ~at in
let at = at + 6 in
let* previous_resolutions, at = decode_uint16 buf ~at in
ignore orig;
Some ({ status; previous_resolutions }, at);;
type print_get_image_resolution_reply = { image_resolution : int; } [@@deriving sexp];;
let encode_print_get_image_resolution ~(context : pcontext)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 24 ~at in
let* at = encode_pcontext buf context ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_print_get_image_resolution_reply length buf ~at : (print_get_image_resolution_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* image_resolution, at = decode_uint16 buf ~at in
ignore orig;
Some ({ image_resolution }, at);;
type notify_event = { detail : int; context : pcontext; cancel : bool; } [@@deriving sexp];;
type attribut_notify_event = { detail : int; context : pcontext; } [@@deriving sexp];;
type bad_context_error = unit [@@deriving sexp];;
type bad_sequence_error = unit [@@deriving sexp];;
end
module[@warning "-27"] Xselinux = struct
type query_version_reply = { server_major : int; server_minor : int; } [@@deriving sexp];;
let encode_query_version ~(client_major : int) ~(client_minor : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint8 buf client_major ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint8 buf client_minor ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* server_major, at = decode_uint16 buf ~at in
let* server_minor, at = decode_uint16 buf ~at in
ignore orig;
Some ({ server_major; server_minor }, at);;
let encode_set_device_create_context ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = encode_int32 buf (identity (String.length context)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_create_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_device_create_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_create_context_reply length buf ~at : (get_device_create_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
let encode_set_device_context ~(device : int) ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_int32 buf device ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf (identity (String.length context)) ~at in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_device_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_device_context ~(device : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_int32 buf device ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_device_context_reply length buf ~at : (get_device_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
let encode_set_window_create_context ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_int32 buf (identity (String.length context)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_window_create_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_window_create_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_window_create_context_reply length buf ~at : (get_window_create_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type get_window_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_window_context ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_window_context_reply length buf ~at : (get_window_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type list_item = { name : Xproto.atom; object_context : string; data_context : string; } [@@deriving sexp];;
let decode_list_item buf ~at : (list_item * int) option = let orig = at in let* name, at = Xproto.decode_atom buf ~at in
let* object_context_len, at = decode_int32 buf ~at in let object_context_len = object_context_len in
let* data_context_len, at = decode_int32 buf ~at in let data_context_len = data_context_len in
let* object_context, at = decode_string object_context_len buf ~at in
let at = at + ((at - orig) mod 4) in
let* data_context, at = decode_string data_context_len buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ name; object_context; data_context }, at);;
let encode_list_item buf (v : list_item) ~at : int option = let orig = at in let* at = Xproto.encode_atom buf v.name ~at in let* at = encode_int32 buf (identity (String.length v.object_context)) ~at in let* at = encode_int32 buf (identity (String.length v.data_context)) ~at in let* at = encode_string buf v.object_context ~at in let at = at + ((at - orig) mod 4) in let* at = encode_string buf v.data_context ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

let encode_set_property_create_context ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_int32 buf (identity (String.length context)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_property_create_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_property_create_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_property_create_context_reply length buf ~at : (get_property_create_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
let encode_set_property_use_context ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = encode_int32 buf (identity (String.length context)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_property_use_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_property_use_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_property_use_context_reply length buf ~at : (get_property_use_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type get_property_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_property_context ~(window : Xproto.window) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_property_context_reply length buf ~at : (get_property_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type get_property_data_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_property_data_context ~(window : Xproto.window) ~(property : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf property ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_property_data_context_reply length buf ~at : (get_property_data_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type list_properties_reply = { properties : list_item list; } [@@deriving sexp];;
let encode_list_properties ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_properties_reply length buf ~at : (list_properties_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* properties_len, at = decode_int32 buf ~at in let properties_len = properties_len in
let at = at + 20 in
let* properties, at = decode_list (decode_list_item) properties_len buf ~at in
ignore orig;
Some ({ properties }, at);;
let encode_set_selection_create_context ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_int32 buf (identity (String.length context)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_selection_create_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_selection_create_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_selection_create_context_reply length buf ~at : (get_selection_create_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
let encode_set_selection_use_context ~(context : string)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_int32 buf (identity (String.length context)) ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_string buf context ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_selection_use_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_selection_use_context  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_selection_use_context_reply length buf ~at : (get_selection_use_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type get_selection_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_selection_context ~(selection : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = Xproto.encode_atom buf selection ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_selection_context_reply length buf ~at : (get_selection_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type get_selection_data_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_selection_data_context ~(selection : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 20 ~at in
let* at = Xproto.encode_atom buf selection ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_selection_data_context_reply length buf ~at : (get_selection_data_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
type list_selections_reply = { selections : list_item list; } [@@deriving sexp];;
let encode_list_selections  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 21 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_selections_reply length buf ~at : (list_selections_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* selections_len, at = decode_int32 buf ~at in let selections_len = selections_len in
let at = at + 20 in
let* selections, at = decode_list (decode_list_item) selections_len buf ~at in
ignore orig;
Some ({ selections }, at);;
type get_client_context_reply = { context : string; } [@@deriving sexp];;
let encode_get_client_context ~(resource : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 22 ~at in
let* at = encode_int32 buf resource ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_client_context_reply length buf ~at : (get_client_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* context_len, at = decode_int32 buf ~at in let context_len = context_len in
let at = at + 20 in
let* context, at = decode_string context_len buf ~at in
ignore orig;
Some ({ context }, at);;
end
module[@warning "-27"] Xtest = struct
type get_version_reply = { major_version : int; minor_version : int; } [@@deriving sexp];;
let encode_get_version ~(major_version : int) ~(minor_version : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in
let* at = encode_uint8 buf major_version ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 1 in
let* at = encode_uint16 buf minor_version ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_version_reply length buf ~at : (get_version_reply * int) option = let orig = at in let at = at + 1 in
let* major_version, at = decode_uint8 buf ~at in
let at = at + 6 in
let* minor_version, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major_version; minor_version }, at);;
type cursor_enum = [ `None | `Current ] [@@deriving sexp];;
let cursor_enum_of_int : int -> [> cursor_enum ] option = function 0 -> Some `None | 1 -> Some `Current | n -> Printf.printf "unknown cursor_enum: %d\n" n; None;;
let cursor_int_of_enum : cursor_enum -> int = function `None -> 0 | `Current -> 1;;
type compare_cursor_reply = { same : bool; } [@@deriving sexp];;
let encode_compare_cursor ~(window : Xproto.window) ~(cursor : Xproto.cursor)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_cursor buf cursor ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_compare_cursor_reply length buf ~at : (compare_cursor_reply * int) option = let orig = at in let at = at + 1 in
let* same, at = decode_bool buf ~at in
let at = at + 6 in
ignore orig;
Some ({ same }, at);;
let encode_fake_input ~(type_ : char) ~(detail : char) ~(time : int) ~(root : Xproto.window) ~(root_x : int) ~(root_y : int) ~(deviceid : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_char buf type_ ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_char buf detail ~at in
let at = at + 2 in
let* at = encode_int32 buf time ~at in
let* at = Xproto.encode_window buf root ~at in
let at = at + 8 in
let* at = encode_int16 buf root_x ~at in
let* at = encode_int16 buf root_y ~at in
let at = at + 7 in
let* at = encode_uint8 buf deviceid ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_grab_control ~(impervious : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_bool buf impervious ~at in
(* reserve request length *)
let at = at + 2 in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
end
module[@warning "-27"] Xv = struct
type port = xid [@@deriving sexp];;
let decode_port = decode_xid;;
let encode_port = encode_xid;;

type encoding = xid [@@deriving sexp];;
let decode_encoding = decode_xid;;
let encode_encoding = encode_xid;;

type type_mask = [ `Input_mask | `Output_mask | `Video_mask | `Still_mask | `Image_mask ] list [@@deriving sexp];;
let type_mask_of_int64 mask : type_mask option = let of_int = function 0 -> Some `Input_mask | 1 -> Some `Output_mask | 2 -> Some `Video_mask | 3 -> Some `Still_mask | 4 -> Some `Image_mask | _ -> None in mask_of_int of_int mask;;
let type_int_of_mask : type_mask -> int = let to_bit = function `Input_mask -> 0 | `Output_mask -> 1 | `Video_mask -> 2 | `Still_mask -> 3 | `Image_mask -> 4 in int_of_mask to_bit;;
type image_format_info_type_enum = [ `Rgb | `Yuv ] [@@deriving sexp];;
let image_format_info_type_enum_of_int : int -> [> image_format_info_type_enum ] option = function 0 -> Some `Rgb | 1 -> Some `Yuv | n -> Printf.printf "unknown image_format_info_type_enum: %d\n" n; None;;
let image_format_info_type_int_of_enum : image_format_info_type_enum -> int = function `Rgb -> 0 | `Yuv -> 1;;
type image_format_info_format_enum = [ `Packed | `Planar ] [@@deriving sexp];;
let image_format_info_format_enum_of_int : int -> [> image_format_info_format_enum ] option = function 0 -> Some `Packed | 1 -> Some `Planar | n -> Printf.printf "unknown image_format_info_format_enum: %d\n" n; None;;
let image_format_info_format_int_of_enum : image_format_info_format_enum -> int = function `Packed -> 0 | `Planar -> 1;;
type attribute_flag_mask = [ `Gettable | `Settable ] list [@@deriving sexp];;
let attribute_flag_mask_of_int64 mask : attribute_flag_mask option = let of_int = function 0 -> Some `Gettable | 1 -> Some `Settable | _ -> None in mask_of_int of_int mask;;
let attribute_flag_int_of_mask : attribute_flag_mask -> int = let to_bit = function `Gettable -> 0 | `Settable -> 1 in int_of_mask to_bit;;
type video_notify_reason_enum = [ `Started | `Stopped | `Busy | `Preempted | `Hard_error ] [@@deriving sexp];;
let video_notify_reason_enum_of_int : int -> [> video_notify_reason_enum ] option = function 0 -> Some `Started | 1 -> Some `Stopped | 2 -> Some `Busy | 3 -> Some `Preempted | 4 -> Some `Hard_error | n -> Printf.printf "unknown video_notify_reason_enum: %d\n" n; None;;
let video_notify_reason_int_of_enum : video_notify_reason_enum -> int = function `Started -> 0 | `Stopped -> 1 | `Busy -> 2 | `Preempted -> 3 | `Hard_error -> 4;;
type scanline_order_enum = [ `Top_to_bottom | `Bottom_to_top ] [@@deriving sexp];;
let scanline_order_enum_of_int : int -> [> scanline_order_enum ] option = function 0 -> Some `Top_to_bottom | 1 -> Some `Bottom_to_top | n -> Printf.printf "unknown scanline_order_enum: %d\n" n; None;;
let scanline_order_int_of_enum : scanline_order_enum -> int = function `Top_to_bottom -> 0 | `Bottom_to_top -> 1;;
type grab_port_status_enum = [ `Success | `Bad_extension | `Already_grabbed | `Invalid_time | `Bad_reply | `Bad_alloc ] [@@deriving sexp];;
let grab_port_status_enum_of_int : int -> [> grab_port_status_enum ] option = function 0 -> Some `Success | 1 -> Some `Bad_extension | 2 -> Some `Already_grabbed | 3 -> Some `Invalid_time | 4 -> Some `Bad_reply | 5 -> Some `Bad_alloc | n -> Printf.printf "unknown grab_port_status_enum: %d\n" n; None;;
let grab_port_status_int_of_enum : grab_port_status_enum -> int = function `Success -> 0 | `Bad_extension -> 1 | `Already_grabbed -> 2 | `Invalid_time -> 3 | `Bad_reply -> 4 | `Bad_alloc -> 5;;
type rational = { numerator : int; denominator : int; } [@@deriving sexp];;
let decode_rational buf ~at : (rational * int) option = let orig = at in let* numerator, at = decode_int32 buf ~at in
let* denominator, at = decode_int32 buf ~at in
ignore orig;
Some ({ numerator; denominator }, at);;
let encode_rational buf (v : rational) ~at : int option = let orig = at in let* at = encode_int32 buf v.numerator ~at in let* at = encode_int32 buf v.denominator ~at in ignore orig; Some at;;

type format = { visual : Xproto.visualid; depth : int; } [@@deriving sexp];;
let decode_format buf ~at : (format * int) option = let orig = at in let* visual, at = Xproto.decode_visualid buf ~at in
let* depth, at = decode_uint8 buf ~at in
let at = at + 3 in
ignore orig;
Some ({ visual; depth }, at);;
let encode_format buf (v : format) ~at : int option = let orig = at in let* at = Xproto.encode_visualid buf v.visual ~at in let* at = encode_uint8 buf v.depth ~at in let at = at + 3 in ignore orig; Some at;;

type adaptor_info = { base_id : port; num_ports : int; type_ : type_mask; name : string; formats : format list; } [@@deriving sexp];;
let decode_adaptor_info buf ~at : (adaptor_info * int) option = let orig = at in let* base_id, at = decode_port buf ~at in
let* name_size, at = decode_uint16 buf ~at in let name_size = name_size in
let* num_ports, at = decode_uint16 buf ~at in
let* num_formats, at = decode_uint16 buf ~at in let num_formats = num_formats in
let* type_, at = decode_mask decode_uint8 Int64.of_int type_mask_of_int64 buf ~at in
let at = at + 1 in
let* name, at = decode_string name_size buf ~at in
let at = at + ((at - orig) mod 4) in
let* formats, at = decode_list (decode_format) num_formats buf ~at in
ignore orig;
Some ({ base_id; num_ports; type_; name; formats }, at);;
let encode_adaptor_info buf (v : adaptor_info) ~at : int option = let orig = at in let* at = encode_port buf v.base_id ~at in let* at = encode_uint16 buf (identity (String.length v.name)) ~at in let* at = encode_uint16 buf v.num_ports ~at in let* at = encode_uint16 buf (identity ((* invalid_argument *) List.length v.formats)) ~at in let* at = encode_mask encode_uint8 identity type_int_of_mask buf v.type_ ~at in let at = at + 1 in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in let* at = encode_list encode_format buf v.formats ~at in ignore orig; Some at;;

type encoding_info = { encoding : encoding; width : int; height : int; rate : rational; name : string; } [@@deriving sexp];;
let decode_encoding_info buf ~at : (encoding_info * int) option = let orig = at in let* encoding, at = decode_encoding buf ~at in
let* name_size, at = decode_uint16 buf ~at in let name_size = name_size in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let at = at + 2 in
let* rate, at = decode_rational buf ~at in
let* name, at = decode_string name_size buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ encoding; width; height; rate; name }, at);;
let encode_encoding_info buf (v : encoding_info) ~at : int option = let orig = at in let* at = encode_encoding buf v.encoding ~at in let* at = encode_uint16 buf (identity (String.length v.name)) ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let at = at + 2 in let* at = encode_rational buf v.rate ~at in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type image = { id : int; width : int; height : int; pitches : int list; offsets : int list; data : int list; } [@@deriving sexp];;
let decode_image buf ~at : (image * int) option = let orig = at in let* id, at = decode_int32 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let* data_size, at = decode_int32 buf ~at in let data_size = data_size in
let* num_planes, at = decode_int32 buf ~at in let num_planes = num_planes in
let* pitches, at = decode_list (decode_int32) num_planes buf ~at in
let* offsets, at = decode_list (decode_int32) num_planes buf ~at in
let* data, at = decode_list (decode_uint8) data_size buf ~at in
ignore orig;
Some ({ id; width; height; pitches; offsets; data }, at);;
let encode_image buf (v : image) ~at : int option = let orig = at in let* at = encode_int32 buf v.id ~at in let* at = encode_uint16 buf v.width ~at in let* at = encode_uint16 buf v.height ~at in let* at = encode_int32 buf (identity ((* Parsetree.Card8 *) List.length v.data)) ~at in let* at = encode_int32 buf (identity ((* Parsetree.Card32 *) List.length v.pitches)) ~at in let* at = encode_list encode_int32 buf v.pitches ~at in let* at = encode_list encode_int32 buf v.offsets ~at in let* at = encode_list encode_uint8 buf v.data ~at in ignore orig; Some at;;

type attribute_info = { flags : attribute_flag_mask; min : int; max : int; name : string; } [@@deriving sexp];;
let decode_attribute_info buf ~at : (attribute_info * int) option = let orig = at in let* flags, at = decode_mask decode_int32 Int64.of_int attribute_flag_mask_of_int64 buf ~at in
let* min, at = decode_int32 buf ~at in
let* max, at = decode_int32 buf ~at in
let* size, at = decode_int32 buf ~at in let size = size in
let* name, at = decode_string size buf ~at in
let at = at + ((at - orig) mod 4) in
ignore orig;
Some ({ flags; min; max; name }, at);;
let encode_attribute_info buf (v : attribute_info) ~at : int option = let orig = at in let* at = encode_mask encode_int32 identity attribute_flag_int_of_mask buf v.flags ~at in let* at = encode_int32 buf v.min ~at in let* at = encode_int32 buf v.max ~at in let* at = encode_int32 buf (identity (String.length v.name)) ~at in let* at = encode_string buf v.name ~at in let at = at + ((at - orig) mod 4) in ignore orig; Some at;;

type image_format_info = { id : int; type_ : image_format_info_type_enum; byte_order : Xproto.image_order_enum; guid : int list; bpp : int; num_planes : int; depth : int; red_mask : int; green_mask : int; blue_mask : int; format : image_format_info_format_enum; y_sample_bits : int; u_sample_bits : int; v_sample_bits : int; vhorz_y_period : int; vhorz_u_period : int; vhorz_v_period : int; vvert_y_period : int; vvert_u_period : int; vvert_v_period : int; vcomp_order : int list; vscanline_order : scanline_order_enum; } [@@deriving sexp];;
let decode_image_format_info buf ~at : (image_format_info * int) option = let orig = at in let* id, at = decode_int32 buf ~at in
let* type_, at = decode_enum decode_uint8 identity image_format_info_type_enum_of_int buf ~at in
let* byte_order, at = decode_enum decode_uint8 identity Xproto.image_order_enum_of_int buf ~at in
let at = at + 2 in
let* guid, at = let length = 16 in decode_list (decode_uint8) length buf ~at in
let* bpp, at = decode_uint8 buf ~at in
let* num_planes, at = decode_uint8 buf ~at in
let at = at + 2 in
let* depth, at = decode_uint8 buf ~at in
let at = at + 3 in
let* red_mask, at = decode_int32 buf ~at in
let* green_mask, at = decode_int32 buf ~at in
let* blue_mask, at = decode_int32 buf ~at in
let* format, at = decode_enum decode_uint8 identity image_format_info_format_enum_of_int buf ~at in
let at = at + 3 in
let* y_sample_bits, at = decode_int32 buf ~at in
let* u_sample_bits, at = decode_int32 buf ~at in
let* v_sample_bits, at = decode_int32 buf ~at in
let* vhorz_y_period, at = decode_int32 buf ~at in
let* vhorz_u_period, at = decode_int32 buf ~at in
let* vhorz_v_period, at = decode_int32 buf ~at in
let* vvert_y_period, at = decode_int32 buf ~at in
let* vvert_u_period, at = decode_int32 buf ~at in
let* vvert_v_period, at = decode_int32 buf ~at in
let* vcomp_order, at = let length = 32 in decode_list (decode_uint8) length buf ~at in
let* vscanline_order, at = decode_enum decode_uint8 identity scanline_order_enum_of_int buf ~at in
let at = at + 11 in
ignore orig;
Some ({ id; type_; byte_order; guid; bpp; num_planes; depth; red_mask; green_mask; blue_mask; format; y_sample_bits; u_sample_bits; v_sample_bits; vhorz_y_period; vhorz_u_period; vhorz_v_period; vvert_y_period; vvert_u_period; vvert_v_period; vcomp_order; vscanline_order }, at);;
let encode_image_format_info buf (v : image_format_info) ~at : int option = let orig = at in let* at = encode_int32 buf v.id ~at in let* at = encode_enum encode_uint8 identity image_format_info_type_int_of_enum buf v.type_ ~at in let* at = encode_enum encode_uint8 identity Xproto.image_order_int_of_enum buf v.byte_order ~at in let at = at + 2 in let* at = encode_list encode_uint8 buf v.guid ~at in let* at = encode_uint8 buf v.bpp ~at in let* at = encode_uint8 buf v.num_planes ~at in let at = at + 2 in let* at = encode_uint8 buf v.depth ~at in let at = at + 3 in let* at = encode_int32 buf v.red_mask ~at in let* at = encode_int32 buf v.green_mask ~at in let* at = encode_int32 buf v.blue_mask ~at in let* at = encode_enum encode_uint8 identity image_format_info_format_int_of_enum buf v.format ~at in let at = at + 3 in let* at = encode_int32 buf v.y_sample_bits ~at in let* at = encode_int32 buf v.u_sample_bits ~at in let* at = encode_int32 buf v.v_sample_bits ~at in let* at = encode_int32 buf v.vhorz_y_period ~at in let* at = encode_int32 buf v.vhorz_u_period ~at in let* at = encode_int32 buf v.vhorz_v_period ~at in let* at = encode_int32 buf v.vvert_y_period ~at in let* at = encode_int32 buf v.vvert_u_period ~at in let* at = encode_int32 buf v.vvert_v_period ~at in let* at = encode_list encode_uint8 buf v.vcomp_order ~at in let* at = encode_enum encode_uint8 identity scanline_order_int_of_enum buf v.vscanline_order ~at in let at = at + 11 in ignore orig; Some at;;

type bad_port_error = unit [@@deriving sexp];;
type bad_encoding_error = unit [@@deriving sexp];;
type bad_control_error = unit [@@deriving sexp];;
type video_notify_event = { reason : video_notify_reason_enum; time : Xproto.timestamp; drawable : Xproto.drawable; port : port; } [@@deriving sexp];;
type port_notify_event = { time : Xproto.timestamp; port : port; attribute : Xproto.atom; value : int; } [@@deriving sexp];;
type query_extension_reply = { major : int; minor : int; } [@@deriving sexp];;
let encode_query_extension  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_extension_reply length buf ~at : (query_extension_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major, at = decode_uint16 buf ~at in
let* minor, at = decode_uint16 buf ~at in
ignore orig;
Some ({ major; minor }, at);;
type query_adaptors_reply = { info : adaptor_info list; } [@@deriving sexp];;
let encode_query_adaptors ~(window : Xproto.window)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xproto.encode_window buf window ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_adaptors_reply length buf ~at : (query_adaptors_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_adaptors, at = decode_uint16 buf ~at in let num_adaptors = num_adaptors in
let at = at + 22 in
let* info, at = decode_list (decode_adaptor_info) num_adaptors buf ~at in
ignore orig;
Some ({ info }, at);;
type query_encodings_reply = { info : encoding_info list; } [@@deriving sexp];;
let encode_query_encodings ~(port : port)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_encodings_reply length buf ~at : (query_encodings_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_encodings, at = decode_uint16 buf ~at in let num_encodings = num_encodings in
let at = at + 22 in
let* info, at = decode_list (decode_encoding_info) num_encodings buf ~at in
ignore orig;
Some ({ info }, at);;
type grab_port_reply = { result : grab_port_status_enum; } [@@deriving sexp];;
let encode_grab_port ~(port : port) ~(time : Xproto.time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_grab_port_reply length buf ~at : (grab_port_reply * int) option = let orig = at in let at = at + 1 in
let* result, at = decode_enum decode_char Char.code grab_port_status_enum_of_int buf ~at in
let at = at + 6 in
ignore orig;
Some ({ result }, at);;
let encode_ungrab_port ~(port : port) ~(time : Xproto.time_enum alt_enum)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf time ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_put_video ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = encode_int16 buf vid_x ~at in
let* at = encode_int16 buf vid_y ~at in
let* at = encode_uint16 buf vid_w ~at in
let* at = encode_uint16 buf vid_h ~at in
let* at = encode_int16 buf drw_x ~at in
let* at = encode_int16 buf drw_y ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_put_still ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = encode_int16 buf vid_x ~at in
let* at = encode_int16 buf vid_y ~at in
let* at = encode_uint16 buf vid_w ~at in
let* at = encode_uint16 buf vid_h ~at in
let* at = encode_int16 buf drw_x ~at in
let* at = encode_int16 buf drw_y ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_get_video ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = encode_int16 buf vid_x ~at in
let* at = encode_int16 buf vid_y ~at in
let* at = encode_uint16 buf vid_w ~at in
let* at = encode_uint16 buf vid_h ~at in
let* at = encode_int16 buf drw_x ~at in
let* at = encode_int16 buf drw_y ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_get_still ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int) ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = encode_int16 buf vid_x ~at in
let* at = encode_int16 buf vid_y ~at in
let* at = encode_uint16 buf vid_w ~at in
let* at = encode_uint16 buf vid_h ~at in
let* at = encode_int16 buf drw_x ~at in
let* at = encode_int16 buf drw_y ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_stop_video ~(port : port) ~(drawable : Xproto.drawable)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 9 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_select_video_notify ~(drawable : Xproto.drawable) ~(onoff : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 10 ~at in
let* at = Xproto.encode_drawable buf drawable ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_bool buf onoff ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_select_port_notify ~(port : port) ~(onoff : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 11 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_bool buf onoff ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type query_best_size_reply = { actual_width : int; actual_height : int; } [@@deriving sexp];;
let encode_query_best_size ~(port : port) ~(vid_w : int) ~(vid_h : int) ~(drw_w : int) ~(drw_h : int) ~(motion : bool)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 12 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_uint16 buf vid_w ~at in
let* at = encode_uint16 buf vid_h ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
let* at = encode_bool buf motion ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_best_size_reply length buf ~at : (query_best_size_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* actual_width, at = decode_uint16 buf ~at in
let* actual_height, at = decode_uint16 buf ~at in
ignore orig;
Some ({ actual_width; actual_height }, at);;
let encode_set_port_attribute ~(port : port) ~(attribute : Xproto.atom) ~(value : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 13 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf attribute ~at in
let* at = encode_int32 buf value ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type get_port_attribute_reply = { value : int; } [@@deriving sexp];;
let encode_get_port_attribute ~(port : port) ~(attribute : Xproto.atom)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 14 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_atom buf attribute ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_get_port_attribute_reply length buf ~at : (get_port_attribute_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* value, at = decode_int32 buf ~at in
ignore orig;
Some ({ value }, at);;
type query_port_attributes_reply = { text_size : int; attributes : attribute_info list; } [@@deriving sexp];;
let encode_query_port_attributes ~(port : port)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 15 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_port_attributes_reply length buf ~at : (query_port_attributes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_attributes, at = decode_int32 buf ~at in let num_attributes = num_attributes in
let* text_size, at = decode_int32 buf ~at in
let at = at + 16 in
let* attributes, at = decode_list (decode_attribute_info) num_attributes buf ~at in
ignore orig;
Some ({ text_size; attributes }, at);;
type list_image_formats_reply = { format : image_format_info list; } [@@deriving sexp];;
let encode_list_image_formats ~(port : port)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 16 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_image_formats_reply length buf ~at : (list_image_formats_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_formats, at = decode_int32 buf ~at in let num_formats = num_formats in
let at = at + 20 in
let* format, at = decode_list (decode_image_format_info) num_formats buf ~at in
ignore orig;
Some ({ format }, at);;
type query_image_attributes_reply = { data_size : int; width : int; height : int; pitches : int list; offsets : int list; } [@@deriving sexp];;
let encode_query_image_attributes ~(port : port) ~(id : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 17 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_int32 buf id ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_image_attributes_reply length buf ~at : (query_image_attributes_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num_planes, at = decode_int32 buf ~at in let num_planes = num_planes in
let* data_size, at = decode_int32 buf ~at in
let* width, at = decode_uint16 buf ~at in
let* height, at = decode_uint16 buf ~at in
let at = at + 12 in
let* pitches, at = decode_list (decode_int32) num_planes buf ~at in
let* offsets, at = decode_list (decode_int32) num_planes buf ~at in
ignore orig;
Some ({ data_size; width; height; pitches; offsets }, at);;
let encode_put_image ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(id : int) ~(src_x : int) ~(src_y : int) ~(src_w : int) ~(src_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) ~(width : int) ~(height : int) ~(data : int list)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 18 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = encode_int32 buf id ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_uint16 buf src_w ~at in
let* at = encode_uint16 buf src_h ~at in
let* at = encode_int16 buf drw_x ~at in
let* at = encode_int16 buf drw_y ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_list encode_uint8 buf data ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let encode_shm_put_image ~(port : port) ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext) ~(shmseg : Shm.seg) ~(id : int) ~(offset : int) ~(src_x : int) ~(src_y : int) ~(src_w : int) ~(src_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) ~(width : int) ~(height : int) ~(send_event : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 19 ~at in
let* at = encode_port buf port ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xproto.encode_drawable buf drawable ~at in
let* at = Xproto.encode_gcontext buf gc ~at in
let* at = Shm.encode_seg buf shmseg ~at in
let* at = encode_int32 buf id ~at in
let* at = encode_int32 buf offset ~at in
let* at = encode_int16 buf src_x ~at in
let* at = encode_int16 buf src_y ~at in
let* at = encode_uint16 buf src_w ~at in
let* at = encode_uint16 buf src_h ~at in
let* at = encode_int16 buf drw_x ~at in
let* at = encode_int16 buf drw_y ~at in
let* at = encode_uint16 buf drw_w ~at in
let* at = encode_uint16 buf drw_h ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_uint8 buf send_event ~at in
let at = at + 3 in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
end
module[@warning "-27"] Xvmc = struct
type context = xid [@@deriving sexp];;
let decode_context = decode_xid;;
let encode_context = encode_xid;;

type surface = xid [@@deriving sexp];;
let decode_surface = decode_xid;;
let encode_surface = encode_xid;;

type subpicture = xid [@@deriving sexp];;
let decode_subpicture = decode_xid;;
let encode_subpicture = encode_xid;;

type surface_info = { id : surface; chroma_format : int; pad0 : int; max_width : int; max_height : int; subpicture_max_width : int; subpicture_max_height : int; mc_type : int; flags : int; } [@@deriving sexp];;
let decode_surface_info buf ~at : (surface_info * int) option = let orig = at in let* id, at = decode_surface buf ~at in
let* chroma_format, at = decode_uint16 buf ~at in
let* pad0, at = decode_uint16 buf ~at in
let* max_width, at = decode_uint16 buf ~at in
let* max_height, at = decode_uint16 buf ~at in
let* subpicture_max_width, at = decode_uint16 buf ~at in
let* subpicture_max_height, at = decode_uint16 buf ~at in
let* mc_type, at = decode_int32 buf ~at in
let* flags, at = decode_int32 buf ~at in
ignore orig;
Some ({ id; chroma_format; pad0; max_width; max_height; subpicture_max_width; subpicture_max_height; mc_type; flags }, at);;
let encode_surface_info buf (v : surface_info) ~at : int option = let orig = at in let* at = encode_surface buf v.id ~at in let* at = encode_uint16 buf v.chroma_format ~at in let* at = encode_uint16 buf v.pad0 ~at in let* at = encode_uint16 buf v.max_width ~at in let* at = encode_uint16 buf v.max_height ~at in let* at = encode_uint16 buf v.subpicture_max_width ~at in let* at = encode_uint16 buf v.subpicture_max_height ~at in let* at = encode_int32 buf v.mc_type ~at in let* at = encode_int32 buf v.flags ~at in ignore orig; Some at;;

type query_version_reply = { major : int; minor : int; } [@@deriving sexp];;
let encode_query_version  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 0 ~at in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_query_version_reply length buf ~at : (query_version_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* major, at = decode_int32 buf ~at in
let* minor, at = decode_int32 buf ~at in
ignore orig;
Some ({ major; minor }, at);;
type list_surface_types_reply = { surfaces : surface_info list; } [@@deriving sexp];;
let encode_list_surface_types ~(port_id : Xv.port)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 1 ~at in
let* at = Xv.encode_port buf port_id ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_surface_types_reply length buf ~at : (list_surface_types_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num, at = decode_int32 buf ~at in let num = num in
let at = at + 20 in
let* surfaces, at = decode_list (decode_surface_info) num buf ~at in
ignore orig;
Some ({ surfaces }, at);;
type create_context_reply = { width_actual : int; height_actual : int; flags_return : int; priv_data : int list; } [@@deriving sexp];;
let encode_create_context ~(context_id : context) ~(port_id : Xv.port) ~(surface_id : surface) ~(width : int) ~(height : int) ~(flags : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 2 ~at in
let* at = encode_context buf context_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = Xv.encode_port buf port_id ~at in
let* at = encode_surface buf surface_id ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
let* at = encode_int32 buf flags ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_context_reply length buf ~at : (create_context_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width_actual, at = decode_uint16 buf ~at in
let* height_actual, at = decode_uint16 buf ~at in
let* flags_return, at = decode_int32 buf ~at in
let at = at + 20 in
let* priv_data, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ width_actual; height_actual; flags_return; priv_data }, at);;
let encode_destroy_context ~(context_id : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 3 ~at in
let* at = encode_context buf context_id ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type create_surface_reply = { priv_data : int list; } [@@deriving sexp];;
let encode_create_surface ~(surface_id : surface) ~(context_id : context)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 4 ~at in
let* at = encode_surface buf surface_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_context buf context_id ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_surface_reply length buf ~at : (create_surface_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let at = at + 24 in
let* priv_data, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ priv_data }, at);;
let encode_destroy_surface ~(surface_id : surface)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 5 ~at in
let* at = encode_surface buf surface_id ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type create_subpicture_reply = { width_actual : int; height_actual : int; num_palette_entries : int; entry_bytes : int; component_order : int list; priv_data : int list; } [@@deriving sexp];;
let encode_create_subpicture ~(subpicture_id : subpicture) ~(context : context) ~(xvimage_id : int) ~(width : int) ~(height : int)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 6 ~at in
let* at = encode_subpicture buf subpicture_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_context buf context ~at in
let* at = encode_int32 buf xvimage_id ~at in
let* at = encode_uint16 buf width ~at in
let* at = encode_uint16 buf height ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_create_subpicture_reply length buf ~at : (create_subpicture_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* width_actual, at = decode_uint16 buf ~at in
let* height_actual, at = decode_uint16 buf ~at in
let* num_palette_entries, at = decode_uint16 buf ~at in
let* entry_bytes, at = decode_uint16 buf ~at in
let* component_order, at = let length = 4 in decode_list (decode_uint8) length buf ~at in
let at = at + 12 in
let* priv_data, at = let length = length in decode_list (decode_int32) length buf ~at in
ignore orig;
Some ({ width_actual; height_actual; num_palette_entries; entry_bytes; component_order; priv_data }, at);;
let encode_destroy_subpicture ~(subpicture_id : subpicture)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 7 ~at in
let* at = encode_subpicture buf subpicture_id ~at in
(* reserve request length *)
let at = at + 2 in

(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
type list_subpicture_types_reply = { types : Xv.image_format_info list; } [@@deriving sexp];;
let encode_list_subpicture_types ~(port_id : Xv.port) ~(surface_id : surface)  buf ~at : int option =
let orig = at in
(* opcode *)
let* at = encode_uint8 buf 8 ~at in
let* at = Xv.encode_port buf port_id ~at in
(* reserve request length *)
let at = at + 2 in
let* at = encode_surface buf surface_id ~at in
(* write request length *)
let* _ = encode_uint16 buf (at / 4) ~at:(orig + 2) in
Some at;;
let decode_list_subpicture_types_reply length buf ~at : (list_subpicture_types_reply * int) option = let orig = at in let at = at + 1 in
let at = at + 1 in
let at = at + 6 in
let* num, at = decode_int32 buf ~at in let num = num in
let at = at + 20 in
let* types, at = decode_list (Xv.decode_image_format_info) num buf ~at in
ignore orig;
Some ({ types }, at);;
end
