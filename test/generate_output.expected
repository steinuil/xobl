module Bigreq = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type enable_reply = int [@@deriving sexp]

  let encode_enable buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_enable_reply length buf ~at : (enable_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* maximum_request_length, at = decode_int32 buf ~at in
    ignore orig;
    Some (maximum_request_length, at)
end

module Xproto = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type char2b = { byte1 : int; byte2 : int } [@@deriving sexp]

  let decode_char2b buf ~at : (char2b * int) option =
    let orig = at in
    let* byte1, at = decode_uint8 buf ~at in
    let* byte2, at = decode_uint8 buf ~at in
    ignore orig;
    Some ({ byte1; byte2 }, at)

  let encode_char2b buf (v : char2b) =
    encode_uint8 buf v.byte1;
    encode_uint8 buf v.byte2;
    ()

  type window = xid [@@deriving sexp]

  let decode_window = decode_xid
  let encode_window = encode_xid

  type pixmap = xid [@@deriving sexp]

  let decode_pixmap = decode_xid
  let encode_pixmap = encode_xid

  type cursor = xid [@@deriving sexp]

  let decode_cursor = decode_xid
  let encode_cursor = encode_xid

  type font = xid [@@deriving sexp]

  let decode_font = decode_xid
  let encode_font = encode_xid

  type gcontext = xid [@@deriving sexp]

  let decode_gcontext = decode_xid
  let encode_gcontext = encode_xid

  type colormap = xid [@@deriving sexp]

  let decode_colormap = decode_xid
  let encode_colormap = encode_xid

  type atom = xid [@@deriving sexp]

  let decode_atom = decode_xid
  let encode_atom = encode_xid

  type drawable = xid [@@deriving sexp]

  let decode_drawable = decode_xid
  let encode_drawable = encode_xid

  type fontable = xid [@@deriving sexp]

  let decode_fontable = decode_xid
  let encode_fontable = encode_xid

  type bool32 = int [@@deriving sexp]

  let decode_bool32 = decode_int32
  let encode_bool32 = encode_int32

  type visualid = int [@@deriving sexp]

  let decode_visualid = decode_int32
  let encode_visualid = encode_int32

  type timestamp = int [@@deriving sexp]

  let decode_timestamp = decode_int32
  let encode_timestamp = encode_int32

  type keysym = int [@@deriving sexp]

  let decode_keysym = decode_int32
  let encode_keysym = encode_int32

  type keycode = int [@@deriving sexp]

  let decode_keycode = decode_uint8
  let encode_keycode = encode_uint8

  type keycode32 = int [@@deriving sexp]

  let decode_keycode32 = decode_int32
  let encode_keycode32 = encode_int32

  type button = int [@@deriving sexp]

  let decode_button = decode_uint8
  let encode_button = encode_uint8

  type point = { x : int; y : int } [@@deriving sexp]

  let decode_point buf ~at : (point * int) option =
    let orig = at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ x; y }, at)

  let encode_point buf (v : point) =
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    ()

  type rectangle = { x : int; y : int; width : int; height : int }
  [@@deriving sexp]

  let decode_rectangle buf ~at : (rectangle * int) option =
    let orig = at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ x; y; width; height }, at)

  let encode_rectangle buf (v : rectangle) =
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    ()

  type arc = {
    x : int;
    y : int;
    width : int;
    height : int;
    angle1 : int;
    angle2 : int;
  }
  [@@deriving sexp]

  let decode_arc buf ~at : (arc * int) option =
    let orig = at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* angle1, at = decode_int16 buf ~at in
    let* angle2, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ x; y; width; height; angle1; angle2 }, at)

  let encode_arc buf (v : arc) =
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_int16 buf v.angle1;
    encode_int16 buf v.angle2;
    ()

  type format = { depth : int; bits_per_pixel : int; scanline_pad : int }
  [@@deriving sexp]

  let decode_format buf ~at : (format * int) option =
    let orig = at in
    let* depth, at = decode_uint8 buf ~at in
    let* bits_per_pixel, at = decode_uint8 buf ~at in
    let* scanline_pad, at = decode_uint8 buf ~at in
    let at = at + 5 in
    ignore orig;
    Some ({ depth; bits_per_pixel; scanline_pad }, at)

  let encode_format buf (v : format) =
    encode_uint8 buf v.depth;
    encode_uint8 buf v.bits_per_pixel;
    encode_uint8 buf v.scanline_pad;
    encode_pad buf 5;
    ()

  type visual_class_enum =
    [ `Static_gray
    | `Gray_scale
    | `Static_color
    | `Pseudo_color
    | `True_color
    | `Direct_color ]
  [@@deriving sexp]

  let visual_class_enum_of_int : int -> [> visual_class_enum ] option = function
    | 0 -> Some `Static_gray
    | 1 -> Some `Gray_scale
    | 2 -> Some `Static_color
    | 3 -> Some `Pseudo_color
    | 4 -> Some `True_color
    | 5 -> Some `Direct_color
    | n ->
        Printf.printf "unknown visual_class_enum: %d\n" n;
        None

  let visual_class_int_of_enum : visual_class_enum -> int = function
    | `Static_gray -> 0
    | `Gray_scale -> 1
    | `Static_color -> 2
    | `Pseudo_color -> 3
    | `True_color -> 4
    | `Direct_color -> 5

  type visualtype = {
    visual_id : visualid;
    class_ : visual_class_enum;
    bits_per_rgb_value : int;
    colormap_entries : int;
    red_mask : int;
    green_mask : int;
    blue_mask : int;
  }
  [@@deriving sexp]

  let decode_visualtype buf ~at : (visualtype * int) option =
    let orig = at in
    let* visual_id, at = decode_visualid buf ~at in
    let* class_, at =
      decode_enum decode_uint8 identity visual_class_enum_of_int buf ~at
    in
    let* bits_per_rgb_value, at = decode_uint8 buf ~at in
    let* colormap_entries, at = decode_uint16 buf ~at in
    let* red_mask, at = decode_int32 buf ~at in
    let* green_mask, at = decode_int32 buf ~at in
    let* blue_mask, at = decode_int32 buf ~at in
    let at = at + 4 in
    ignore orig;
    Some
      ( {
          visual_id;
          class_;
          bits_per_rgb_value;
          colormap_entries;
          red_mask;
          green_mask;
          blue_mask;
        },
        at )

  let encode_visualtype buf (v : visualtype) =
    encode_visualid buf v.visual_id;
    encode_enum encode_uint8 identity visual_class_int_of_enum buf v.class_;
    encode_uint8 buf v.bits_per_rgb_value;
    encode_uint16 buf v.colormap_entries;
    encode_int32 buf v.red_mask;
    encode_int32 buf v.green_mask;
    encode_int32 buf v.blue_mask;
    encode_pad buf 4;
    ()

  type depth = { depth : int; visuals : visualtype list } [@@deriving sexp]

  let decode_depth buf ~at : (depth * int) option =
    let orig = at in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* visuals_len, at = decode_uint16 buf ~at in
    let visuals_len = visuals_len in
    let at = at + 4 in
    let* visuals, at = decode_list decode_visualtype visuals_len buf ~at in
    ignore orig;
    Some ({ depth; visuals }, at)

  let encode_depth buf (v : depth) =
    encode_uint8 buf v.depth;
    encode_pad buf 1;
    encode_uint16 buf (identity ((* invalid_argument *) List.length v.visuals));
    encode_pad buf 4;
    encode_list encode_visualtype buf v.visuals;
    ()

  type event_mask =
    [ `Key_press
    | `Key_release
    | `Button_press
    | `Button_release
    | `Enter_window
    | `Leave_window
    | `Pointer_motion
    | `Pointer_motion_hint
    | `Button1_motion
    | `Button2_motion
    | `Button3_motion
    | `Button4_motion
    | `Button5_motion
    | `Button_motion
    | `Keymap_state
    | `Exposure
    | `Visibility_change
    | `Structure_notify
    | `Resize_redirect
    | `Substructure_notify
    | `Substructure_redirect
    | `Focus_change
    | `Property_change
    | `Color_map_change
    | `Owner_grab_button ]
    list
    option
  [@@deriving sexp]

  let event_mask_mask_of_int64 mask : event_mask option =
    let of_mask = function
      | 0 -> Some `Key_press
      | 1 -> Some `Key_release
      | 2 -> Some `Button_press
      | 3 -> Some `Button_release
      | 4 -> Some `Enter_window
      | 5 -> Some `Leave_window
      | 6 -> Some `Pointer_motion
      | 7 -> Some `Pointer_motion_hint
      | 8 -> Some `Button1_motion
      | 9 -> Some `Button2_motion
      | 10 -> Some `Button3_motion
      | 11 -> Some `Button4_motion
      | 12 -> Some `Button5_motion
      | 13 -> Some `Button_motion
      | 14 -> Some `Keymap_state
      | 15 -> Some `Exposure
      | 16 -> Some `Visibility_change
      | 17 -> Some `Structure_notify
      | 18 -> Some `Resize_redirect
      | 19 -> Some `Substructure_notify
      | 20 -> Some `Substructure_redirect
      | 21 -> Some `Focus_change
      | 22 -> Some `Property_change
      | 23 -> Some `Color_map_change
      | 24 -> Some `Owner_grab_button
      | _ -> None
    in
    if mask = 0L then Some None
    else mask_of_int of_mask mask |> Option.map (fun m -> Some m)

  let event_mask_int_of_mask (mask : event_mask) : int =
    let to_mask = function
      | `Key_press -> 0
      | `Key_release -> 1
      | `Button_press -> 2
      | `Button_release -> 3
      | `Enter_window -> 4
      | `Leave_window -> 5
      | `Pointer_motion -> 6
      | `Pointer_motion_hint -> 7
      | `Button1_motion -> 8
      | `Button2_motion -> 9
      | `Button3_motion -> 10
      | `Button4_motion -> 11
      | `Button5_motion -> 12
      | `Button_motion -> 13
      | `Keymap_state -> 14
      | `Exposure -> 15
      | `Visibility_change -> 16
      | `Structure_notify -> 17
      | `Resize_redirect -> 18
      | `Substructure_notify -> 19
      | `Substructure_redirect -> 20
      | `Focus_change -> 21
      | `Property_change -> 22
      | `Color_map_change -> 23
      | `Owner_grab_button -> 24
    in
    match mask with None -> 0 | Some mask -> int_of_mask to_mask mask

  type backing_store_enum = [ `Not_useful | `When_mapped | `Always ]
  [@@deriving sexp]

  let backing_store_enum_of_int : int -> [> backing_store_enum ] option =
    function
    | 0 -> Some `Not_useful
    | 1 -> Some `When_mapped
    | 2 -> Some `Always
    | n ->
        Printf.printf "unknown backing_store_enum: %d\n" n;
        None

  let backing_store_int_of_enum : backing_store_enum -> int = function
    | `Not_useful -> 0
    | `When_mapped -> 1
    | `Always -> 2

  type screen = {
    root : window;
    default_colormap : colormap;
    white_pixel : int;
    black_pixel : int;
    current_input_masks : event_mask;
    width_in_pixels : int;
    height_in_pixels : int;
    width_in_millimeters : int;
    height_in_millimeters : int;
    min_installed_maps : int;
    max_installed_maps : int;
    root_visual : visualid;
    backing_stores : backing_store_enum;
    save_unders : bool;
    root_depth : int;
    allowed_depths : depth list;
  }
  [@@deriving sexp]

  let decode_screen buf ~at : (screen * int) option =
    let orig = at in
    let* root, at = decode_window buf ~at in
    let* default_colormap, at = decode_colormap buf ~at in
    let* white_pixel, at = decode_int32 buf ~at in
    let* black_pixel, at = decode_int32 buf ~at in
    let* current_input_masks, at =
      decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at
    in
    let* width_in_pixels, at = decode_uint16 buf ~at in
    let* height_in_pixels, at = decode_uint16 buf ~at in
    let* width_in_millimeters, at = decode_uint16 buf ~at in
    let* height_in_millimeters, at = decode_uint16 buf ~at in
    let* min_installed_maps, at = decode_uint16 buf ~at in
    let* max_installed_maps, at = decode_uint16 buf ~at in
    let* root_visual, at = decode_visualid buf ~at in
    let* backing_stores, at =
      decode_enum decode_char Char.code backing_store_enum_of_int buf ~at
    in
    let* save_unders, at = decode_bool buf ~at in
    let* root_depth, at = decode_uint8 buf ~at in
    let* allowed_depths_len, at = decode_uint8 buf ~at in
    let allowed_depths_len = allowed_depths_len in
    let* allowed_depths, at =
      decode_list decode_depth allowed_depths_len buf ~at
    in
    ignore orig;
    Some
      ( {
          root;
          default_colormap;
          white_pixel;
          black_pixel;
          current_input_masks;
          width_in_pixels;
          height_in_pixels;
          width_in_millimeters;
          height_in_millimeters;
          min_installed_maps;
          max_installed_maps;
          root_visual;
          backing_stores;
          save_unders;
          root_depth;
          allowed_depths;
        },
        at )

  let encode_screen buf (v : screen) =
    encode_window buf v.root;
    encode_colormap buf v.default_colormap;
    encode_int32 buf v.white_pixel;
    encode_int32 buf v.black_pixel;
    encode_mask encode_int32 identity event_mask_int_of_mask buf
      v.current_input_masks;
    encode_uint16 buf v.width_in_pixels;
    encode_uint16 buf v.height_in_pixels;
    encode_uint16 buf v.width_in_millimeters;
    encode_uint16 buf v.height_in_millimeters;
    encode_uint16 buf v.min_installed_maps;
    encode_uint16 buf v.max_installed_maps;
    encode_visualid buf v.root_visual;
    encode_enum encode_char Char.chr backing_store_int_of_enum buf
      v.backing_stores;
    encode_bool buf v.save_unders;
    encode_uint8 buf v.root_depth;
    encode_uint8 buf
      (identity ((* invalid_argument *) List.length v.allowed_depths));
    encode_list encode_depth buf v.allowed_depths;
    ()

  type setup_request = {
    byte_order : int;
    protocol_major_version : int;
    protocol_minor_version : int;
    authorization_protocol_name : string;
    authorization_protocol_data : string;
  }
  [@@deriving sexp]

  let decode_setup_request buf ~at : (setup_request * int) option =
    let orig = at in
    let* byte_order, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* protocol_major_version, at = decode_uint16 buf ~at in
    let* protocol_minor_version, at = decode_uint16 buf ~at in
    let* authorization_protocol_name_len, at = decode_uint16 buf ~at in
    let authorization_protocol_name_len = authorization_protocol_name_len in
    let* authorization_protocol_data_len, at = decode_uint16 buf ~at in
    let authorization_protocol_data_len = authorization_protocol_data_len in
    let at = at + 2 in
    let* authorization_protocol_name, at =
      decode_string authorization_protocol_name_len buf ~at
    in
    let at = at + ((at - orig) mod 4) in
    let* authorization_protocol_data, at =
      decode_string authorization_protocol_data_len buf ~at
    in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some
      ( {
          byte_order;
          protocol_major_version;
          protocol_minor_version;
          authorization_protocol_name;
          authorization_protocol_data;
        },
        at )

  let encode_setup_request buf (v : setup_request) =
    encode_uint8 buf v.byte_order;
    encode_pad buf 1;
    encode_uint16 buf v.protocol_major_version;
    encode_uint16 buf v.protocol_minor_version;
    encode_uint16 buf (identity (String.length v.authorization_protocol_name));
    encode_uint16 buf (identity (String.length v.authorization_protocol_data));
    encode_pad buf 2;
    encode_string buf v.authorization_protocol_name;
    encode_align buf 4;
    encode_string buf v.authorization_protocol_data;
    encode_align buf 4;
    ()

  type setup_failed = {
    status : int;
    protocol_major_version : int;
    protocol_minor_version : int;
    length : int;
    reason : string;
  }
  [@@deriving sexp]

  let decode_setup_failed buf ~at : (setup_failed * int) option =
    let orig = at in
    let* status, at = decode_uint8 buf ~at in
    let* reason_len, at = decode_uint8 buf ~at in
    let reason_len = reason_len in
    let* protocol_major_version, at = decode_uint16 buf ~at in
    let* protocol_minor_version, at = decode_uint16 buf ~at in
    let* length, at = decode_uint16 buf ~at in
    let* reason, at = decode_string reason_len buf ~at in
    ignore orig;
    Some
      ( {
          status;
          protocol_major_version;
          protocol_minor_version;
          length;
          reason;
        },
        at )

  let encode_setup_failed buf (v : setup_failed) =
    encode_uint8 buf v.status;
    encode_uint8 buf (identity (String.length v.reason));
    encode_uint16 buf v.protocol_major_version;
    encode_uint16 buf v.protocol_minor_version;
    encode_uint16 buf v.length;
    encode_string buf v.reason;
    ()

  type setup_authenticate = { status : int; reason : string } [@@deriving sexp]

  let decode_setup_authenticate buf ~at : (setup_authenticate * int) option =
    let orig = at in
    let* status, at = decode_uint8 buf ~at in
    let at = at + 5 in
    let* length, at = decode_uint16 buf ~at in
    let length = length / 4 in
    let* reason, at = decode_string length buf ~at in
    ignore orig;
    Some ({ status; reason }, at)

  let encode_setup_authenticate buf (v : setup_authenticate) =
    encode_uint8 buf v.status;
    encode_pad buf 5;
    encode_uint16 buf (identity (String.length v.reason));
    encode_string buf v.reason;
    ()

  type image_order_enum = [ `Lsb_first | `Msb_first ] [@@deriving sexp]

  let image_order_enum_of_int : int -> [> image_order_enum ] option = function
    | 0 -> Some `Lsb_first
    | 1 -> Some `Msb_first
    | n ->
        Printf.printf "unknown image_order_enum: %d\n" n;
        None

  let image_order_int_of_enum : image_order_enum -> int = function
    | `Lsb_first -> 0
    | `Msb_first -> 1

  type setup = {
    status : int;
    protocol_major_version : int;
    protocol_minor_version : int;
    length : int;
    release_number : int;
    resource_id_base : int;
    resource_id_mask : int;
    motion_buffer_size : int;
    maximum_request_length : int;
    image_byte_order : image_order_enum;
    bitmap_format_bit_order : image_order_enum;
    bitmap_format_scanline_unit : int;
    bitmap_format_scanline_pad : int;
    min_keycode : keycode;
    max_keycode : keycode;
    vendor : string;
    pixmap_formats : format list;
    roots : screen list;
  }
  [@@deriving sexp]

  let decode_setup buf ~at : (setup * int) option =
    let orig = at in
    let* status, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* protocol_major_version, at = decode_uint16 buf ~at in
    let* protocol_minor_version, at = decode_uint16 buf ~at in
    let* length, at = decode_uint16 buf ~at in
    let* release_number, at = decode_int32 buf ~at in
    let* resource_id_base, at = decode_int32 buf ~at in
    let* resource_id_mask, at = decode_int32 buf ~at in
    let* motion_buffer_size, at = decode_int32 buf ~at in
    let* vendor_len, at = decode_uint16 buf ~at in
    let vendor_len = vendor_len in
    let* maximum_request_length, at = decode_uint16 buf ~at in
    let* roots_len, at = decode_uint8 buf ~at in
    let roots_len = roots_len in
    let* pixmap_formats_len, at = decode_uint8 buf ~at in
    let pixmap_formats_len = pixmap_formats_len in
    let* image_byte_order, at =
      decode_enum decode_uint8 identity image_order_enum_of_int buf ~at
    in
    let* bitmap_format_bit_order, at =
      decode_enum decode_uint8 identity image_order_enum_of_int buf ~at
    in
    let* bitmap_format_scanline_unit, at = decode_uint8 buf ~at in
    let* bitmap_format_scanline_pad, at = decode_uint8 buf ~at in
    let* min_keycode, at = decode_keycode buf ~at in
    let* max_keycode, at = decode_keycode buf ~at in
    let at = at + 4 in
    let* vendor, at = decode_string vendor_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* pixmap_formats, at =
      decode_list decode_format pixmap_formats_len buf ~at
    in
    let* roots, at = decode_list decode_screen roots_len buf ~at in
    ignore orig;
    Some
      ( {
          status;
          protocol_major_version;
          protocol_minor_version;
          length;
          release_number;
          resource_id_base;
          resource_id_mask;
          motion_buffer_size;
          maximum_request_length;
          image_byte_order;
          bitmap_format_bit_order;
          bitmap_format_scanline_unit;
          bitmap_format_scanline_pad;
          min_keycode;
          max_keycode;
          vendor;
          pixmap_formats;
          roots;
        },
        at )

  let encode_setup buf (v : setup) =
    encode_uint8 buf v.status;
    encode_pad buf 1;
    encode_uint16 buf v.protocol_major_version;
    encode_uint16 buf v.protocol_minor_version;
    encode_uint16 buf v.length;
    encode_int32 buf v.release_number;
    encode_int32 buf v.resource_id_base;
    encode_int32 buf v.resource_id_mask;
    encode_int32 buf v.motion_buffer_size;
    encode_uint16 buf (identity (String.length v.vendor));
    encode_uint16 buf v.maximum_request_length;
    encode_uint8 buf (identity ((* invalid_argument *) List.length v.roots));
    encode_uint8 buf
      (identity ((* invalid_argument *) List.length v.pixmap_formats));
    encode_enum encode_uint8 identity image_order_int_of_enum buf
      v.image_byte_order;
    encode_enum encode_uint8 identity image_order_int_of_enum buf
      v.bitmap_format_bit_order;
    encode_uint8 buf v.bitmap_format_scanline_unit;
    encode_uint8 buf v.bitmap_format_scanline_pad;
    encode_keycode buf v.min_keycode;
    encode_keycode buf v.max_keycode;
    encode_pad buf 4;
    encode_string buf v.vendor;
    encode_align buf 4;
    encode_list encode_format buf v.pixmap_formats;
    encode_list encode_screen buf v.roots;
    ()

  type mod_mask =
    [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list
  [@@deriving sexp]

  let mod_mask_mask_of_int64 mask : mod_mask option =
    let of_int = function
      | 0 -> Some `Shift
      | 1 -> Some `Lock
      | 2 -> Some `Control
      | 3 -> Some `D1
      | 4 -> Some `D2
      | 5 -> Some `D3
      | 6 -> Some `D4
      | 7 -> Some `D5
      | 15 -> Some `Any
      | _ -> None
    in
    mask_of_int of_int mask

  let mod_mask_int_of_mask : mod_mask -> int =
    let to_bit = function
      | `Shift -> 0
      | `Lock -> 1
      | `Control -> 2
      | `D1 -> 3
      | `D2 -> 4
      | `D3 -> 5
      | `D4 -> 6
      | `D5 -> 7
      | `Any -> 15
    in
    int_of_mask to_bit

  type key_but_mask =
    [ `Shift
    | `Lock
    | `Control
    | `Mod1
    | `Mod2
    | `Mod3
    | `Mod4
    | `Mod5
    | `Button1
    | `Button2
    | `Button3
    | `Button4
    | `Button5 ]
    list
  [@@deriving sexp]

  let key_but_mask_mask_of_int64 mask : key_but_mask option =
    let of_int = function
      | 0 -> Some `Shift
      | 1 -> Some `Lock
      | 2 -> Some `Control
      | 3 -> Some `Mod1
      | 4 -> Some `Mod2
      | 5 -> Some `Mod3
      | 6 -> Some `Mod4
      | 7 -> Some `Mod5
      | 8 -> Some `Button1
      | 9 -> Some `Button2
      | 10 -> Some `Button3
      | 11 -> Some `Button4
      | 12 -> Some `Button5
      | _ -> None
    in
    mask_of_int of_int mask

  let key_but_mask_int_of_mask : key_but_mask -> int =
    let to_bit = function
      | `Shift -> 0
      | `Lock -> 1
      | `Control -> 2
      | `Mod1 -> 3
      | `Mod2 -> 4
      | `Mod3 -> 5
      | `Mod4 -> 6
      | `Mod5 -> 7
      | `Button1 -> 8
      | `Button2 -> 9
      | `Button3 -> 10
      | `Button4 -> 11
      | `Button5 -> 12
    in
    int_of_mask to_bit

  type window_enum = [ `None ] [@@deriving sexp]

  let window_enum_of_int : int -> [> window_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown window_enum: %d\n" n;
        None

  let window_int_of_enum : window_enum -> int = function `None -> 0

  type key_press_event = {
    detail : keycode;
    time : timestamp;
    root : window;
    event : window;
    child : window_enum alt_enum;
    root_x : int;
    root_y : int;
    event_x : int;
    event_y : int;
    state : key_but_mask;
    same_screen : bool;
  }
  [@@deriving sexp]

  type key_release_event = key_press_event [@@deriving sexp]

  type button_mask = [ `D1 | `D2 | `D3 | `D4 | `D5 | `Any ] list
  [@@deriving sexp]

  let button_mask_mask_of_int64 mask : button_mask option =
    let of_int = function
      | 8 -> Some `D1
      | 9 -> Some `D2
      | 10 -> Some `D3
      | 11 -> Some `D4
      | 12 -> Some `D5
      | 15 -> Some `Any
      | _ -> None
    in
    mask_of_int of_int mask

  let button_mask_int_of_mask : button_mask -> int =
    let to_bit = function
      | `D1 -> 8
      | `D2 -> 9
      | `D3 -> 10
      | `D4 -> 11
      | `D5 -> 12
      | `Any -> 15
    in
    int_of_mask to_bit

  type button_press_event = {
    detail : button;
    time : timestamp;
    root : window;
    event : window;
    child : window_enum alt_enum;
    root_x : int;
    root_y : int;
    event_x : int;
    event_y : int;
    state : key_but_mask;
    same_screen : bool;
  }
  [@@deriving sexp]

  type button_release_event = button_press_event [@@deriving sexp]
  type motion_enum = [ `Normal | `Hint ] [@@deriving sexp]

  let motion_enum_of_int : int -> [> motion_enum ] option = function
    | 0 -> Some `Normal
    | 1 -> Some `Hint
    | n ->
        Printf.printf "unknown motion_enum: %d\n" n;
        None

  let motion_int_of_enum : motion_enum -> int = function
    | `Normal -> 0
    | `Hint -> 1

  type motion_notify_event = {
    detail : motion_enum;
    time : timestamp;
    root : window;
    event : window;
    child : window_enum alt_enum;
    root_x : int;
    root_y : int;
    event_x : int;
    event_y : int;
    state : key_but_mask;
    same_screen : bool;
  }
  [@@deriving sexp]

  let decode_motion_notify_event buf ~at : (motion_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at =
      decode_enum decode_char Char.code motion_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = decode_timestamp buf ~at in
    let* root, at = decode_window buf ~at in
    let* event, at = decode_window buf ~at in
    let* child, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* root_x, at = decode_int16 buf ~at in
    let* root_y, at = decode_int16 buf ~at in
    let* event_x, at = decode_int16 buf ~at in
    let* event_y, at = decode_int16 buf ~at in
    let* state, at =
      decode_mask decode_uint16 Int64.of_int key_but_mask_mask_of_int64 buf ~at
    in
    let* same_screen, at = decode_bool buf ~at in
    let at = at + 1 in
    ignore orig;
    Some
      ( {
          detail;
          time;
          root;
          event;
          child;
          root_x;
          root_y;
          event_x;
          event_y;
          state;
          same_screen;
        },
        at )

  type notify_detail_enum =
    [ `Ancestor
    | `Virtual
    | `Inferior
    | `Nonlinear
    | `Nonlinear_virtual
    | `Pointer
    | `Pointer_root
    | `None ]
  [@@deriving sexp]

  let notify_detail_enum_of_int : int -> [> notify_detail_enum ] option =
    function
    | 0 -> Some `Ancestor
    | 1 -> Some `Virtual
    | 2 -> Some `Inferior
    | 3 -> Some `Nonlinear
    | 4 -> Some `Nonlinear_virtual
    | 5 -> Some `Pointer
    | 6 -> Some `Pointer_root
    | 7 -> Some `None
    | n ->
        Printf.printf "unknown notify_detail_enum: %d\n" n;
        None

  let notify_detail_int_of_enum : notify_detail_enum -> int = function
    | `Ancestor -> 0
    | `Virtual -> 1
    | `Inferior -> 2
    | `Nonlinear -> 3
    | `Nonlinear_virtual -> 4
    | `Pointer -> 5
    | `Pointer_root -> 6
    | `None -> 7

  type notify_mode_enum = [ `Normal | `Grab | `Ungrab | `While_grabbed ]
  [@@deriving sexp]

  let notify_mode_enum_of_int : int -> [> notify_mode_enum ] option = function
    | 0 -> Some `Normal
    | 1 -> Some `Grab
    | 2 -> Some `Ungrab
    | 3 -> Some `While_grabbed
    | n ->
        Printf.printf "unknown notify_mode_enum: %d\n" n;
        None

  let notify_mode_int_of_enum : notify_mode_enum -> int = function
    | `Normal -> 0
    | `Grab -> 1
    | `Ungrab -> 2
    | `While_grabbed -> 3

  type enter_notify_event = {
    detail : notify_detail_enum;
    time : timestamp;
    root : window;
    event : window;
    child : window_enum alt_enum;
    root_x : int;
    root_y : int;
    event_x : int;
    event_y : int;
    state : key_but_mask;
    mode : notify_mode_enum;
    same_screen_focus : char;
  }
  [@@deriving sexp]

  let decode_enter_notify_event buf ~at : (enter_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at =
      decode_enum decode_char Char.code notify_detail_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = decode_timestamp buf ~at in
    let* root, at = decode_window buf ~at in
    let* event, at = decode_window buf ~at in
    let* child, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* root_x, at = decode_int16 buf ~at in
    let* root_y, at = decode_int16 buf ~at in
    let* event_x, at = decode_int16 buf ~at in
    let* event_y, at = decode_int16 buf ~at in
    let* state, at =
      decode_mask decode_uint16 Int64.of_int key_but_mask_mask_of_int64 buf ~at
    in
    let* mode, at =
      decode_enum decode_char Char.code notify_mode_enum_of_int buf ~at
    in
    let* same_screen_focus, at = decode_char buf ~at in
    ignore orig;
    Some
      ( {
          detail;
          time;
          root;
          event;
          child;
          root_x;
          root_y;
          event_x;
          event_y;
          state;
          mode;
          same_screen_focus;
        },
        at )

  type leave_notify_event = enter_notify_event [@@deriving sexp]

  type focus_in_event = {
    detail : notify_detail_enum;
    event : window;
    mode : notify_mode_enum;
  }
  [@@deriving sexp]

  let decode_focus_in_event buf ~at : (focus_in_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at =
      decode_enum decode_char Char.code notify_detail_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* mode, at =
      decode_enum decode_char Char.code notify_mode_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some ({ detail; event; mode }, at)

  type focus_out_event = focus_in_event [@@deriving sexp]
  type keymap_notify_event = int list [@@deriving sexp]

  let decode_keymap_notify_event buf ~at : (keymap_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* keys, at =
      let length = 31 in
      decode_list decode_uint8 length buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    ignore orig;
    Some (keys, at)

  type expose_event = {
    window : window;
    x : int;
    y : int;
    width : int;
    height : int;
    count : int;
  }
  [@@deriving sexp]

  let decode_expose_event buf ~at : (expose_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = decode_window buf ~at in
    let* x, at = decode_uint16 buf ~at in
    let* y, at = decode_uint16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* count, at = decode_uint16 buf ~at in
    let at = at + 2 in
    ignore orig;
    Some ({ window; x; y; width; height; count }, at)

  type graphics_exposure_event = {
    drawable : drawable;
    x : int;
    y : int;
    width : int;
    height : int;
    minor_opcode : int;
    count : int;
    major_opcode : int;
  }
  [@@deriving sexp]

  let decode_graphics_exposure_event buf ~at :
      (graphics_exposure_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* drawable, at = decode_drawable buf ~at in
    let* x, at = decode_uint16 buf ~at in
    let* y, at = decode_uint16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* minor_opcode, at = decode_uint16 buf ~at in
    let* count, at = decode_uint16 buf ~at in
    let* major_opcode, at = decode_uint8 buf ~at in
    let at = at + 3 in
    ignore orig;
    Some
      ({ drawable; x; y; width; height; minor_opcode; count; major_opcode }, at)

  type no_exposure_event = {
    drawable : drawable;
    minor_opcode : int;
    major_opcode : int;
  }
  [@@deriving sexp]

  let decode_no_exposure_event buf ~at : (no_exposure_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* drawable, at = decode_drawable buf ~at in
    let* minor_opcode, at = decode_uint16 buf ~at in
    let* major_opcode, at = decode_uint8 buf ~at in
    let at = at + 1 in
    ignore orig;
    Some ({ drawable; minor_opcode; major_opcode }, at)

  type visibility_enum = [ `Unobscured | `Partially_obscured | `Fully_obscured ]
  [@@deriving sexp]

  let visibility_enum_of_int : int -> [> visibility_enum ] option = function
    | 0 -> Some `Unobscured
    | 1 -> Some `Partially_obscured
    | 2 -> Some `Fully_obscured
    | n ->
        Printf.printf "unknown visibility_enum: %d\n" n;
        None

  let visibility_int_of_enum : visibility_enum -> int = function
    | `Unobscured -> 0
    | `Partially_obscured -> 1
    | `Fully_obscured -> 2

  type visibility_notify_event = { window : window; state : visibility_enum }
  [@@deriving sexp]

  let decode_visibility_notify_event buf ~at :
      (visibility_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = decode_window buf ~at in
    let* state, at =
      decode_enum decode_char Char.code visibility_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some ({ window; state }, at)

  type create_notify_event = {
    parent : window;
    window : window;
    x : int;
    y : int;
    width : int;
    height : int;
    border_width : int;
    override_redirect : bool;
  }
  [@@deriving sexp]

  let decode_create_notify_event buf ~at : (create_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* parent, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* border_width, at = decode_uint16 buf ~at in
    let* override_redirect, at = decode_bool buf ~at in
    let at = at + 1 in
    ignore orig;
    Some
      ( { parent; window; x; y; width; height; border_width; override_redirect },
        at )

  type destroy_notify_event = { event : window; window : window }
  [@@deriving sexp]

  let decode_destroy_notify_event buf ~at : (destroy_notify_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    ignore orig;
    Some ({ event; window }, at)

  type unmap_notify_event = {
    event : window;
    window : window;
    from_configure : bool;
  }
  [@@deriving sexp]

  let decode_unmap_notify_event buf ~at : (unmap_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* from_configure, at = decode_bool buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ event; window; from_configure }, at)

  type map_notify_event = {
    event : window;
    window : window;
    override_redirect : bool;
  }
  [@@deriving sexp]

  let decode_map_notify_event buf ~at : (map_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* override_redirect, at = decode_bool buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ event; window; override_redirect }, at)

  type map_request_event = { parent : window; window : window }
  [@@deriving sexp]

  let decode_map_request_event buf ~at : (map_request_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* parent, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    ignore orig;
    Some ({ parent; window }, at)

  type reparent_notify_event = {
    event : window;
    window : window;
    parent : window;
    x : int;
    y : int;
    override_redirect : bool;
  }
  [@@deriving sexp]

  let decode_reparent_notify_event buf ~at :
      (reparent_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* parent, at = decode_window buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* override_redirect, at = decode_bool buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ event; window; parent; x; y; override_redirect }, at)

  type configure_notify_event = {
    event : window;
    window : window;
    above_sibling : window_enum alt_enum;
    x : int;
    y : int;
    width : int;
    height : int;
    border_width : int;
    override_redirect : bool;
  }
  [@@deriving sexp]

  let decode_configure_notify_event buf ~at :
      (configure_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* above_sibling, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* border_width, at = decode_uint16 buf ~at in
    let* override_redirect, at = decode_bool buf ~at in
    let at = at + 1 in
    ignore orig;
    Some
      ( {
          event;
          window;
          above_sibling;
          x;
          y;
          width;
          height;
          border_width;
          override_redirect;
        },
        at )

  type stack_mode_enum = [ `Above | `Below | `Top_if | `Bottom_if | `Opposite ]
  [@@deriving sexp]

  let stack_mode_enum_of_int : int -> [> stack_mode_enum ] option = function
    | 0 -> Some `Above
    | 1 -> Some `Below
    | 2 -> Some `Top_if
    | 3 -> Some `Bottom_if
    | 4 -> Some `Opposite
    | n ->
        Printf.printf "unknown stack_mode_enum: %d\n" n;
        None

  let stack_mode_int_of_enum : stack_mode_enum -> int = function
    | `Above -> 0
    | `Below -> 1
    | `Top_if -> 2
    | `Bottom_if -> 3
    | `Opposite -> 4

  type config_window_mask =
    [ `X | `Y | `Width | `Height | `Border_width | `Sibling | `Stack_mode ] list
  [@@deriving sexp]

  let config_window_mask_of_int64 mask : config_window_mask option =
    let of_int = function
      | 0 -> Some `X
      | 1 -> Some `Y
      | 2 -> Some `Width
      | 3 -> Some `Height
      | 4 -> Some `Border_width
      | 5 -> Some `Sibling
      | 6 -> Some `Stack_mode
      | _ -> None
    in
    mask_of_int of_int mask

  let config_window_int_of_mask : config_window_mask -> int =
    let to_bit = function
      | `X -> 0
      | `Y -> 1
      | `Width -> 2
      | `Height -> 3
      | `Border_width -> 4
      | `Sibling -> 5
      | `Stack_mode -> 6
    in
    int_of_mask to_bit

  type configure_request_event = {
    stack_mode : stack_mode_enum;
    parent : window;
    window : window;
    sibling : window_enum alt_enum;
    x : int;
    y : int;
    width : int;
    height : int;
    border_width : int;
    value_mask : config_window_mask;
  }
  [@@deriving sexp]

  let decode_configure_request_event buf ~at :
      (configure_request_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* stack_mode, at =
      decode_enum decode_char Char.code stack_mode_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* parent, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* sibling, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* border_width, at = decode_uint16 buf ~at in
    let* value_mask, at =
      decode_mask decode_uint16 Int64.of_int config_window_mask_of_int64 buf ~at
    in
    ignore orig;
    Some
      ( {
          stack_mode;
          parent;
          window;
          sibling;
          x;
          y;
          width;
          height;
          border_width;
          value_mask;
        },
        at )

  type gravity_notify_event = {
    event : window;
    window : window;
    x : int;
    y : int;
  }
  [@@deriving sexp]

  let decode_gravity_notify_event buf ~at : (gravity_notify_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ event; window; x; y }, at)

  type resize_request_event = { window : window; width : int; height : int }
  [@@deriving sexp]

  let decode_resize_request_event buf ~at : (resize_request_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = decode_window buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ window; width; height }, at)

  type place_enum = [ `On_top | `On_bottom ] [@@deriving sexp]

  let place_enum_of_int : int -> [> place_enum ] option = function
    | 0 -> Some `On_top
    | 1 -> Some `On_bottom
    | n ->
        Printf.printf "unknown place_enum: %d\n" n;
        None

  let place_int_of_enum : place_enum -> int = function
    | `On_top -> 0
    | `On_bottom -> 1

  type circulate_notify_event = {
    event : window;
    window : window;
    place : place_enum;
  }
  [@@deriving sexp]

  let decode_circulate_notify_event buf ~at :
      (circulate_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_window buf ~at in
    let* window, at = decode_window buf ~at in
    let at = at + 4 in
    let* place, at =
      decode_enum decode_char Char.code place_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some ({ event; window; place }, at)

  type circulate_request_event = circulate_notify_event [@@deriving sexp]
  type property_enum = [ `New_value | `Delete ] [@@deriving sexp]

  let property_enum_of_int : int -> [> property_enum ] option = function
    | 0 -> Some `New_value
    | 1 -> Some `Delete
    | n ->
        Printf.printf "unknown property_enum: %d\n" n;
        None

  let property_int_of_enum : property_enum -> int = function
    | `New_value -> 0
    | `Delete -> 1

  type property_notify_event = {
    window : window;
    atom : atom;
    time : timestamp;
    state : property_enum;
  }
  [@@deriving sexp]

  let decode_property_notify_event buf ~at :
      (property_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = decode_window buf ~at in
    let* atom, at = decode_atom buf ~at in
    let* time, at = decode_timestamp buf ~at in
    let* state, at =
      decode_enum decode_char Char.code property_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some ({ window; atom; time; state }, at)

  type selection_clear_event = {
    time : timestamp;
    owner : window;
    selection : atom;
  }
  [@@deriving sexp]

  let decode_selection_clear_event buf ~at :
      (selection_clear_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = decode_timestamp buf ~at in
    let* owner, at = decode_window buf ~at in
    let* selection, at = decode_atom buf ~at in
    ignore orig;
    Some ({ time; owner; selection }, at)

  type time_enum = [ `Current_time ] [@@deriving sexp]

  let time_enum_of_int : int -> [> time_enum ] option = function
    | 0 -> Some `Current_time
    | n ->
        Printf.printf "unknown time_enum: %d\n" n;
        None

  let time_int_of_enum : time_enum -> int = function `Current_time -> 0

  type atom_enum =
    [ `None
    | `Any
    | `Primary
    | `Secondary
    | `Arc
    | `Atom
    | `Bitmap
    | `Cardinal
    | `Colormap
    | `Cursor
    | `Cut_buffer0
    | `Cut_buffer1
    | `Cut_buffer2
    | `Cut_buffer3
    | `Cut_buffer4
    | `Cut_buffer5
    | `Cut_buffer6
    | `Cut_buffer7
    | `Drawable
    | `Font
    | `Integer
    | `Pixmap
    | `Point
    | `Rectangle
    | `Resource_manager
    | `Rgb_color_map
    | `Rgb_best_map
    | `Rgb_blue_map
    | `Rgb_default_map
    | `Rgb_gray_map
    | `Rgb_green_map
    | `Rgb_red_map
    | `String
    | `Visualid
    | `Window
    | `Wm_command
    | `Wm_hints
    | `Wm_client_machine
    | `Wm_icon_name
    | `Wm_icon_size
    | `Wm_name
    | `Wm_normal_hints
    | `Wm_size_hints
    | `Wm_zoom_hints
    | `Min_space
    | `Norm_space
    | `Max_space
    | `End_space
    | `Superscript_x
    | `Superscript_y
    | `Subscript_x
    | `Subscript_y
    | `Underline_position
    | `Underline_thickness
    | `Strikeout_ascent
    | `Strikeout_descent
    | `Italic_angle
    | `X_height
    | `Quad_width
    | `Weight
    | `Point_size
    | `Resolution
    | `Copyright
    | `Notice
    | `Font_name
    | `Family_name
    | `Full_name
    | `Cap_height
    | `Wm_class
    | `Wm_transient_for ]
  [@@deriving sexp]

  let atom_enum_of_int : int -> [> atom_enum ] option = function
    | 0 -> Some `None
    | 0 -> Some `Any
    | 1 -> Some `Primary
    | 2 -> Some `Secondary
    | 3 -> Some `Arc
    | 4 -> Some `Atom
    | 5 -> Some `Bitmap
    | 6 -> Some `Cardinal
    | 7 -> Some `Colormap
    | 8 -> Some `Cursor
    | 9 -> Some `Cut_buffer0
    | 10 -> Some `Cut_buffer1
    | 11 -> Some `Cut_buffer2
    | 12 -> Some `Cut_buffer3
    | 13 -> Some `Cut_buffer4
    | 14 -> Some `Cut_buffer5
    | 15 -> Some `Cut_buffer6
    | 16 -> Some `Cut_buffer7
    | 17 -> Some `Drawable
    | 18 -> Some `Font
    | 19 -> Some `Integer
    | 20 -> Some `Pixmap
    | 21 -> Some `Point
    | 22 -> Some `Rectangle
    | 23 -> Some `Resource_manager
    | 24 -> Some `Rgb_color_map
    | 25 -> Some `Rgb_best_map
    | 26 -> Some `Rgb_blue_map
    | 27 -> Some `Rgb_default_map
    | 28 -> Some `Rgb_gray_map
    | 29 -> Some `Rgb_green_map
    | 30 -> Some `Rgb_red_map
    | 31 -> Some `String
    | 32 -> Some `Visualid
    | 33 -> Some `Window
    | 34 -> Some `Wm_command
    | 35 -> Some `Wm_hints
    | 36 -> Some `Wm_client_machine
    | 37 -> Some `Wm_icon_name
    | 38 -> Some `Wm_icon_size
    | 39 -> Some `Wm_name
    | 40 -> Some `Wm_normal_hints
    | 41 -> Some `Wm_size_hints
    | 42 -> Some `Wm_zoom_hints
    | 43 -> Some `Min_space
    | 44 -> Some `Norm_space
    | 45 -> Some `Max_space
    | 46 -> Some `End_space
    | 47 -> Some `Superscript_x
    | 48 -> Some `Superscript_y
    | 49 -> Some `Subscript_x
    | 50 -> Some `Subscript_y
    | 51 -> Some `Underline_position
    | 52 -> Some `Underline_thickness
    | 53 -> Some `Strikeout_ascent
    | 54 -> Some `Strikeout_descent
    | 55 -> Some `Italic_angle
    | 56 -> Some `X_height
    | 57 -> Some `Quad_width
    | 58 -> Some `Weight
    | 59 -> Some `Point_size
    | 60 -> Some `Resolution
    | 61 -> Some `Copyright
    | 62 -> Some `Notice
    | 63 -> Some `Font_name
    | 64 -> Some `Family_name
    | 65 -> Some `Full_name
    | 66 -> Some `Cap_height
    | 67 -> Some `Wm_class
    | 68 -> Some `Wm_transient_for
    | n ->
        Printf.printf "unknown atom_enum: %d\n" n;
        None

  let atom_int_of_enum : atom_enum -> int = function
    | `None -> 0
    | `Any -> 0
    | `Primary -> 1
    | `Secondary -> 2
    | `Arc -> 3
    | `Atom -> 4
    | `Bitmap -> 5
    | `Cardinal -> 6
    | `Colormap -> 7
    | `Cursor -> 8
    | `Cut_buffer0 -> 9
    | `Cut_buffer1 -> 10
    | `Cut_buffer2 -> 11
    | `Cut_buffer3 -> 12
    | `Cut_buffer4 -> 13
    | `Cut_buffer5 -> 14
    | `Cut_buffer6 -> 15
    | `Cut_buffer7 -> 16
    | `Drawable -> 17
    | `Font -> 18
    | `Integer -> 19
    | `Pixmap -> 20
    | `Point -> 21
    | `Rectangle -> 22
    | `Resource_manager -> 23
    | `Rgb_color_map -> 24
    | `Rgb_best_map -> 25
    | `Rgb_blue_map -> 26
    | `Rgb_default_map -> 27
    | `Rgb_gray_map -> 28
    | `Rgb_green_map -> 29
    | `Rgb_red_map -> 30
    | `String -> 31
    | `Visualid -> 32
    | `Window -> 33
    | `Wm_command -> 34
    | `Wm_hints -> 35
    | `Wm_client_machine -> 36
    | `Wm_icon_name -> 37
    | `Wm_icon_size -> 38
    | `Wm_name -> 39
    | `Wm_normal_hints -> 40
    | `Wm_size_hints -> 41
    | `Wm_zoom_hints -> 42
    | `Min_space -> 43
    | `Norm_space -> 44
    | `Max_space -> 45
    | `End_space -> 46
    | `Superscript_x -> 47
    | `Superscript_y -> 48
    | `Subscript_x -> 49
    | `Subscript_y -> 50
    | `Underline_position -> 51
    | `Underline_thickness -> 52
    | `Strikeout_ascent -> 53
    | `Strikeout_descent -> 54
    | `Italic_angle -> 55
    | `X_height -> 56
    | `Quad_width -> 57
    | `Weight -> 58
    | `Point_size -> 59
    | `Resolution -> 60
    | `Copyright -> 61
    | `Notice -> 62
    | `Font_name -> 63
    | `Family_name -> 64
    | `Full_name -> 65
    | `Cap_height -> 66
    | `Wm_class -> 67
    | `Wm_transient_for -> 68

  type selection_request_event = {
    time : time_enum alt_enum;
    owner : window;
    requestor : window;
    selection : atom;
    target : atom;
    property : atom_enum alt_enum;
  }
  [@@deriving sexp]

  let decode_selection_request_event buf ~at :
      (selection_request_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum decode_timestamp identity time_enum_of_int buf ~at
    in
    let* owner, at = decode_window buf ~at in
    let* requestor, at = decode_window buf ~at in
    let* selection, at = decode_atom buf ~at in
    let* target, at = decode_atom buf ~at in
    let* property, at =
      decode_alt_enum decode_atom identity atom_enum_of_int buf ~at
    in
    ignore orig;
    Some ({ time; owner; requestor; selection; target; property }, at)

  type selection_notify_event = {
    time : time_enum alt_enum;
    requestor : window;
    selection : atom;
    target : atom;
    property : atom_enum alt_enum;
  }
  [@@deriving sexp]

  let decode_selection_notify_event buf ~at :
      (selection_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum decode_timestamp identity time_enum_of_int buf ~at
    in
    let* requestor, at = decode_window buf ~at in
    let* selection, at = decode_atom buf ~at in
    let* target, at = decode_atom buf ~at in
    let* property, at =
      decode_alt_enum decode_atom identity atom_enum_of_int buf ~at
    in
    ignore orig;
    Some ({ time; requestor; selection; target; property }, at)

  type colormap_state_enum = [ `Uninstalled | `Installed ] [@@deriving sexp]

  let colormap_state_enum_of_int : int -> [> colormap_state_enum ] option =
    function
    | 0 -> Some `Uninstalled
    | 1 -> Some `Installed
    | n ->
        Printf.printf "unknown colormap_state_enum: %d\n" n;
        None

  let colormap_state_int_of_enum : colormap_state_enum -> int = function
    | `Uninstalled -> 0
    | `Installed -> 1

  type colormap_enum = [ `None ] [@@deriving sexp]

  let colormap_enum_of_int : int -> [> colormap_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown colormap_enum: %d\n" n;
        None

  let colormap_int_of_enum : colormap_enum -> int = function `None -> 0

  type colormap_notify_event = {
    window : window;
    colormap : colormap_enum alt_enum;
    new_ : bool;
    state : colormap_state_enum;
  }
  [@@deriving sexp]

  let decode_colormap_notify_event buf ~at :
      (colormap_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = decode_window buf ~at in
    let* colormap, at =
      decode_alt_enum decode_colormap identity colormap_enum_of_int buf ~at
    in
    let* new_, at = decode_bool buf ~at in
    let* state, at =
      decode_enum decode_char Char.code colormap_state_enum_of_int buf ~at
    in
    let at = at + 2 in
    ignore orig;
    Some ({ window; colormap; new_; state }, at)

  type client_message_data_format_enum = [ `Data8 | `Data16 | `Data32 ]
  [@@deriving sexp]

  let client_message_data_format_enum_of_int :
      int -> [> client_message_data_format_enum ] option = function
    | 8 -> Some `Data8
    | 16 -> Some `Data16
    | 32 -> Some `Data32
    | n ->
        Printf.printf "unknown client_message_data_format_enum: %d\n" n;
        None

  let client_message_data_format_int_of_enum :
      client_message_data_format_enum -> int = function
    | `Data8 -> 8
    | `Data16 -> 16
    | `Data32 -> 32

  type client_message_data_format_variant =
    | Data8 of { data8 : int list }
    | Data16 of { data16 : int list }
    | Data32 of { data32 : int list }
  [@@deriving sexp]

  let decode_client_message_data_format_variant tag buf ~at :
      (client_message_data_format_variant * int) option =
    match tag with
    | 8 ->
        let* data8, at =
          let length = 20 in
          decode_list decode_uint8 length buf ~at
        in
        Some (Data8 { data8 }, at)
    | 16 ->
        let* data16, at =
          let length = 10 in
          decode_list decode_uint16 length buf ~at
        in
        Some (Data16 { data16 }, at)
    | 32 ->
        let* data32, at =
          let length = 5 in
          decode_list decode_int32 length buf ~at
        in
        Some (Data32 { data32 }, at)
    | _ -> None

  type client_message_event = {
    window : window;
    type_ : atom;
    data : client_message_data_format_variant;
  }
  [@@deriving sexp]

  let decode_client_message_event buf ~at : (client_message_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* data_tag, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = decode_window buf ~at in
    let* type_, at = decode_atom buf ~at in
    let* data, at =
      decode_client_message_data_format_variant data_tag buf ~at
    in
    ignore orig;
    Some ({ window; type_; data }, at)

  type mapping_enum = [ `Modifier | `Keyboard | `Pointer ] [@@deriving sexp]

  let mapping_enum_of_int : int -> [> mapping_enum ] option = function
    | 0 -> Some `Modifier
    | 1 -> Some `Keyboard
    | 2 -> Some `Pointer
    | n ->
        Printf.printf "unknown mapping_enum: %d\n" n;
        None

  let mapping_int_of_enum : mapping_enum -> int = function
    | `Modifier -> 0
    | `Keyboard -> 1
    | `Pointer -> 2

  type mapping_notify_event = {
    request : mapping_enum;
    first_keycode : keycode;
    count : int;
  }
  [@@deriving sexp]

  let decode_mapping_notify_event buf ~at : (mapping_notify_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* request, at =
      decode_enum decode_char Char.code mapping_enum_of_int buf ~at
    in
    let* first_keycode, at = decode_keycode buf ~at in
    let* count, at = decode_uint8 buf ~at in
    let at = at + 1 in
    ignore orig;
    Some ({ request; first_keycode; count }, at)

  type ge_generic_event = unit [@@deriving sexp]

  let decode_ge_generic_event buf ~at : (ge_generic_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 22 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    ignore orig;
    Some ((), at)

  type request_error = {
    bad_value : int;
    minor_opcode : int;
    major_opcode : int;
  }
  [@@deriving sexp]

  type value_error = { bad_value : int; minor_opcode : int; major_opcode : int }
  [@@deriving sexp]

  type window_error = value_error [@@deriving sexp]
  type pixmap_error = value_error [@@deriving sexp]
  type atom_error = value_error [@@deriving sexp]
  type cursor_error = value_error [@@deriving sexp]
  type font_error = value_error [@@deriving sexp]
  type match_error = request_error [@@deriving sexp]
  type drawable_error = value_error [@@deriving sexp]
  type access_error = request_error [@@deriving sexp]
  type alloc_error = request_error [@@deriving sexp]
  type colormap_error = value_error [@@deriving sexp]
  type g_context_error = value_error [@@deriving sexp]
  type id_choice_error = value_error [@@deriving sexp]
  type name_error = request_error [@@deriving sexp]
  type length_error = request_error [@@deriving sexp]
  type implementation_error = request_error [@@deriving sexp]

  type window_class_enum = [ `Copy_from_parent | `Input_output | `Input_only ]
  [@@deriving sexp]

  let window_class_enum_of_int : int -> [> window_class_enum ] option = function
    | 0 -> Some `Copy_from_parent
    | 1 -> Some `Input_output
    | 2 -> Some `Input_only
    | n ->
        Printf.printf "unknown window_class_enum: %d\n" n;
        None

  let window_class_int_of_enum : window_class_enum -> int = function
    | `Copy_from_parent -> 0
    | `Input_output -> 1
    | `Input_only -> 2

  type cw_mask =
    [ `Back_pixmap
    | `Back_pixel
    | `Border_pixmap
    | `Border_pixel
    | `Bit_gravity
    | `Win_gravity
    | `Backing_store
    | `Backing_planes
    | `Backing_pixel
    | `Override_redirect
    | `Save_under
    | `Event_mask
    | `Dont_propagate
    | `Colormap
    | `Cursor ]
    list
  [@@deriving sexp]

  let cw_mask_of_int64 mask : cw_mask option =
    let of_int = function
      | 0 -> Some `Back_pixmap
      | 1 -> Some `Back_pixel
      | 2 -> Some `Border_pixmap
      | 3 -> Some `Border_pixel
      | 4 -> Some `Bit_gravity
      | 5 -> Some `Win_gravity
      | 6 -> Some `Backing_store
      | 7 -> Some `Backing_planes
      | 8 -> Some `Backing_pixel
      | 9 -> Some `Override_redirect
      | 10 -> Some `Save_under
      | 11 -> Some `Event_mask
      | 12 -> Some `Dont_propagate
      | 13 -> Some `Colormap
      | 14 -> Some `Cursor
      | _ -> None
    in
    mask_of_int of_int mask

  let cw_int_of_mask : cw_mask -> int =
    let to_bit = function
      | `Back_pixmap -> 0
      | `Back_pixel -> 1
      | `Border_pixmap -> 2
      | `Border_pixel -> 3
      | `Bit_gravity -> 4
      | `Win_gravity -> 5
      | `Backing_store -> 6
      | `Backing_planes -> 7
      | `Backing_pixel -> 8
      | `Override_redirect -> 9
      | `Save_under -> 10
      | `Event_mask -> 11
      | `Dont_propagate -> 12
      | `Colormap -> 13
      | `Cursor -> 14
    in
    int_of_mask to_bit

  type back_pixmap_enum = [ `None | `Parent_relative ] [@@deriving sexp]

  let back_pixmap_enum_of_int : int -> [> back_pixmap_enum ] option = function
    | 0 -> Some `None
    | 1 -> Some `Parent_relative
    | n ->
        Printf.printf "unknown back_pixmap_enum: %d\n" n;
        None

  let back_pixmap_int_of_enum : back_pixmap_enum -> int = function
    | `None -> 0
    | `Parent_relative -> 1

  type gravity_enum =
    [ `Bit_forget
    | `Win_unmap
    | `North_west
    | `North
    | `North_east
    | `West
    | `Center
    | `East
    | `South_west
    | `South
    | `South_east
    | `Static ]
  [@@deriving sexp]

  let gravity_enum_of_int : int -> [> gravity_enum ] option = function
    | 0 -> Some `Bit_forget
    | 0 -> Some `Win_unmap
    | 1 -> Some `North_west
    | 2 -> Some `North
    | 3 -> Some `North_east
    | 4 -> Some `West
    | 5 -> Some `Center
    | 6 -> Some `East
    | 7 -> Some `South_west
    | 8 -> Some `South
    | 9 -> Some `South_east
    | 10 -> Some `Static
    | n ->
        Printf.printf "unknown gravity_enum: %d\n" n;
        None

  let gravity_int_of_enum : gravity_enum -> int = function
    | `Bit_forget -> 0
    | `Win_unmap -> 0
    | `North_west -> 1
    | `North -> 2
    | `North_east -> 3
    | `West -> 4
    | `Center -> 5
    | `East -> 6
    | `South_west -> 7
    | `South -> 8
    | `South_east -> 9
    | `Static -> 10

  type pixmap_enum = [ `None ] [@@deriving sexp]

  let pixmap_enum_of_int : int -> [> pixmap_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown pixmap_enum: %d\n" n;
        None

  let pixmap_int_of_enum : pixmap_enum -> int = function `None -> 0

  type cursor_enum = [ `None ] [@@deriving sexp]

  let cursor_enum_of_int : int -> [> cursor_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown cursor_enum: %d\n" n;
        None

  let cursor_int_of_enum : cursor_enum -> int = function `None -> 0

  let encode_create_window ~(depth : int) ~(wid : window) ~(parent : window)
      ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(border_width : int)
      ~(class_ : window_class_enum) ~(visual : visualid)
      ?(background_pixmap : back_pixmap_enum alt_enum option)
      ?(background_pixel : int option)
      ?(border_pixmap : pixmap_enum alt_enum option)
      ?(border_pixel : int option) ?(bit_gravity : gravity_enum option)
      ?(win_gravity : gravity_enum option)
      ?(backing_store : backing_store_enum option)
      ?(backing_planes : int option) ?(backing_pixel : int option)
      ?(override_redirect : bool32 option) ?(save_under : bool32 option)
      ?(event_mask : event_mask option)
      ?(do_not_propogate_mask : event_mask option)
      ?(colormap : colormap_enum alt_enum option)
      ?(cursor : cursor_enum alt_enum option) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_uint8 buf depth;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf wid;
    encode_window buf parent;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_uint16 buf border_width;
    encode_enum encode_uint16 identity window_class_int_of_enum buf class_;
    encode_visualid buf visual;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some background_pixmap, 0);
        (Option.is_some background_pixel, 1);
        (Option.is_some border_pixmap, 2);
        (Option.is_some border_pixel, 3);
        (Option.is_some bit_gravity, 4);
        (Option.is_some win_gravity, 5);
        (Option.is_some backing_store, 6);
        (Option.is_some backing_planes, 7);
        (Option.is_some backing_pixel, 8);
        (Option.is_some override_redirect, 9);
        (Option.is_some save_under, 10);
        (Option.is_some event_mask, 11);
        (Option.is_some do_not_propogate_mask, 12);
        (Option.is_some colormap, 13);
        (Option.is_some cursor, 14);
      ];
    (match background_pixmap with
    | None -> ()
    | Some v ->
        encode_alt_enum encode_pixmap identity back_pixmap_int_of_enum buf v);
    (match background_pixel with None -> () | Some v -> encode_int32 buf v);
    (match border_pixmap with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match border_pixel with None -> () | Some v -> encode_int32 buf v);
    (match bit_gravity with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity gravity_int_of_enum buf v);
    (match win_gravity with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity gravity_int_of_enum buf v);
    (match backing_store with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity backing_store_int_of_enum buf v);
    (match backing_planes with None -> () | Some v -> encode_int32 buf v);
    (match backing_pixel with None -> () | Some v -> encode_int32 buf v);
    (match override_redirect with None -> () | Some v -> encode_bool32 buf v);
    (match save_under with None -> () | Some v -> encode_bool32 buf v);
    (match event_mask with
    | None -> ()
    | Some v -> encode_mask encode_int32 identity event_mask_int_of_mask buf v);
    (match do_not_propogate_mask with
    | None -> ()
    | Some v -> encode_mask encode_int32 identity event_mask_int_of_mask buf v);
    (match colormap with
    | None -> ()
    | Some v ->
        encode_alt_enum encode_colormap identity colormap_int_of_enum buf v);
    (match cursor with
    | None -> ()
    | Some v -> encode_alt_enum encode_cursor identity cursor_int_of_enum buf v);
    (* write request length *)
    encode_request_length buf

  let encode_change_window_attributes ~(window : window)
      ?(background_pixmap : back_pixmap_enum alt_enum option)
      ?(background_pixel : int option)
      ?(border_pixmap : pixmap_enum alt_enum option)
      ?(border_pixel : int option) ?(bit_gravity : gravity_enum option)
      ?(win_gravity : gravity_enum option)
      ?(backing_store : backing_store_enum option)
      ?(backing_planes : int option) ?(backing_pixel : int option)
      ?(override_redirect : bool32 option) ?(save_under : bool32 option)
      ?(event_mask : event_mask option)
      ?(do_not_propogate_mask : event_mask option)
      ?(colormap : colormap_enum alt_enum option)
      ?(cursor : cursor_enum alt_enum option) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some background_pixmap, 0);
        (Option.is_some background_pixel, 1);
        (Option.is_some border_pixmap, 2);
        (Option.is_some border_pixel, 3);
        (Option.is_some bit_gravity, 4);
        (Option.is_some win_gravity, 5);
        (Option.is_some backing_store, 6);
        (Option.is_some backing_planes, 7);
        (Option.is_some backing_pixel, 8);
        (Option.is_some override_redirect, 9);
        (Option.is_some save_under, 10);
        (Option.is_some event_mask, 11);
        (Option.is_some do_not_propogate_mask, 12);
        (Option.is_some colormap, 13);
        (Option.is_some cursor, 14);
      ];
    (match background_pixmap with
    | None -> ()
    | Some v ->
        encode_alt_enum encode_pixmap identity back_pixmap_int_of_enum buf v);
    (match background_pixel with None -> () | Some v -> encode_int32 buf v);
    (match border_pixmap with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match border_pixel with None -> () | Some v -> encode_int32 buf v);
    (match bit_gravity with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity gravity_int_of_enum buf v);
    (match win_gravity with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity gravity_int_of_enum buf v);
    (match backing_store with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity backing_store_int_of_enum buf v);
    (match backing_planes with None -> () | Some v -> encode_int32 buf v);
    (match backing_pixel with None -> () | Some v -> encode_int32 buf v);
    (match override_redirect with None -> () | Some v -> encode_bool32 buf v);
    (match save_under with None -> () | Some v -> encode_bool32 buf v);
    (match event_mask with
    | None -> ()
    | Some v -> encode_mask encode_int32 identity event_mask_int_of_mask buf v);
    (match do_not_propogate_mask with
    | None -> ()
    | Some v -> encode_mask encode_int32 identity event_mask_int_of_mask buf v);
    (match colormap with
    | None -> ()
    | Some v ->
        encode_alt_enum encode_colormap identity colormap_int_of_enum buf v);
    (match cursor with
    | None -> ()
    | Some v -> encode_alt_enum encode_cursor identity cursor_int_of_enum buf v);
    (* write request length *)
    encode_request_length buf

  type map_state_enum = [ `Unmapped | `Unviewable | `Viewable ]
  [@@deriving sexp]

  let map_state_enum_of_int : int -> [> map_state_enum ] option = function
    | 0 -> Some `Unmapped
    | 1 -> Some `Unviewable
    | 2 -> Some `Viewable
    | n ->
        Printf.printf "unknown map_state_enum: %d\n" n;
        None

  let map_state_int_of_enum : map_state_enum -> int = function
    | `Unmapped -> 0
    | `Unviewable -> 1
    | `Viewable -> 2

  type get_window_attributes_reply = {
    backing_store : backing_store_enum;
    visual : visualid;
    class_ : window_class_enum;
    bit_gravity : gravity_enum;
    win_gravity : gravity_enum;
    backing_planes : int;
    backing_pixel : int;
    save_under : bool;
    map_is_installed : bool;
    map_state : map_state_enum;
    override_redirect : bool;
    colormap : colormap_enum alt_enum;
    all_event_masks : event_mask;
    your_event_mask : event_mask;
    do_not_propagate_mask : event_mask;
  }
  [@@deriving sexp]

  let encode_get_window_attributes ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let decode_get_window_attributes_reply length buf ~at :
      (get_window_attributes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* backing_store, at =
      decode_enum decode_uint8 identity backing_store_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* visual, at = decode_visualid buf ~at in
    let* class_, at =
      decode_enum decode_uint16 identity window_class_enum_of_int buf ~at
    in
    let* bit_gravity, at =
      decode_enum decode_uint8 identity gravity_enum_of_int buf ~at
    in
    let* win_gravity, at =
      decode_enum decode_uint8 identity gravity_enum_of_int buf ~at
    in
    let* backing_planes, at = decode_int32 buf ~at in
    let* backing_pixel, at = decode_int32 buf ~at in
    let* save_under, at = decode_bool buf ~at in
    let* map_is_installed, at = decode_bool buf ~at in
    let* map_state, at =
      decode_enum decode_uint8 identity map_state_enum_of_int buf ~at
    in
    let* override_redirect, at = decode_bool buf ~at in
    let* colormap, at =
      decode_alt_enum decode_colormap identity colormap_enum_of_int buf ~at
    in
    let* all_event_masks, at =
      decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at
    in
    let* your_event_mask, at =
      decode_mask decode_int32 Int64.of_int event_mask_mask_of_int64 buf ~at
    in
    let* do_not_propagate_mask, at =
      decode_mask decode_uint16 Int64.of_int event_mask_mask_of_int64 buf ~at
    in
    let at = at + 2 in
    ignore orig;
    Some
      ( {
          backing_store;
          visual;
          class_;
          bit_gravity;
          win_gravity;
          backing_planes;
          backing_pixel;
          save_under;
          map_is_installed;
          map_state;
          override_redirect;
          colormap;
          all_event_masks;
          your_event_mask;
          do_not_propagate_mask;
        },
        at )

  let encode_destroy_window ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_destroy_subwindows ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  type set_mode_enum = [ `Insert | `Delete ] [@@deriving sexp]

  let set_mode_enum_of_int : int -> [> set_mode_enum ] option = function
    | 0 -> Some `Insert
    | 1 -> Some `Delete
    | n ->
        Printf.printf "unknown set_mode_enum: %d\n" n;
        None

  let set_mode_int_of_enum : set_mode_enum -> int = function
    | `Insert -> 0
    | `Delete -> 1

  let encode_change_save_set ~(mode : set_mode_enum) ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_enum encode_char Char.chr set_mode_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_reparent_window ~(window : window) ~(parent : window) ~(x : int)
      ~(y : int) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_window buf parent;
    encode_int16 buf x;
    encode_int16 buf y;
    (* write request length *)
    encode_request_length buf

  let encode_map_window ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_map_subwindows ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_unmap_window ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_unmap_subwindows ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_configure_window ~(window : window) ?(x : int option)
      ?(y : int option) ?(width : int option) ?(height : int option)
      ?(border_width : int option) ?(sibling : window_enum alt_enum option)
      ?(stack_mode : stack_mode_enum option) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_optional_mask encode_uint16 buf
      [
        (Option.is_some x, 0);
        (Option.is_some y, 1);
        (Option.is_some width, 2);
        (Option.is_some height, 3);
        (Option.is_some border_width, 4);
        (Option.is_some sibling, 5);
        (Option.is_some stack_mode, 6);
      ];
    encode_pad buf 2;
    (match x with None -> () | Some v -> encode_int32 buf v);
    (match y with None -> () | Some v -> encode_int32 buf v);
    (match width with None -> () | Some v -> encode_int32 buf v);
    (match height with None -> () | Some v -> encode_int32 buf v);
    (match border_width with None -> () | Some v -> encode_int32 buf v);
    (match sibling with
    | None -> ()
    | Some v -> encode_alt_enum encode_window identity window_int_of_enum buf v);
    (match stack_mode with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity stack_mode_int_of_enum buf v);
    (* write request length *)
    encode_request_length buf

  type circulate_enum = [ `Raise_lowest | `Lower_highest ] [@@deriving sexp]

  let circulate_enum_of_int : int -> [> circulate_enum ] option = function
    | 0 -> Some `Raise_lowest
    | 1 -> Some `Lower_highest
    | n ->
        Printf.printf "unknown circulate_enum: %d\n" n;
        None

  let circulate_int_of_enum : circulate_enum -> int = function
    | `Raise_lowest -> 0
    | `Lower_highest -> 1

  let encode_circulate_window ~(direction : circulate_enum) ~(window : window)
      buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_enum encode_uint8 identity circulate_int_of_enum buf direction;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  type get_geometry_reply = {
    depth : int;
    root : window;
    x : int;
    y : int;
    width : int;
    height : int;
    border_width : int;
  }
  [@@deriving sexp]

  let encode_get_geometry ~(drawable : drawable) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    (* write request length *)
    encode_request_length buf

  let decode_get_geometry_reply length buf ~at :
      (get_geometry_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* root, at = decode_window buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* border_width, at = decode_uint16 buf ~at in
    let at = at + 2 in
    ignore orig;
    Some ({ depth; root; x; y; width; height; border_width }, at)

  type query_tree_reply = {
    root : window;
    parent : window_enum alt_enum;
    children : window list;
  }
  [@@deriving sexp]

  let encode_query_tree ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let decode_query_tree_reply length buf ~at : (query_tree_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* root, at = decode_window buf ~at in
    let* parent, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* children_len, at = decode_uint16 buf ~at in
    let children_len = children_len in
    let at = at + 14 in
    let* children, at = decode_list decode_window children_len buf ~at in
    ignore orig;
    Some ({ root; parent; children }, at)

  type intern_atom_reply = atom_enum alt_enum [@@deriving sexp]

  let encode_intern_atom ~(only_if_exists : bool) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_bool buf only_if_exists;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_intern_atom_reply length buf ~at : (intern_atom_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* atom, at =
      decode_alt_enum decode_atom identity atom_enum_of_int buf ~at
    in
    ignore orig;
    Some (atom, at)

  type get_atom_name_reply = string [@@deriving sexp]

  let encode_get_atom_name ~(atom : atom) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_atom buf atom;
    (* write request length *)
    encode_request_length buf

  let decode_get_atom_name_reply length buf ~at :
      (get_atom_name_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* name_len, at = decode_uint16 buf ~at in
    let name_len = name_len in
    let at = at + 22 in
    let* name, at = decode_string name_len buf ~at in
    ignore orig;
    Some (name, at)

  type prop_mode_enum = [ `Replace | `Prepend | `Append ] [@@deriving sexp]

  let prop_mode_enum_of_int : int -> [> prop_mode_enum ] option = function
    | 0 -> Some `Replace
    | 1 -> Some `Prepend
    | 2 -> Some `Append
    | n ->
        Printf.printf "unknown prop_mode_enum: %d\n" n;
        None

  let prop_mode_int_of_enum : prop_mode_enum -> int = function
    | `Replace -> 0
    | `Prepend -> 1
    | `Append -> 2

  let encode_change_property ~(mode : prop_mode_enum) ~(window : window)
      ~(property : atom) ~(type_ : atom) ~(format : int) ~(data_len : int)
      ~(data : string) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_enum encode_uint8 identity prop_mode_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_atom buf property;
    encode_atom buf type_;
    encode_uint8 buf format;
    encode_pad buf 3;
    encode_int32 buf data_len;
    encode_string buf data;
    (* write request length *)
    encode_request_length buf

  let encode_delete_property ~(window : window) ~(property : atom) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  type get_property_type_enum = [ `Any ] [@@deriving sexp]

  let get_property_type_enum_of_int : int -> [> get_property_type_enum ] option
      = function
    | 0 -> Some `Any
    | n ->
        Printf.printf "unknown get_property_type_enum: %d\n" n;
        None

  let get_property_type_int_of_enum : get_property_type_enum -> int = function
    | `Any -> 0

  type get_property_reply = {
    format : int;
    type_ : atom;
    bytes_after : int;
    value_len : int;
    value : string;
  }
  [@@deriving sexp]

  let encode_get_property ~(delete : bool) ~(window : window) ~(property : atom)
      ~(type_ : get_property_type_enum alt_enum) ~(long_offset : int)
      ~(long_length : int) buf =
    (* opcode *)
    encode_uint8 buf 20;
    encode_bool buf delete;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_atom buf property;
    encode_alt_enum encode_atom identity get_property_type_int_of_enum buf type_;
    encode_int32 buf long_offset;
    encode_int32 buf long_length;
    (* write request length *)
    encode_request_length buf

  let decode_get_property_reply length buf ~at :
      (get_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* format, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* type_, at = decode_atom buf ~at in
    let* bytes_after, at = decode_int32 buf ~at in
    let* value_len, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* value, at =
      let length = value_len * (format / 8) in
      decode_string length buf ~at
    in
    ignore orig;
    Some ({ format; type_; bytes_after; value_len; value }, at)

  type list_properties_reply = atom list [@@deriving sexp]

  let encode_list_properties ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 21;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let decode_list_properties_reply length buf ~at :
      (list_properties_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* atoms_len, at = decode_uint16 buf ~at in
    let atoms_len = atoms_len in
    let at = at + 22 in
    let* atoms, at = decode_list decode_atom atoms_len buf ~at in
    ignore orig;
    Some (atoms, at)

  let encode_set_selection_owner ~(owner : window_enum alt_enum)
      ~(selection : atom) ~(time : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 22;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_window identity window_int_of_enum buf owner;
    encode_atom buf selection;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  type get_selection_owner_reply = window_enum alt_enum [@@deriving sexp]

  let encode_get_selection_owner ~(selection : atom) buf =
    (* opcode *)
    encode_uint8 buf 23;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_atom buf selection;
    (* write request length *)
    encode_request_length buf

  let decode_get_selection_owner_reply length buf ~at :
      (get_selection_owner_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* owner, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    ignore orig;
    Some (owner, at)

  let encode_convert_selection ~(requestor : window) ~(selection : atom)
      ~(target : atom) ~(property : atom_enum alt_enum)
      ~(time : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 24;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf requestor;
    encode_atom buf selection;
    encode_atom buf target;
    encode_alt_enum encode_atom identity atom_int_of_enum buf property;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  type send_event_dest_enum = [ `Pointer_window | `Item_focus ]
  [@@deriving sexp]

  let send_event_dest_enum_of_int : int -> [> send_event_dest_enum ] option =
    function
    | 0 -> Some `Pointer_window
    | 1 -> Some `Item_focus
    | n ->
        Printf.printf "unknown send_event_dest_enum: %d\n" n;
        None

  let send_event_dest_int_of_enum : send_event_dest_enum -> int = function
    | `Pointer_window -> 0
    | `Item_focus -> 1

  let encode_send_event ~(propagate : bool)
      ~(destination : send_event_dest_enum alt_enum) ~(event_mask : event_mask)
      ~(event : string) buf =
    (* opcode *)
    encode_uint8 buf 25;
    encode_bool buf propagate;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_window identity send_event_dest_int_of_enum buf
      destination;
    encode_mask encode_int32 identity event_mask_int_of_mask buf event_mask;
    encode_string buf event;
    (* write request length *)
    encode_request_length buf

  type grab_mode_enum = [ `Sync | `Async ] [@@deriving sexp]

  let grab_mode_enum_of_int : int -> [> grab_mode_enum ] option = function
    | 0 -> Some `Sync
    | 1 -> Some `Async
    | n ->
        Printf.printf "unknown grab_mode_enum: %d\n" n;
        None

  let grab_mode_int_of_enum : grab_mode_enum -> int = function
    | `Sync -> 0
    | `Async -> 1

  type grab_status_enum =
    [ `Success | `Already_grabbed | `Invalid_time | `Not_viewable | `Frozen ]
  [@@deriving sexp]

  let grab_status_enum_of_int : int -> [> grab_status_enum ] option = function
    | 0 -> Some `Success
    | 1 -> Some `Already_grabbed
    | 2 -> Some `Invalid_time
    | 3 -> Some `Not_viewable
    | 4 -> Some `Frozen
    | n ->
        Printf.printf "unknown grab_status_enum: %d\n" n;
        None

  let grab_status_int_of_enum : grab_status_enum -> int = function
    | `Success -> 0
    | `Already_grabbed -> 1
    | `Invalid_time -> 2
    | `Not_viewable -> 3
    | `Frozen -> 4

  type grab_pointer_reply = grab_status_enum [@@deriving sexp]

  let encode_grab_pointer ~(owner_events : bool) ~(grab_window : window)
      ~(event_mask : event_mask) ~(pointer_mode : grab_mode_enum)
      ~(keyboard_mode : grab_mode_enum) ~(confine_to : window_enum alt_enum)
      ~(cursor : cursor_enum alt_enum) ~(time : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 26;
    encode_bool buf owner_events;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf grab_window;
    encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask;
    encode_enum encode_char Char.chr grab_mode_int_of_enum buf pointer_mode;
    encode_enum encode_char Char.chr grab_mode_int_of_enum buf keyboard_mode;
    encode_alt_enum encode_window identity window_int_of_enum buf confine_to;
    encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  let decode_grab_pointer_reply length buf ~at :
      (grab_pointer_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_char Char.code grab_status_enum_of_int buf ~at
    in
    let at = at + 6 in
    ignore orig;
    Some (status, at)

  let encode_ungrab_pointer ~(time : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 27;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  type button_index_enum = [ `Any | `D1 | `D2 | `D3 | `D4 | `D5 ]
  [@@deriving sexp]

  let button_index_enum_of_int : int -> [> button_index_enum ] option = function
    | 0 -> Some `Any
    | 1 -> Some `D1
    | 2 -> Some `D2
    | 3 -> Some `D3
    | 4 -> Some `D4
    | 5 -> Some `D5
    | n ->
        Printf.printf "unknown button_index_enum: %d\n" n;
        None

  let button_index_int_of_enum : button_index_enum -> int = function
    | `Any -> 0
    | `D1 -> 1
    | `D2 -> 2
    | `D3 -> 3
    | `D4 -> 4
    | `D5 -> 5

  let encode_grab_button ~(owner_events : bool) ~(grab_window : window)
      ~(event_mask : event_mask) ~(pointer_mode : grab_mode_enum)
      ~(keyboard_mode : grab_mode_enum) ~(confine_to : window_enum alt_enum)
      ~(cursor : cursor_enum alt_enum) ~(button : button_index_enum)
      ~(modifiers : mod_mask) buf =
    (* opcode *)
    encode_uint8 buf 28;
    encode_bool buf owner_events;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf grab_window;
    encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask;
    encode_enum encode_uint8 identity grab_mode_int_of_enum buf pointer_mode;
    encode_enum encode_uint8 identity grab_mode_int_of_enum buf keyboard_mode;
    encode_alt_enum encode_window identity window_int_of_enum buf confine_to;
    encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor;
    encode_enum encode_uint8 identity button_index_int_of_enum buf button;
    encode_pad buf 1;
    encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers;
    (* write request length *)
    encode_request_length buf

  let encode_ungrab_button ~(button : button_index_enum) ~(grab_window : window)
      ~(modifiers : mod_mask) buf =
    (* opcode *)
    encode_uint8 buf 29;
    encode_enum encode_uint8 identity button_index_int_of_enum buf button;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf grab_window;
    encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let encode_change_active_pointer_grab ~(cursor : cursor_enum alt_enum)
      ~(time : time_enum alt_enum) ~(event_mask : event_mask) buf =
    (* opcode *)
    encode_uint8 buf 30;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_cursor identity cursor_int_of_enum buf cursor;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    encode_mask encode_uint16 identity event_mask_int_of_mask buf event_mask;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type grab_keyboard_reply = grab_status_enum [@@deriving sexp]

  let encode_grab_keyboard ~(owner_events : bool) ~(grab_window : window)
      ~(time : time_enum alt_enum) ~(pointer_mode : grab_mode_enum)
      ~(keyboard_mode : grab_mode_enum) buf =
    (* opcode *)
    encode_uint8 buf 31;
    encode_bool buf owner_events;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf grab_window;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    encode_enum encode_char Char.chr grab_mode_int_of_enum buf pointer_mode;
    encode_enum encode_char Char.chr grab_mode_int_of_enum buf keyboard_mode;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_grab_keyboard_reply length buf ~at :
      (grab_keyboard_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_char Char.code grab_status_enum_of_int buf ~at
    in
    let at = at + 6 in
    ignore orig;
    Some (status, at)

  let encode_ungrab_keyboard ~(time : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 32;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  type grab_enum = [ `Any ] [@@deriving sexp]

  let grab_enum_of_int : int -> [> grab_enum ] option = function
    | 0 -> Some `Any
    | n ->
        Printf.printf "unknown grab_enum: %d\n" n;
        None

  let grab_int_of_enum : grab_enum -> int = function `Any -> 0

  let encode_grab_key ~(owner_events : bool) ~(grab_window : window)
      ~(modifiers : mod_mask) ~(key : grab_enum alt_enum)
      ~(pointer_mode : grab_mode_enum) ~(keyboard_mode : grab_mode_enum) buf =
    (* opcode *)
    encode_uint8 buf 33;
    encode_bool buf owner_events;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf grab_window;
    encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers;
    encode_alt_enum encode_keycode identity grab_int_of_enum buf key;
    encode_enum encode_uint8 identity grab_mode_int_of_enum buf pointer_mode;
    encode_enum encode_uint8 identity grab_mode_int_of_enum buf keyboard_mode;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_ungrab_key ~(key : grab_enum alt_enum) ~(grab_window : window)
      ~(modifiers : mod_mask) buf =
    (* opcode *)
    encode_uint8 buf 34;
    encode_alt_enum encode_keycode identity grab_int_of_enum buf key;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf grab_window;
    encode_mask encode_uint16 identity mod_mask_int_of_mask buf modifiers;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type allow_enum =
    [ `Async_pointer
    | `Sync_pointer
    | `Replay_pointer
    | `Async_keyboard
    | `Sync_keyboard
    | `Replay_keyboard
    | `Async_both
    | `Sync_both ]
  [@@deriving sexp]

  let allow_enum_of_int : int -> [> allow_enum ] option = function
    | 0 -> Some `Async_pointer
    | 1 -> Some `Sync_pointer
    | 2 -> Some `Replay_pointer
    | 3 -> Some `Async_keyboard
    | 4 -> Some `Sync_keyboard
    | 5 -> Some `Replay_keyboard
    | 6 -> Some `Async_both
    | 7 -> Some `Sync_both
    | n ->
        Printf.printf "unknown allow_enum: %d\n" n;
        None

  let allow_int_of_enum : allow_enum -> int = function
    | `Async_pointer -> 0
    | `Sync_pointer -> 1
    | `Replay_pointer -> 2
    | `Async_keyboard -> 3
    | `Sync_keyboard -> 4
    | `Replay_keyboard -> 5
    | `Async_both -> 6
    | `Sync_both -> 7

  let encode_allow_events ~(mode : allow_enum) ~(time : time_enum alt_enum) buf
      =
    (* opcode *)
    encode_uint8 buf 35;
    encode_enum encode_uint8 identity allow_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  let encode_grab_server buf =
    (* opcode *)
    encode_uint8 buf 36;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_ungrab_server buf =
    (* opcode *)
    encode_uint8 buf 37;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type query_pointer_reply = {
    same_screen : bool;
    root : window;
    child : window_enum alt_enum;
    root_x : int;
    root_y : int;
    win_x : int;
    win_y : int;
    mask : key_but_mask;
  }
  [@@deriving sexp]

  let encode_query_pointer ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 38;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let decode_query_pointer_reply length buf ~at :
      (query_pointer_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* same_screen, at = decode_bool buf ~at in
    let at = at + 6 in
    let* root, at = decode_window buf ~at in
    let* child, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* root_x, at = decode_int16 buf ~at in
    let* root_y, at = decode_int16 buf ~at in
    let* win_x, at = decode_int16 buf ~at in
    let* win_y, at = decode_int16 buf ~at in
    let* mask, at =
      decode_mask decode_uint16 Int64.of_int key_but_mask_mask_of_int64 buf ~at
    in
    let at = at + 2 in
    ignore orig;
    Some ({ same_screen; root; child; root_x; root_y; win_x; win_y; mask }, at)

  type timecoord = { time : timestamp; x : int; y : int } [@@deriving sexp]

  let decode_timecoord buf ~at : (timecoord * int) option =
    let orig = at in
    let* time, at = decode_timestamp buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ time; x; y }, at)

  let encode_timecoord buf (v : timecoord) =
    encode_timestamp buf v.time;
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    ()

  type get_motion_events_reply = timecoord list [@@deriving sexp]

  let encode_get_motion_events ~(window : window) ~(start : time_enum alt_enum)
      ~(stop : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 39;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf start;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf stop;
    (* write request length *)
    encode_request_length buf

  let decode_get_motion_events_reply length buf ~at :
      (get_motion_events_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* events_len, at = decode_int32 buf ~at in
    let events_len = events_len in
    let at = at + 20 in
    let* events, at = decode_list decode_timecoord events_len buf ~at in
    ignore orig;
    Some (events, at)

  type translate_coordinates_reply = {
    same_screen : bool;
    child : window_enum alt_enum;
    dst_x : int;
    dst_y : int;
  }
  [@@deriving sexp]

  let encode_translate_coordinates ~(src_window : window) ~(dst_window : window)
      ~(src_x : int) ~(src_y : int) buf =
    (* opcode *)
    encode_uint8 buf 40;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf src_window;
    encode_window buf dst_window;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    (* write request length *)
    encode_request_length buf

  let decode_translate_coordinates_reply length buf ~at :
      (translate_coordinates_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* same_screen, at = decode_bool buf ~at in
    let at = at + 6 in
    let* child, at =
      decode_alt_enum decode_window identity window_enum_of_int buf ~at
    in
    let* dst_x, at = decode_int16 buf ~at in
    let* dst_y, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ same_screen; child; dst_x; dst_y }, at)

  let encode_warp_pointer ~(src_window : window_enum alt_enum)
      ~(dst_window : window_enum alt_enum) ~(src_x : int) ~(src_y : int)
      ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int) buf =
    (* opcode *)
    encode_uint8 buf 41;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_window identity window_int_of_enum buf src_window;
    encode_alt_enum encode_window identity window_int_of_enum buf dst_window;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_uint16 buf src_width;
    encode_uint16 buf src_height;
    encode_int16 buf dst_x;
    encode_int16 buf dst_y;
    (* write request length *)
    encode_request_length buf

  type input_focus_enum = [ `None | `Pointer_root | `Parent | `Follow_keyboard ]
  [@@deriving sexp]

  let input_focus_enum_of_int : int -> [> input_focus_enum ] option = function
    | 0 -> Some `None
    | 1 -> Some `Pointer_root
    | 2 -> Some `Parent
    | 3 -> Some `Follow_keyboard
    | n ->
        Printf.printf "unknown input_focus_enum: %d\n" n;
        None

  let input_focus_int_of_enum : input_focus_enum -> int = function
    | `None -> 0
    | `Pointer_root -> 1
    | `Parent -> 2
    | `Follow_keyboard -> 3

  let encode_set_input_focus ~(revert_to : input_focus_enum)
      ~(focus : input_focus_enum alt_enum) ~(time : time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 42;
    encode_enum encode_uint8 identity input_focus_int_of_enum buf revert_to;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_window identity input_focus_int_of_enum buf focus;
    encode_alt_enum encode_timestamp identity time_int_of_enum buf time;
    (* write request length *)
    encode_request_length buf

  type get_input_focus_reply = {
    revert_to : input_focus_enum;
    focus : input_focus_enum alt_enum;
  }
  [@@deriving sexp]

  let encode_get_input_focus buf =
    (* opcode *)
    encode_uint8 buf 43;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_input_focus_reply length buf ~at :
      (get_input_focus_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* revert_to, at =
      decode_enum decode_uint8 identity input_focus_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* focus, at =
      decode_alt_enum decode_window identity input_focus_enum_of_int buf ~at
    in
    ignore orig;
    Some ({ revert_to; focus }, at)

  type query_keymap_reply = int list [@@deriving sexp]

  let encode_query_keymap buf =
    (* opcode *)
    encode_uint8 buf 44;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_keymap_reply length buf ~at :
      (query_keymap_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* keys, at =
      let length = 32 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some (keys, at)

  let encode_open_font ~(fid : font) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 45;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_font buf fid;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let encode_close_font ~(font : font) buf =
    (* opcode *)
    encode_uint8 buf 46;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_font buf font;
    (* write request length *)
    encode_request_length buf

  type font_draw_enum = [ `Left_to_right | `Right_to_left ] [@@deriving sexp]

  let font_draw_enum_of_int : int -> [> font_draw_enum ] option = function
    | 0 -> Some `Left_to_right
    | 1 -> Some `Right_to_left
    | n ->
        Printf.printf "unknown font_draw_enum: %d\n" n;
        None

  let font_draw_int_of_enum : font_draw_enum -> int = function
    | `Left_to_right -> 0
    | `Right_to_left -> 1

  type fontprop = { name : atom; value : int } [@@deriving sexp]

  let decode_fontprop buf ~at : (fontprop * int) option =
    let orig = at in
    let* name, at = decode_atom buf ~at in
    let* value, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ name; value }, at)

  let encode_fontprop buf (v : fontprop) =
    encode_atom buf v.name;
    encode_int32 buf v.value;
    ()

  type charinfo = {
    left_side_bearing : int;
    right_side_bearing : int;
    character_width : int;
    ascent : int;
    descent : int;
    attributes : int;
  }
  [@@deriving sexp]

  let decode_charinfo buf ~at : (charinfo * int) option =
    let orig = at in
    let* left_side_bearing, at = decode_int16 buf ~at in
    let* right_side_bearing, at = decode_int16 buf ~at in
    let* character_width, at = decode_int16 buf ~at in
    let* ascent, at = decode_int16 buf ~at in
    let* descent, at = decode_int16 buf ~at in
    let* attributes, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          left_side_bearing;
          right_side_bearing;
          character_width;
          ascent;
          descent;
          attributes;
        },
        at )

  let encode_charinfo buf (v : charinfo) =
    encode_int16 buf v.left_side_bearing;
    encode_int16 buf v.right_side_bearing;
    encode_int16 buf v.character_width;
    encode_int16 buf v.ascent;
    encode_int16 buf v.descent;
    encode_uint16 buf v.attributes;
    ()

  type query_font_reply = {
    min_bounds : charinfo;
    max_bounds : charinfo;
    min_char_or_byte2 : int;
    max_char_or_byte2 : int;
    default_char : int;
    draw_direction : font_draw_enum;
    min_byte1 : int;
    max_byte1 : int;
    all_chars_exist : bool;
    font_ascent : int;
    font_descent : int;
    properties : fontprop list;
    char_infos : charinfo list;
  }
  [@@deriving sexp]

  let encode_query_font ~(font : fontable) buf =
    (* opcode *)
    encode_uint8 buf 47;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fontable buf font;
    (* write request length *)
    encode_request_length buf

  let decode_query_font_reply length buf ~at : (query_font_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* min_bounds, at = decode_charinfo buf ~at in
    let at = at + 4 in
    let* max_bounds, at = decode_charinfo buf ~at in
    let at = at + 4 in
    let* min_char_or_byte2, at = decode_uint16 buf ~at in
    let* max_char_or_byte2, at = decode_uint16 buf ~at in
    let* default_char, at = decode_uint16 buf ~at in
    let* properties_len, at = decode_uint16 buf ~at in
    let properties_len = properties_len in
    let* draw_direction, at =
      decode_enum decode_char Char.code font_draw_enum_of_int buf ~at
    in
    let* min_byte1, at = decode_uint8 buf ~at in
    let* max_byte1, at = decode_uint8 buf ~at in
    let* all_chars_exist, at = decode_bool buf ~at in
    let* font_ascent, at = decode_int16 buf ~at in
    let* font_descent, at = decode_int16 buf ~at in
    let* char_infos_len, at = decode_int32 buf ~at in
    let char_infos_len = char_infos_len in
    let* properties, at = decode_list decode_fontprop properties_len buf ~at in
    let* char_infos, at = decode_list decode_charinfo char_infos_len buf ~at in
    ignore orig;
    Some
      ( {
          min_bounds;
          max_bounds;
          min_char_or_byte2;
          max_char_or_byte2;
          default_char;
          draw_direction;
          min_byte1;
          max_byte1;
          all_chars_exist;
          font_ascent;
          font_descent;
          properties;
          char_infos;
        },
        at )

  type str = string [@@deriving sexp]

  let decode_str buf ~at : (str * int) option =
    let orig = at in
    let* name_len, at = decode_uint8 buf ~at in
    let name_len = name_len in
    let* name, at = decode_string name_len buf ~at in
    ignore orig;
    Some (name, at)

  let encode_str buf (v : str) =
    encode_string buf v;
    ()

  type list_fonts_reply = str list [@@deriving sexp]

  let encode_list_fonts ~(max_names : int) ~(pattern : string) buf =
    (* opcode *)
    encode_uint8 buf 49;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf max_names;
    encode_uint16 buf (identity (String.length pattern));
    encode_string buf pattern;
    (* write request length *)
    encode_request_length buf

  let decode_list_fonts_reply length buf ~at : (list_fonts_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* names_len, at = decode_uint16 buf ~at in
    let names_len = names_len in
    let at = at + 22 in
    let* names, at = decode_list decode_str names_len buf ~at in
    ignore orig;
    Some (names, at)

  type list_fonts_with_info_reply = {
    min_bounds : charinfo;
    max_bounds : charinfo;
    min_char_or_byte2 : int;
    max_char_or_byte2 : int;
    default_char : int;
    draw_direction : font_draw_enum;
    min_byte1 : int;
    max_byte1 : int;
    all_chars_exist : bool;
    font_ascent : int;
    font_descent : int;
    replies_hint : int;
    properties : fontprop list;
    name : string;
  }
  [@@deriving sexp]

  let encode_list_fonts_with_info ~(max_names : int) ~(pattern : string) buf =
    (* opcode *)
    encode_uint8 buf 50;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf max_names;
    encode_uint16 buf (identity (String.length pattern));
    encode_string buf pattern;
    (* write request length *)
    encode_request_length buf

  let decode_list_fonts_with_info_reply length buf ~at :
      (list_fonts_with_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* name_len, at = decode_uint8 buf ~at in
    let name_len = name_len in
    let at = at + 6 in
    let* min_bounds, at = decode_charinfo buf ~at in
    let at = at + 4 in
    let* max_bounds, at = decode_charinfo buf ~at in
    let at = at + 4 in
    let* min_char_or_byte2, at = decode_uint16 buf ~at in
    let* max_char_or_byte2, at = decode_uint16 buf ~at in
    let* default_char, at = decode_uint16 buf ~at in
    let* properties_len, at = decode_uint16 buf ~at in
    let properties_len = properties_len in
    let* draw_direction, at =
      decode_enum decode_char Char.code font_draw_enum_of_int buf ~at
    in
    let* min_byte1, at = decode_uint8 buf ~at in
    let* max_byte1, at = decode_uint8 buf ~at in
    let* all_chars_exist, at = decode_bool buf ~at in
    let* font_ascent, at = decode_int16 buf ~at in
    let* font_descent, at = decode_int16 buf ~at in
    let* replies_hint, at = decode_int32 buf ~at in
    let* properties, at = decode_list decode_fontprop properties_len buf ~at in
    let* name, at = decode_string name_len buf ~at in
    ignore orig;
    Some
      ( {
          min_bounds;
          max_bounds;
          min_char_or_byte2;
          max_char_or_byte2;
          default_char;
          draw_direction;
          min_byte1;
          max_byte1;
          all_chars_exist;
          font_ascent;
          font_descent;
          replies_hint;
          properties;
          name;
        },
        at )

  let encode_set_font_path ~(font : str list) buf =
    (* opcode *)
    encode_uint8 buf 51;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity ((* invalid_argument *) List.length font));
    encode_pad buf 2;
    encode_list encode_str buf font;
    (* write request length *)
    encode_request_length buf

  type get_font_path_reply = str list [@@deriving sexp]

  let encode_get_font_path buf =
    (* opcode *)
    encode_uint8 buf 52;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_font_path_reply length buf ~at :
      (get_font_path_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* path_len, at = decode_uint16 buf ~at in
    let path_len = path_len in
    let at = at + 22 in
    let* path, at = decode_list decode_str path_len buf ~at in
    ignore orig;
    Some (path, at)

  let encode_create_pixmap ~(depth : int) ~(pid : pixmap) ~(drawable : drawable)
      ~(width : int) ~(height : int) buf =
    (* opcode *)
    encode_uint8 buf 53;
    encode_uint8 buf depth;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pixmap buf pid;
    encode_drawable buf drawable;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let encode_free_pixmap ~(pixmap : pixmap) buf =
    (* opcode *)
    encode_uint8 buf 54;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pixmap buf pixmap;
    (* write request length *)
    encode_request_length buf

  type gc_mask =
    [ `Function
    | `Plane_mask
    | `Foreground
    | `Background
    | `Line_width
    | `Line_style
    | `Cap_style
    | `Join_style
    | `Fill_style
    | `Fill_rule
    | `Tile
    | `Stipple
    | `Tile_stipple_origin_x
    | `Tile_stipple_origin_y
    | `Font
    | `Subwindow_mode
    | `Graphics_exposures
    | `Clip_origin_x
    | `Clip_origin_y
    | `Clip_mask
    | `Dash_offset
    | `Dash_list
    | `Arc_mode ]
    list
  [@@deriving sexp]

  let gc_mask_of_int64 mask : gc_mask option =
    let of_int = function
      | 0 -> Some `Function
      | 1 -> Some `Plane_mask
      | 2 -> Some `Foreground
      | 3 -> Some `Background
      | 4 -> Some `Line_width
      | 5 -> Some `Line_style
      | 6 -> Some `Cap_style
      | 7 -> Some `Join_style
      | 8 -> Some `Fill_style
      | 9 -> Some `Fill_rule
      | 10 -> Some `Tile
      | 11 -> Some `Stipple
      | 12 -> Some `Tile_stipple_origin_x
      | 13 -> Some `Tile_stipple_origin_y
      | 14 -> Some `Font
      | 15 -> Some `Subwindow_mode
      | 16 -> Some `Graphics_exposures
      | 17 -> Some `Clip_origin_x
      | 18 -> Some `Clip_origin_y
      | 19 -> Some `Clip_mask
      | 20 -> Some `Dash_offset
      | 21 -> Some `Dash_list
      | 22 -> Some `Arc_mode
      | _ -> None
    in
    mask_of_int of_int mask

  let gc_int_of_mask : gc_mask -> int =
    let to_bit = function
      | `Function -> 0
      | `Plane_mask -> 1
      | `Foreground -> 2
      | `Background -> 3
      | `Line_width -> 4
      | `Line_style -> 5
      | `Cap_style -> 6
      | `Join_style -> 7
      | `Fill_style -> 8
      | `Fill_rule -> 9
      | `Tile -> 10
      | `Stipple -> 11
      | `Tile_stipple_origin_x -> 12
      | `Tile_stipple_origin_y -> 13
      | `Font -> 14
      | `Subwindow_mode -> 15
      | `Graphics_exposures -> 16
      | `Clip_origin_x -> 17
      | `Clip_origin_y -> 18
      | `Clip_mask -> 19
      | `Dash_offset -> 20
      | `Dash_list -> 21
      | `Arc_mode -> 22
    in
    int_of_mask to_bit

  type gx_enum =
    [ `Clear
    | `And
    | `And_reverse
    | `Copy
    | `And_inverted
    | `Noop
    | `Xor
    | `Or
    | `Nor
    | `Equiv
    | `Invert
    | `Or_reverse
    | `Copy_inverted
    | `Or_inverted
    | `Nand
    | `Set ]
  [@@deriving sexp]

  let gx_enum_of_int : int -> [> gx_enum ] option = function
    | 0 -> Some `Clear
    | 1 -> Some `And
    | 2 -> Some `And_reverse
    | 3 -> Some `Copy
    | 4 -> Some `And_inverted
    | 5 -> Some `Noop
    | 6 -> Some `Xor
    | 7 -> Some `Or
    | 8 -> Some `Nor
    | 9 -> Some `Equiv
    | 10 -> Some `Invert
    | 11 -> Some `Or_reverse
    | 12 -> Some `Copy_inverted
    | 13 -> Some `Or_inverted
    | 14 -> Some `Nand
    | 15 -> Some `Set
    | n ->
        Printf.printf "unknown gx_enum: %d\n" n;
        None

  let gx_int_of_enum : gx_enum -> int = function
    | `Clear -> 0
    | `And -> 1
    | `And_reverse -> 2
    | `Copy -> 3
    | `And_inverted -> 4
    | `Noop -> 5
    | `Xor -> 6
    | `Or -> 7
    | `Nor -> 8
    | `Equiv -> 9
    | `Invert -> 10
    | `Or_reverse -> 11
    | `Copy_inverted -> 12
    | `Or_inverted -> 13
    | `Nand -> 14
    | `Set -> 15

  type line_style_enum = [ `Solid | `On_off_dash | `Double_dash ]
  [@@deriving sexp]

  let line_style_enum_of_int : int -> [> line_style_enum ] option = function
    | 0 -> Some `Solid
    | 1 -> Some `On_off_dash
    | 2 -> Some `Double_dash
    | n ->
        Printf.printf "unknown line_style_enum: %d\n" n;
        None

  let line_style_int_of_enum : line_style_enum -> int = function
    | `Solid -> 0
    | `On_off_dash -> 1
    | `Double_dash -> 2

  type cap_style_enum = [ `Not_last | `Butt | `Round | `Projecting ]
  [@@deriving sexp]

  let cap_style_enum_of_int : int -> [> cap_style_enum ] option = function
    | 0 -> Some `Not_last
    | 1 -> Some `Butt
    | 2 -> Some `Round
    | 3 -> Some `Projecting
    | n ->
        Printf.printf "unknown cap_style_enum: %d\n" n;
        None

  let cap_style_int_of_enum : cap_style_enum -> int = function
    | `Not_last -> 0
    | `Butt -> 1
    | `Round -> 2
    | `Projecting -> 3

  type join_style_enum = [ `Miter | `Round | `Bevel ] [@@deriving sexp]

  let join_style_enum_of_int : int -> [> join_style_enum ] option = function
    | 0 -> Some `Miter
    | 1 -> Some `Round
    | 2 -> Some `Bevel
    | n ->
        Printf.printf "unknown join_style_enum: %d\n" n;
        None

  let join_style_int_of_enum : join_style_enum -> int = function
    | `Miter -> 0
    | `Round -> 1
    | `Bevel -> 2

  type fill_style_enum = [ `Solid | `Tiled | `Stippled | `Opaque_stippled ]
  [@@deriving sexp]

  let fill_style_enum_of_int : int -> [> fill_style_enum ] option = function
    | 0 -> Some `Solid
    | 1 -> Some `Tiled
    | 2 -> Some `Stippled
    | 3 -> Some `Opaque_stippled
    | n ->
        Printf.printf "unknown fill_style_enum: %d\n" n;
        None

  let fill_style_int_of_enum : fill_style_enum -> int = function
    | `Solid -> 0
    | `Tiled -> 1
    | `Stippled -> 2
    | `Opaque_stippled -> 3

  type fill_rule_enum = [ `Even_odd | `Winding ] [@@deriving sexp]

  let fill_rule_enum_of_int : int -> [> fill_rule_enum ] option = function
    | 0 -> Some `Even_odd
    | 1 -> Some `Winding
    | n ->
        Printf.printf "unknown fill_rule_enum: %d\n" n;
        None

  let fill_rule_int_of_enum : fill_rule_enum -> int = function
    | `Even_odd -> 0
    | `Winding -> 1

  type subwindow_mode_enum = [ `Clip_by_children | `Include_inferiors ]
  [@@deriving sexp]

  let subwindow_mode_enum_of_int : int -> [> subwindow_mode_enum ] option =
    function
    | 0 -> Some `Clip_by_children
    | 1 -> Some `Include_inferiors
    | n ->
        Printf.printf "unknown subwindow_mode_enum: %d\n" n;
        None

  let subwindow_mode_int_of_enum : subwindow_mode_enum -> int = function
    | `Clip_by_children -> 0
    | `Include_inferiors -> 1

  type arc_mode_enum = [ `Chord | `Pie_slice ] [@@deriving sexp]

  let arc_mode_enum_of_int : int -> [> arc_mode_enum ] option = function
    | 0 -> Some `Chord
    | 1 -> Some `Pie_slice
    | n ->
        Printf.printf "unknown arc_mode_enum: %d\n" n;
        None

  let arc_mode_int_of_enum : arc_mode_enum -> int = function
    | `Chord -> 0
    | `Pie_slice -> 1

  type font_enum = [ `None ] [@@deriving sexp]

  let font_enum_of_int : int -> [> font_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown font_enum: %d\n" n;
        None

  let font_int_of_enum : font_enum -> int = function `None -> 0

  let encode_create_gc ~(cid : gcontext) ~(drawable : drawable)
      ?(function_ : gx_enum option) ?(plane_mask : int option)
      ?(foreground : int option) ?(background : int option)
      ?(line_width : int option) ?(line_style : line_style_enum option)
      ?(cap_style : cap_style_enum option)
      ?(join_style : join_style_enum option)
      ?(fill_style : fill_style_enum option)
      ?(fill_rule : fill_rule_enum option) ?(tile : pixmap_enum alt_enum option)
      ?(stipple : pixmap_enum alt_enum option)
      ?(tile_stipple_x_origin : int option)
      ?(tile_stipple_y_origin : int option) ?(font : font_enum alt_enum option)
      ?(subwindow_mode : subwindow_mode_enum option)
      ?(graphics_exposures : bool32 option) ?(clip_x_origin : int option)
      ?(clip_y_origin : int option) ?(clip_mask : pixmap_enum alt_enum option)
      ?(dash_offset : int option) ?(dashes : int option)
      ?(arc_mode : arc_mode_enum option) buf =
    (* opcode *)
    encode_uint8 buf 55;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_gcontext buf cid;
    encode_drawable buf drawable;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some function_, 0);
        (Option.is_some plane_mask, 1);
        (Option.is_some foreground, 2);
        (Option.is_some background, 3);
        (Option.is_some line_width, 4);
        (Option.is_some line_style, 5);
        (Option.is_some cap_style, 6);
        (Option.is_some join_style, 7);
        (Option.is_some fill_style, 8);
        (Option.is_some fill_rule, 9);
        (Option.is_some tile, 10);
        (Option.is_some stipple, 11);
        (Option.is_some tile_stipple_x_origin, 12);
        (Option.is_some tile_stipple_y_origin, 13);
        (Option.is_some font, 14);
        (Option.is_some subwindow_mode, 15);
        (Option.is_some graphics_exposures, 16);
        (Option.is_some clip_x_origin, 17);
        (Option.is_some clip_y_origin, 18);
        (Option.is_some clip_mask, 19);
        (Option.is_some dash_offset, 20);
        (Option.is_some dashes, 21);
        (Option.is_some arc_mode, 22);
      ];
    (match function_ with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity gx_int_of_enum buf v);
    (match plane_mask with None -> () | Some v -> encode_int32 buf v);
    (match foreground with None -> () | Some v -> encode_int32 buf v);
    (match background with None -> () | Some v -> encode_int32 buf v);
    (match line_width with None -> () | Some v -> encode_int32 buf v);
    (match line_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity line_style_int_of_enum buf v);
    (match cap_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity cap_style_int_of_enum buf v);
    (match join_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity join_style_int_of_enum buf v);
    (match fill_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity fill_style_int_of_enum buf v);
    (match fill_rule with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity fill_rule_int_of_enum buf v);
    (match tile with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match stipple with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match tile_stipple_x_origin with
    | None -> ()
    | Some v -> encode_int32 buf v);
    (match tile_stipple_y_origin with
    | None -> ()
    | Some v -> encode_int32 buf v);
    (match font with
    | None -> ()
    | Some v -> encode_alt_enum encode_font identity font_int_of_enum buf v);
    (match subwindow_mode with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity subwindow_mode_int_of_enum buf v);
    (match graphics_exposures with None -> () | Some v -> encode_bool32 buf v);
    (match clip_x_origin with None -> () | Some v -> encode_int32 buf v);
    (match clip_y_origin with None -> () | Some v -> encode_int32 buf v);
    (match clip_mask with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match dash_offset with None -> () | Some v -> encode_int32 buf v);
    (match dashes with None -> () | Some v -> encode_int32 buf v);
    (match arc_mode with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity arc_mode_int_of_enum buf v);
    (* write request length *)
    encode_request_length buf

  let encode_change_gc ~(gc : gcontext) ?(function_ : gx_enum option)
      ?(plane_mask : int option) ?(foreground : int option)
      ?(background : int option) ?(line_width : int option)
      ?(line_style : line_style_enum option)
      ?(cap_style : cap_style_enum option)
      ?(join_style : join_style_enum option)
      ?(fill_style : fill_style_enum option)
      ?(fill_rule : fill_rule_enum option) ?(tile : pixmap_enum alt_enum option)
      ?(stipple : pixmap_enum alt_enum option)
      ?(tile_stipple_x_origin : int option)
      ?(tile_stipple_y_origin : int option) ?(font : font_enum alt_enum option)
      ?(subwindow_mode : subwindow_mode_enum option)
      ?(graphics_exposures : bool32 option) ?(clip_x_origin : int option)
      ?(clip_y_origin : int option) ?(clip_mask : pixmap_enum alt_enum option)
      ?(dash_offset : int option) ?(dashes : int option)
      ?(arc_mode : arc_mode_enum option) buf =
    (* opcode *)
    encode_uint8 buf 56;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_gcontext buf gc;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some function_, 0);
        (Option.is_some plane_mask, 1);
        (Option.is_some foreground, 2);
        (Option.is_some background, 3);
        (Option.is_some line_width, 4);
        (Option.is_some line_style, 5);
        (Option.is_some cap_style, 6);
        (Option.is_some join_style, 7);
        (Option.is_some fill_style, 8);
        (Option.is_some fill_rule, 9);
        (Option.is_some tile, 10);
        (Option.is_some stipple, 11);
        (Option.is_some tile_stipple_x_origin, 12);
        (Option.is_some tile_stipple_y_origin, 13);
        (Option.is_some font, 14);
        (Option.is_some subwindow_mode, 15);
        (Option.is_some graphics_exposures, 16);
        (Option.is_some clip_x_origin, 17);
        (Option.is_some clip_y_origin, 18);
        (Option.is_some clip_mask, 19);
        (Option.is_some dash_offset, 20);
        (Option.is_some dashes, 21);
        (Option.is_some arc_mode, 22);
      ];
    (match function_ with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity gx_int_of_enum buf v);
    (match plane_mask with None -> () | Some v -> encode_int32 buf v);
    (match foreground with None -> () | Some v -> encode_int32 buf v);
    (match background with None -> () | Some v -> encode_int32 buf v);
    (match line_width with None -> () | Some v -> encode_int32 buf v);
    (match line_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity line_style_int_of_enum buf v);
    (match cap_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity cap_style_int_of_enum buf v);
    (match join_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity join_style_int_of_enum buf v);
    (match fill_style with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity fill_style_int_of_enum buf v);
    (match fill_rule with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity fill_rule_int_of_enum buf v);
    (match tile with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match stipple with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match tile_stipple_x_origin with
    | None -> ()
    | Some v -> encode_int32 buf v);
    (match tile_stipple_y_origin with
    | None -> ()
    | Some v -> encode_int32 buf v);
    (match font with
    | None -> ()
    | Some v -> encode_alt_enum encode_font identity font_int_of_enum buf v);
    (match subwindow_mode with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity subwindow_mode_int_of_enum buf v);
    (match graphics_exposures with None -> () | Some v -> encode_bool32 buf v);
    (match clip_x_origin with None -> () | Some v -> encode_int32 buf v);
    (match clip_y_origin with None -> () | Some v -> encode_int32 buf v);
    (match clip_mask with
    | None -> ()
    | Some v -> encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf v);
    (match dash_offset with None -> () | Some v -> encode_int32 buf v);
    (match dashes with None -> () | Some v -> encode_int32 buf v);
    (match arc_mode with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity arc_mode_int_of_enum buf v);
    (* write request length *)
    encode_request_length buf

  let encode_copy_gc ~(src_gc : gcontext) ~(dst_gc : gcontext)
      ~(value_mask : gc_mask) buf =
    (* opcode *)
    encode_uint8 buf 57;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_gcontext buf src_gc;
    encode_gcontext buf dst_gc;
    encode_mask encode_int32 identity gc_int_of_mask buf value_mask;
    (* write request length *)
    encode_request_length buf

  let encode_set_dashes ~(gc : gcontext) ~(dash_offset : int)
      ~(dashes : int list) buf =
    (* opcode *)
    encode_uint8 buf 58;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_gcontext buf gc;
    encode_uint16 buf dash_offset;
    encode_uint16 buf (identity ((* Parsetree.Card8 *) List.length dashes));
    encode_list encode_uint8 buf dashes;
    (* write request length *)
    encode_request_length buf

  type clip_ordering_enum = [ `Unsorted | `Y_sorted | `Yx_sorted | `Yx_banded ]
  [@@deriving sexp]

  let clip_ordering_enum_of_int : int -> [> clip_ordering_enum ] option =
    function
    | 0 -> Some `Unsorted
    | 1 -> Some `Y_sorted
    | 2 -> Some `Yx_sorted
    | 3 -> Some `Yx_banded
    | n ->
        Printf.printf "unknown clip_ordering_enum: %d\n" n;
        None

  let clip_ordering_int_of_enum : clip_ordering_enum -> int = function
    | `Unsorted -> 0
    | `Y_sorted -> 1
    | `Yx_sorted -> 2
    | `Yx_banded -> 3

  let encode_set_clip_rectangles ~(ordering : clip_ordering_enum)
      ~(gc : gcontext) ~(clip_x_origin : int) ~(clip_y_origin : int)
      ~(rectangles : rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 59;
    encode_enum encode_char Char.chr clip_ordering_int_of_enum buf ordering;
    (* reserve request length *)
    encode_pad buf 2;
    encode_gcontext buf gc;
    encode_int16 buf clip_x_origin;
    encode_int16 buf clip_y_origin;
    encode_list encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_free_gc ~(gc : gcontext) buf =
    (* opcode *)
    encode_uint8 buf 60;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_gcontext buf gc;
    (* write request length *)
    encode_request_length buf

  let encode_clear_area ~(exposures : bool) ~(window : window) ~(x : int)
      ~(y : int) ~(width : int) ~(height : int) buf =
    (* opcode *)
    encode_uint8 buf 61;
    encode_bool buf exposures;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let encode_copy_area ~(src_drawable : drawable) ~(dst_drawable : drawable)
      ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int)
      ~(dst_y : int) ~(width : int) ~(height : int) buf =
    (* opcode *)
    encode_uint8 buf 62;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf src_drawable;
    encode_drawable buf dst_drawable;
    encode_gcontext buf gc;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_int16 buf dst_x;
    encode_int16 buf dst_y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let encode_copy_plane ~(src_drawable : drawable) ~(dst_drawable : drawable)
      ~(gc : gcontext) ~(src_x : int) ~(src_y : int) ~(dst_x : int)
      ~(dst_y : int) ~(width : int) ~(height : int) ~(bit_plane : int) buf =
    (* opcode *)
    encode_uint8 buf 63;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf src_drawable;
    encode_drawable buf dst_drawable;
    encode_gcontext buf gc;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_int16 buf dst_x;
    encode_int16 buf dst_y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int32 buf bit_plane;
    (* write request length *)
    encode_request_length buf

  type coord_mode_enum = [ `Origin | `Previous ] [@@deriving sexp]

  let coord_mode_enum_of_int : int -> [> coord_mode_enum ] option = function
    | 0 -> Some `Origin
    | 1 -> Some `Previous
    | n ->
        Printf.printf "unknown coord_mode_enum: %d\n" n;
        None

  let coord_mode_int_of_enum : coord_mode_enum -> int = function
    | `Origin -> 0
    | `Previous -> 1

  let encode_poly_point ~(coordinate_mode : coord_mode_enum)
      ~(drawable : drawable) ~(gc : gcontext) ~(points : point list) buf =
    (* opcode *)
    encode_uint8 buf 64;
    encode_enum encode_char Char.chr coord_mode_int_of_enum buf coordinate_mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_point buf points;
    (* write request length *)
    encode_request_length buf

  let encode_poly_line ~(coordinate_mode : coord_mode_enum)
      ~(drawable : drawable) ~(gc : gcontext) ~(points : point list) buf =
    (* opcode *)
    encode_uint8 buf 65;
    encode_enum encode_char Char.chr coord_mode_int_of_enum buf coordinate_mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_point buf points;
    (* write request length *)
    encode_request_length buf

  type segment = { x1 : int; y1 : int; x2 : int; y2 : int } [@@deriving sexp]

  let decode_segment buf ~at : (segment * int) option =
    let orig = at in
    let* x1, at = decode_int16 buf ~at in
    let* y1, at = decode_int16 buf ~at in
    let* x2, at = decode_int16 buf ~at in
    let* y2, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ x1; y1; x2; y2 }, at)

  let encode_segment buf (v : segment) =
    encode_int16 buf v.x1;
    encode_int16 buf v.y1;
    encode_int16 buf v.x2;
    encode_int16 buf v.y2;
    ()

  let encode_poly_segment ~(drawable : drawable) ~(gc : gcontext)
      ~(segments : segment list) buf =
    (* opcode *)
    encode_uint8 buf 66;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_segment buf segments;
    (* write request length *)
    encode_request_length buf

  let encode_poly_rectangle ~(drawable : drawable) ~(gc : gcontext)
      ~(rectangles : rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 67;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_poly_arc ~(drawable : drawable) ~(gc : gcontext) ~(arcs : arc list)
      buf =
    (* opcode *)
    encode_uint8 buf 68;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_arc buf arcs;
    (* write request length *)
    encode_request_length buf

  type poly_shape_enum = [ `Complex | `Nonconvex | `Convex ] [@@deriving sexp]

  let poly_shape_enum_of_int : int -> [> poly_shape_enum ] option = function
    | 0 -> Some `Complex
    | 1 -> Some `Nonconvex
    | 2 -> Some `Convex
    | n ->
        Printf.printf "unknown poly_shape_enum: %d\n" n;
        None

  let poly_shape_int_of_enum : poly_shape_enum -> int = function
    | `Complex -> 0
    | `Nonconvex -> 1
    | `Convex -> 2

  let encode_fill_poly ~(drawable : drawable) ~(gc : gcontext)
      ~(shape : poly_shape_enum) ~(coordinate_mode : coord_mode_enum)
      ~(points : point list) buf =
    (* opcode *)
    encode_uint8 buf 69;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_enum encode_uint8 identity poly_shape_int_of_enum buf shape;
    encode_enum encode_uint8 identity coord_mode_int_of_enum buf coordinate_mode;
    encode_pad buf 2;
    encode_list encode_point buf points;
    (* write request length *)
    encode_request_length buf

  let encode_poly_fill_rectangle ~(drawable : drawable) ~(gc : gcontext)
      ~(rectangles : rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 70;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_poly_fill_arc ~(drawable : drawable) ~(gc : gcontext)
      ~(arcs : arc list) buf =
    (* opcode *)
    encode_uint8 buf 71;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_list encode_arc buf arcs;
    (* write request length *)
    encode_request_length buf

  type image_format_enum = [ `Xy_bitmap | `Xy_pixmap | `Z_pixmap ]
  [@@deriving sexp]

  let image_format_enum_of_int : int -> [> image_format_enum ] option = function
    | 0 -> Some `Xy_bitmap
    | 1 -> Some `Xy_pixmap
    | 2 -> Some `Z_pixmap
    | n ->
        Printf.printf "unknown image_format_enum: %d\n" n;
        None

  let image_format_int_of_enum : image_format_enum -> int = function
    | `Xy_bitmap -> 0
    | `Xy_pixmap -> 1
    | `Z_pixmap -> 2

  let encode_put_image ~(format : image_format_enum) ~(drawable : drawable)
      ~(gc : gcontext) ~(width : int) ~(height : int) ~(dst_x : int)
      ~(dst_y : int) ~(left_pad : int) ~(depth : int) ~(data : char list) buf =
    (* opcode *)
    encode_uint8 buf 72;
    encode_enum encode_uint8 identity image_format_int_of_enum buf format;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int16 buf dst_x;
    encode_int16 buf dst_y;
    encode_uint8 buf left_pad;
    encode_uint8 buf depth;
    encode_pad buf 2;
    encode_list encode_char buf data;
    (* write request length *)
    encode_request_length buf

  type get_image_reply = { depth : int; visual : visualid; data : char list }
  [@@deriving sexp]

  let encode_get_image ~(format : image_format_enum) ~(drawable : drawable)
      ~(x : int) ~(y : int) ~(width : int) ~(height : int) ~(plane_mask : int)
      buf =
    (* opcode *)
    encode_uint8 buf 73;
    encode_enum encode_uint8 identity image_format_int_of_enum buf format;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int32 buf plane_mask;
    (* write request length *)
    encode_request_length buf

  let decode_get_image_reply length buf ~at : (get_image_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* visual, at = decode_visualid buf ~at in
    let at = at + 20 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ depth; visual; data }, at)

  let encode_poly_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int)
      ~(y : int) ~(items : char list) buf =
    (* opcode *)
    encode_uint8 buf 74;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_list encode_char buf items;
    (* write request length *)
    encode_request_length buf

  let encode_poly_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int)
      ~(y : int) ~(items : char list) buf =
    (* opcode *)
    encode_uint8 buf 75;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_list encode_char buf items;
    (* write request length *)
    encode_request_length buf

  let encode_image_text8 ~(drawable : drawable) ~(gc : gcontext) ~(x : int)
      ~(y : int) ~(string : string) buf =
    (* opcode *)
    encode_uint8 buf 76;
    encode_char buf (Char.chr (String.length string));
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_string buf string;
    (* write request length *)
    encode_request_length buf

  let encode_image_text16 ~(drawable : drawable) ~(gc : gcontext) ~(x : int)
      ~(y : int) ~(string : char2b list) buf =
    (* opcode *)
    encode_uint8 buf 77;
    encode_char buf (Char.chr ((* invalid_argument *) List.length string));
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_gcontext buf gc;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_list encode_char2b buf string;
    (* write request length *)
    encode_request_length buf

  type colormap_alloc_enum = [ `None | `All ] [@@deriving sexp]

  let colormap_alloc_enum_of_int : int -> [> colormap_alloc_enum ] option =
    function
    | 0 -> Some `None
    | 1 -> Some `All
    | n ->
        Printf.printf "unknown colormap_alloc_enum: %d\n" n;
        None

  let colormap_alloc_int_of_enum : colormap_alloc_enum -> int = function
    | `None -> 0
    | `All -> 1

  let encode_create_colormap ~(alloc : colormap_alloc_enum) ~(mid : colormap)
      ~(window : window) ~(visual : visualid) buf =
    (* opcode *)
    encode_uint8 buf 78;
    encode_enum encode_char Char.chr colormap_alloc_int_of_enum buf alloc;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf mid;
    encode_window buf window;
    encode_visualid buf visual;
    (* write request length *)
    encode_request_length buf

  let encode_free_colormap ~(cmap : colormap) buf =
    (* opcode *)
    encode_uint8 buf 79;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    (* write request length *)
    encode_request_length buf

  let encode_copy_colormap_and_free ~(mid : colormap) ~(src_cmap : colormap) buf
      =
    (* opcode *)
    encode_uint8 buf 80;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf mid;
    encode_colormap buf src_cmap;
    (* write request length *)
    encode_request_length buf

  let encode_install_colormap ~(cmap : colormap) buf =
    (* opcode *)
    encode_uint8 buf 81;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    (* write request length *)
    encode_request_length buf

  let encode_uninstall_colormap ~(cmap : colormap) buf =
    (* opcode *)
    encode_uint8 buf 82;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    (* write request length *)
    encode_request_length buf

  type list_installed_colormaps_reply = colormap list [@@deriving sexp]

  let encode_list_installed_colormaps ~(window : window) buf =
    (* opcode *)
    encode_uint8 buf 83;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let decode_list_installed_colormaps_reply length buf ~at :
      (list_installed_colormaps_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* cmaps_len, at = decode_uint16 buf ~at in
    let cmaps_len = cmaps_len in
    let at = at + 22 in
    let* cmaps, at = decode_list decode_colormap cmaps_len buf ~at in
    ignore orig;
    Some (cmaps, at)

  type alloc_color_reply = { red : int; green : int; blue : int; pixel : int }
  [@@deriving sexp]

  let encode_alloc_color ~(cmap : colormap) ~(red : int) ~(green : int)
      ~(blue : int) buf =
    (* opcode *)
    encode_uint8 buf 84;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_uint16 buf red;
    encode_uint16 buf green;
    encode_uint16 buf blue;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_alloc_color_reply length buf ~at : (alloc_color_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* red, at = decode_uint16 buf ~at in
    let* green, at = decode_uint16 buf ~at in
    let* blue, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* pixel, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ red; green; blue; pixel }, at)

  type alloc_named_color_reply = {
    pixel : int;
    exact_red : int;
    exact_green : int;
    exact_blue : int;
    visual_red : int;
    visual_green : int;
    visual_blue : int;
  }
  [@@deriving sexp]

  let encode_alloc_named_color ~(cmap : colormap) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 85;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_alloc_named_color_reply length buf ~at :
      (alloc_named_color_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* pixel, at = decode_int32 buf ~at in
    let* exact_red, at = decode_uint16 buf ~at in
    let* exact_green, at = decode_uint16 buf ~at in
    let* exact_blue, at = decode_uint16 buf ~at in
    let* visual_red, at = decode_uint16 buf ~at in
    let* visual_green, at = decode_uint16 buf ~at in
    let* visual_blue, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          pixel;
          exact_red;
          exact_green;
          exact_blue;
          visual_red;
          visual_green;
          visual_blue;
        },
        at )

  type alloc_color_cells_reply = { pixels : int list; masks : int list }
  [@@deriving sexp]

  let encode_alloc_color_cells ~(contiguous : bool) ~(cmap : colormap)
      ~(colors : int) ~(planes : int) buf =
    (* opcode *)
    encode_uint8 buf 86;
    encode_bool buf contiguous;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_uint16 buf colors;
    encode_uint16 buf planes;
    (* write request length *)
    encode_request_length buf

  let decode_alloc_color_cells_reply length buf ~at :
      (alloc_color_cells_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* pixels_len, at = decode_uint16 buf ~at in
    let pixels_len = pixels_len in
    let* masks_len, at = decode_uint16 buf ~at in
    let masks_len = masks_len in
    let at = at + 20 in
    let* pixels, at = decode_list decode_int32 pixels_len buf ~at in
    let* masks, at = decode_list decode_int32 masks_len buf ~at in
    ignore orig;
    Some ({ pixels; masks }, at)

  type alloc_color_planes_reply = {
    red_mask : int;
    green_mask : int;
    blue_mask : int;
    pixels : int list;
  }
  [@@deriving sexp]

  let encode_alloc_color_planes ~(contiguous : bool) ~(cmap : colormap)
      ~(colors : int) ~(reds : int) ~(greens : int) ~(blues : int) buf =
    (* opcode *)
    encode_uint8 buf 87;
    encode_bool buf contiguous;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_uint16 buf colors;
    encode_uint16 buf reds;
    encode_uint16 buf greens;
    encode_uint16 buf blues;
    (* write request length *)
    encode_request_length buf

  let decode_alloc_color_planes_reply length buf ~at :
      (alloc_color_planes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* pixels_len, at = decode_uint16 buf ~at in
    let pixels_len = pixels_len in
    let at = at + 2 in
    let* red_mask, at = decode_int32 buf ~at in
    let* green_mask, at = decode_int32 buf ~at in
    let* blue_mask, at = decode_int32 buf ~at in
    let at = at + 8 in
    let* pixels, at = decode_list decode_int32 pixels_len buf ~at in
    ignore orig;
    Some ({ red_mask; green_mask; blue_mask; pixels }, at)

  let encode_free_colors ~(cmap : colormap) ~(plane_mask : int)
      ~(pixels : int list) buf =
    (* opcode *)
    encode_uint8 buf 88;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_int32 buf plane_mask;
    encode_list encode_int32 buf pixels;
    (* write request length *)
    encode_request_length buf

  type color_flag_mask = [ `Red | `Green | `Blue ] list [@@deriving sexp]

  let color_flag_mask_of_int64 mask : color_flag_mask option =
    let of_int = function
      | 0 -> Some `Red
      | 1 -> Some `Green
      | 2 -> Some `Blue
      | _ -> None
    in
    mask_of_int of_int mask

  let color_flag_int_of_mask : color_flag_mask -> int =
    let to_bit = function `Red -> 0 | `Green -> 1 | `Blue -> 2 in
    int_of_mask to_bit

  type coloritem = {
    pixel : int;
    red : int;
    green : int;
    blue : int;
    flags : color_flag_mask;
  }
  [@@deriving sexp]

  let decode_coloritem buf ~at : (coloritem * int) option =
    let orig = at in
    let* pixel, at = decode_int32 buf ~at in
    let* red, at = decode_uint16 buf ~at in
    let* green, at = decode_uint16 buf ~at in
    let* blue, at = decode_uint16 buf ~at in
    let* flags, at =
      decode_mask decode_char char_to_int64 color_flag_mask_of_int64 buf ~at
    in
    let at = at + 1 in
    ignore orig;
    Some ({ pixel; red; green; blue; flags }, at)

  let encode_coloritem buf (v : coloritem) =
    encode_int32 buf v.pixel;
    encode_uint16 buf v.red;
    encode_uint16 buf v.green;
    encode_uint16 buf v.blue;
    encode_mask encode_char Char.chr color_flag_int_of_mask buf v.flags;
    encode_pad buf 1;
    ()

  let encode_store_colors ~(cmap : colormap) ~(items : coloritem list) buf =
    (* opcode *)
    encode_uint8 buf 89;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_list encode_coloritem buf items;
    (* write request length *)
    encode_request_length buf

  let encode_store_named_color ~(flags : color_flag_mask) ~(cmap : colormap)
      ~(pixel : int) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 90;
    encode_mask encode_uint8 identity color_flag_int_of_mask buf flags;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_int32 buf pixel;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  type rgb = { red : int; green : int; blue : int } [@@deriving sexp]

  let decode_rgb buf ~at : (rgb * int) option =
    let orig = at in
    let* red, at = decode_uint16 buf ~at in
    let* green, at = decode_uint16 buf ~at in
    let* blue, at = decode_uint16 buf ~at in
    let at = at + 2 in
    ignore orig;
    Some ({ red; green; blue }, at)

  let encode_rgb buf (v : rgb) =
    encode_uint16 buf v.red;
    encode_uint16 buf v.green;
    encode_uint16 buf v.blue;
    encode_pad buf 2;
    ()

  type query_colors_reply = rgb list [@@deriving sexp]

  let encode_query_colors ~(cmap : colormap) ~(pixels : int list) buf =
    (* opcode *)
    encode_uint8 buf 91;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_list encode_int32 buf pixels;
    (* write request length *)
    encode_request_length buf

  let decode_query_colors_reply length buf ~at :
      (query_colors_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* colors_len, at = decode_uint16 buf ~at in
    let colors_len = colors_len in
    let at = at + 22 in
    let* colors, at = decode_list decode_rgb colors_len buf ~at in
    ignore orig;
    Some (colors, at)

  type lookup_color_reply = {
    exact_red : int;
    exact_green : int;
    exact_blue : int;
    visual_red : int;
    visual_green : int;
    visual_blue : int;
  }
  [@@deriving sexp]

  let encode_lookup_color ~(cmap : colormap) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 92;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_colormap buf cmap;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_lookup_color_reply length buf ~at :
      (lookup_color_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* exact_red, at = decode_uint16 buf ~at in
    let* exact_green, at = decode_uint16 buf ~at in
    let* exact_blue, at = decode_uint16 buf ~at in
    let* visual_red, at = decode_uint16 buf ~at in
    let* visual_green, at = decode_uint16 buf ~at in
    let* visual_blue, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          exact_red;
          exact_green;
          exact_blue;
          visual_red;
          visual_green;
          visual_blue;
        },
        at )

  let encode_create_cursor ~(cid : cursor) ~(source : pixmap)
      ~(mask : pixmap_enum alt_enum) ~(fore_red : int) ~(fore_green : int)
      ~(fore_blue : int) ~(back_red : int) ~(back_green : int)
      ~(back_blue : int) ~(x : int) ~(y : int) buf =
    (* opcode *)
    encode_uint8 buf 93;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_cursor buf cid;
    encode_pixmap buf source;
    encode_alt_enum encode_pixmap identity pixmap_int_of_enum buf mask;
    encode_uint16 buf fore_red;
    encode_uint16 buf fore_green;
    encode_uint16 buf fore_blue;
    encode_uint16 buf back_red;
    encode_uint16 buf back_green;
    encode_uint16 buf back_blue;
    encode_uint16 buf x;
    encode_uint16 buf y;
    (* write request length *)
    encode_request_length buf

  let encode_create_glyph_cursor ~(cid : cursor) ~(source_font : font)
      ~(mask_font : font_enum alt_enum) ~(source_char : int) ~(mask_char : int)
      ~(fore_red : int) ~(fore_green : int) ~(fore_blue : int) ~(back_red : int)
      ~(back_green : int) ~(back_blue : int) buf =
    (* opcode *)
    encode_uint8 buf 94;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_cursor buf cid;
    encode_font buf source_font;
    encode_alt_enum encode_font identity font_int_of_enum buf mask_font;
    encode_uint16 buf source_char;
    encode_uint16 buf mask_char;
    encode_uint16 buf fore_red;
    encode_uint16 buf fore_green;
    encode_uint16 buf fore_blue;
    encode_uint16 buf back_red;
    encode_uint16 buf back_green;
    encode_uint16 buf back_blue;
    (* write request length *)
    encode_request_length buf

  let encode_free_cursor ~(cursor : cursor) buf =
    (* opcode *)
    encode_uint8 buf 95;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_cursor buf cursor;
    (* write request length *)
    encode_request_length buf

  let encode_recolor_cursor ~(cursor : cursor) ~(fore_red : int)
      ~(fore_green : int) ~(fore_blue : int) ~(back_red : int)
      ~(back_green : int) ~(back_blue : int) buf =
    (* opcode *)
    encode_uint8 buf 96;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_cursor buf cursor;
    encode_uint16 buf fore_red;
    encode_uint16 buf fore_green;
    encode_uint16 buf fore_blue;
    encode_uint16 buf back_red;
    encode_uint16 buf back_green;
    encode_uint16 buf back_blue;
    (* write request length *)
    encode_request_length buf

  type query_shape_of_enum =
    [ `Largest_cursor | `Fastest_tile | `Fastest_stipple ]
  [@@deriving sexp]

  let query_shape_of_enum_of_int : int -> [> query_shape_of_enum ] option =
    function
    | 0 -> Some `Largest_cursor
    | 1 -> Some `Fastest_tile
    | 2 -> Some `Fastest_stipple
    | n ->
        Printf.printf "unknown query_shape_of_enum: %d\n" n;
        None

  let query_shape_of_int_of_enum : query_shape_of_enum -> int = function
    | `Largest_cursor -> 0
    | `Fastest_tile -> 1
    | `Fastest_stipple -> 2

  type query_best_size_reply = { width : int; height : int } [@@deriving sexp]

  let encode_query_best_size ~(class_ : query_shape_of_enum)
      ~(drawable : drawable) ~(width : int) ~(height : int) buf =
    (* opcode *)
    encode_uint8 buf 97;
    encode_enum encode_uint8 identity query_shape_of_int_of_enum buf class_;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let decode_query_best_size_reply length buf ~at :
      (query_best_size_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ width; height }, at)

  type query_extension_reply = {
    present : bool;
    major_opcode : int;
    first_event : int;
    first_error : int;
  }
  [@@deriving sexp]

  let encode_query_extension ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 98;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_query_extension_reply length buf ~at :
      (query_extension_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* present, at = decode_bool buf ~at in
    let* major_opcode, at = decode_uint8 buf ~at in
    let* first_event, at = decode_uint8 buf ~at in
    let* first_error, at = decode_uint8 buf ~at in
    ignore orig;
    Some ({ present; major_opcode; first_event; first_error }, at)

  type list_extensions_reply = str list [@@deriving sexp]

  let encode_list_extensions buf =
    (* opcode *)
    encode_uint8 buf 99;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_list_extensions_reply length buf ~at :
      (list_extensions_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* names_len, at = decode_uint8 buf ~at in
    let names_len = names_len in
    let at = at + 6 in
    let at = at + 24 in
    let* names, at = decode_list decode_str names_len buf ~at in
    ignore orig;
    Some (names, at)

  let encode_change_keyboard_mapping ~(keycode_count : int)
      ~(first_keycode : keycode) ~(keysyms_per_keycode : int)
      ~(keysyms : keysym list) buf =
    (* opcode *)
    encode_uint8 buf 100;
    encode_uint8 buf keycode_count;
    (* reserve request length *)
    encode_pad buf 2;
    encode_keycode buf first_keycode;
    encode_uint8 buf keysyms_per_keycode;
    encode_pad buf 2;
    encode_list encode_keysym buf keysyms;
    (* write request length *)
    encode_request_length buf

  type get_keyboard_mapping_reply = {
    keysyms_per_keycode : char;
    keysyms : keysym list;
  }
  [@@deriving sexp]

  let encode_get_keyboard_mapping ~(first_keycode : keycode) ~(count : int) buf
      =
    (* opcode *)
    encode_uint8 buf 101;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_keycode buf first_keycode;
    encode_uint8 buf count;
    (* write request length *)
    encode_request_length buf

  let decode_get_keyboard_mapping_reply length buf ~at :
      (get_keyboard_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* keysyms_per_keycode, at = decode_char buf ~at in
    let at = at + 6 in
    let at = at + 24 in
    let* keysyms, at =
      let length = length in
      decode_list decode_keysym length buf ~at
    in
    ignore orig;
    Some ({ keysyms_per_keycode; keysyms }, at)

  type kb_mask =
    [ `Key_click_percent
    | `Bell_percent
    | `Bell_pitch
    | `Bell_duration
    | `Led
    | `Led_mode
    | `Key
    | `Auto_repeat_mode ]
    list
  [@@deriving sexp]

  let kb_mask_of_int64 mask : kb_mask option =
    let of_int = function
      | 0 -> Some `Key_click_percent
      | 1 -> Some `Bell_percent
      | 2 -> Some `Bell_pitch
      | 3 -> Some `Bell_duration
      | 4 -> Some `Led
      | 5 -> Some `Led_mode
      | 6 -> Some `Key
      | 7 -> Some `Auto_repeat_mode
      | _ -> None
    in
    mask_of_int of_int mask

  let kb_int_of_mask : kb_mask -> int =
    let to_bit = function
      | `Key_click_percent -> 0
      | `Bell_percent -> 1
      | `Bell_pitch -> 2
      | `Bell_duration -> 3
      | `Led -> 4
      | `Led_mode -> 5
      | `Key -> 6
      | `Auto_repeat_mode -> 7
    in
    int_of_mask to_bit

  type led_mode_enum = [ `Off | `On ] [@@deriving sexp]

  let led_mode_enum_of_int : int -> [> led_mode_enum ] option = function
    | 0 -> Some `Off
    | 1 -> Some `On
    | n ->
        Printf.printf "unknown led_mode_enum: %d\n" n;
        None

  let led_mode_int_of_enum : led_mode_enum -> int = function
    | `Off -> 0
    | `On -> 1

  type auto_repeat_mode_enum = [ `Off | `On | `Default ] [@@deriving sexp]

  let auto_repeat_mode_enum_of_int : int -> [> auto_repeat_mode_enum ] option =
    function
    | 0 -> Some `Off
    | 1 -> Some `On
    | 2 -> Some `Default
    | n ->
        Printf.printf "unknown auto_repeat_mode_enum: %d\n" n;
        None

  let auto_repeat_mode_int_of_enum : auto_repeat_mode_enum -> int = function
    | `Off -> 0
    | `On -> 1
    | `Default -> 2

  let encode_change_keyboard_control ?(key_click_percent : int option)
      ?(bell_percent : int option) ?(bell_pitch : int option)
      ?(bell_duration : int option) ?(led : int option)
      ?(led_mode : led_mode_enum option) ?(key : keycode32 option)
      ?(auto_repeat_mode : auto_repeat_mode_enum option) buf =
    (* opcode *)
    encode_uint8 buf 102;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some key_click_percent, 0);
        (Option.is_some bell_percent, 1);
        (Option.is_some bell_pitch, 2);
        (Option.is_some bell_duration, 3);
        (Option.is_some led, 4);
        (Option.is_some led_mode, 5);
        (Option.is_some key, 6);
        (Option.is_some auto_repeat_mode, 7);
      ];
    (match key_click_percent with None -> () | Some v -> encode_int32 buf v);
    (match bell_percent with None -> () | Some v -> encode_int32 buf v);
    (match bell_pitch with None -> () | Some v -> encode_int32 buf v);
    (match bell_duration with None -> () | Some v -> encode_int32 buf v);
    (match led with None -> () | Some v -> encode_int32 buf v);
    (match led_mode with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity led_mode_int_of_enum buf v);
    (match key with None -> () | Some v -> encode_keycode32 buf v);
    (match auto_repeat_mode with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity auto_repeat_mode_int_of_enum buf v);
    (* write request length *)
    encode_request_length buf

  type get_keyboard_control_reply = {
    global_auto_repeat : auto_repeat_mode_enum;
    led_mask : int;
    key_click_percent : int;
    bell_percent : int;
    bell_pitch : int;
    bell_duration : int;
    auto_repeats : int list;
  }
  [@@deriving sexp]

  let encode_get_keyboard_control buf =
    (* opcode *)
    encode_uint8 buf 103;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_keyboard_control_reply length buf ~at :
      (get_keyboard_control_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* global_auto_repeat, at =
      decode_enum decode_char Char.code auto_repeat_mode_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* led_mask, at = decode_int32 buf ~at in
    let* key_click_percent, at = decode_uint8 buf ~at in
    let* bell_percent, at = decode_uint8 buf ~at in
    let* bell_pitch, at = decode_uint16 buf ~at in
    let* bell_duration, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* auto_repeats, at =
      let length = 32 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some
      ( {
          global_auto_repeat;
          led_mask;
          key_click_percent;
          bell_percent;
          bell_pitch;
          bell_duration;
          auto_repeats;
        },
        at )

  let encode_bell ~(percent : int) buf =
    (* opcode *)
    encode_uint8 buf 104;
    encode_int8 buf percent;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_change_pointer_control ~(acceleration_numerator : int)
      ~(acceleration_denominator : int) ~(threshold : int)
      ~(do_acceleration : bool) ~(do_threshold : bool) buf =
    (* opcode *)
    encode_uint8 buf 105;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf acceleration_numerator;
    encode_int16 buf acceleration_denominator;
    encode_int16 buf threshold;
    encode_bool buf do_acceleration;
    encode_bool buf do_threshold;
    (* write request length *)
    encode_request_length buf

  type get_pointer_control_reply = {
    acceleration_numerator : int;
    acceleration_denominator : int;
    threshold : int;
  }
  [@@deriving sexp]

  let encode_get_pointer_control buf =
    (* opcode *)
    encode_uint8 buf 106;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_pointer_control_reply length buf ~at :
      (get_pointer_control_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* acceleration_numerator, at = decode_uint16 buf ~at in
    let* acceleration_denominator, at = decode_uint16 buf ~at in
    let* threshold, at = decode_uint16 buf ~at in
    let at = at + 18 in
    ignore orig;
    Some ({ acceleration_numerator; acceleration_denominator; threshold }, at)

  type blanking_enum = [ `Not_preferred | `Preferred | `Default ]
  [@@deriving sexp]

  let blanking_enum_of_int : int -> [> blanking_enum ] option = function
    | 0 -> Some `Not_preferred
    | 1 -> Some `Preferred
    | 2 -> Some `Default
    | n ->
        Printf.printf "unknown blanking_enum: %d\n" n;
        None

  let blanking_int_of_enum : blanking_enum -> int = function
    | `Not_preferred -> 0
    | `Preferred -> 1
    | `Default -> 2

  type exposures_enum = [ `Not_allowed | `Allowed | `Default ] [@@deriving sexp]

  let exposures_enum_of_int : int -> [> exposures_enum ] option = function
    | 0 -> Some `Not_allowed
    | 1 -> Some `Allowed
    | 2 -> Some `Default
    | n ->
        Printf.printf "unknown exposures_enum: %d\n" n;
        None

  let exposures_int_of_enum : exposures_enum -> int = function
    | `Not_allowed -> 0
    | `Allowed -> 1
    | `Default -> 2

  let encode_set_screen_saver ~(timeout : int) ~(interval : int)
      ~(prefer_blanking : blanking_enum) ~(allow_exposures : exposures_enum) buf
      =
    (* opcode *)
    encode_uint8 buf 107;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf timeout;
    encode_int16 buf interval;
    encode_enum encode_uint8 identity blanking_int_of_enum buf prefer_blanking;
    encode_enum encode_uint8 identity exposures_int_of_enum buf allow_exposures;
    (* write request length *)
    encode_request_length buf

  type get_screen_saver_reply = {
    timeout : int;
    interval : int;
    prefer_blanking : blanking_enum;
    allow_exposures : exposures_enum;
  }
  [@@deriving sexp]

  let encode_get_screen_saver buf =
    (* opcode *)
    encode_uint8 buf 108;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_screen_saver_reply length buf ~at :
      (get_screen_saver_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* timeout, at = decode_uint16 buf ~at in
    let* interval, at = decode_uint16 buf ~at in
    let* prefer_blanking, at =
      decode_enum decode_char Char.code blanking_enum_of_int buf ~at
    in
    let* allow_exposures, at =
      decode_enum decode_char Char.code exposures_enum_of_int buf ~at
    in
    let at = at + 18 in
    ignore orig;
    Some ({ timeout; interval; prefer_blanking; allow_exposures }, at)

  type host_mode_enum = [ `Insert | `Delete ] [@@deriving sexp]

  let host_mode_enum_of_int : int -> [> host_mode_enum ] option = function
    | 0 -> Some `Insert
    | 1 -> Some `Delete
    | n ->
        Printf.printf "unknown host_mode_enum: %d\n" n;
        None

  let host_mode_int_of_enum : host_mode_enum -> int = function
    | `Insert -> 0
    | `Delete -> 1

  type family_enum =
    [ `Internet | `Decnet | `Chaos | `Server_interpreted | `Internet6 ]
  [@@deriving sexp]

  let family_enum_of_int : int -> [> family_enum ] option = function
    | 0 -> Some `Internet
    | 1 -> Some `Decnet
    | 2 -> Some `Chaos
    | 5 -> Some `Server_interpreted
    | 6 -> Some `Internet6
    | n ->
        Printf.printf "unknown family_enum: %d\n" n;
        None

  let family_int_of_enum : family_enum -> int = function
    | `Internet -> 0
    | `Decnet -> 1
    | `Chaos -> 2
    | `Server_interpreted -> 5
    | `Internet6 -> 6

  let encode_change_hosts ~(mode : host_mode_enum) ~(family : family_enum)
      ~(address : char list) buf =
    (* opcode *)
    encode_uint8 buf 109;
    encode_enum encode_uint8 identity host_mode_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity family_int_of_enum buf family;
    encode_pad buf 1;
    encode_uint16 buf (identity ((* Parsetree.Byte *) List.length address));
    encode_list encode_char buf address;
    (* write request length *)
    encode_request_length buf

  type host = { family : family_enum; address : char list } [@@deriving sexp]

  let decode_host buf ~at : (host * int) option =
    let orig = at in
    let* family, at =
      decode_enum decode_uint8 identity family_enum_of_int buf ~at
    in
    let at = at + 1 in
    let* address_len, at = decode_uint16 buf ~at in
    let address_len = address_len in
    let* address, at = decode_list decode_char address_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ family; address }, at)

  let encode_host buf (v : host) =
    encode_enum encode_uint8 identity family_int_of_enum buf v.family;
    encode_pad buf 1;
    encode_uint16 buf (identity ((* Parsetree.Byte *) List.length v.address));
    encode_list encode_char buf v.address;
    encode_align buf 4;
    ()

  type access_control_enum = [ `Disable | `Enable ] [@@deriving sexp]

  let access_control_enum_of_int : int -> [> access_control_enum ] option =
    function
    | 0 -> Some `Disable
    | 1 -> Some `Enable
    | n ->
        Printf.printf "unknown access_control_enum: %d\n" n;
        None

  let access_control_int_of_enum : access_control_enum -> int = function
    | `Disable -> 0
    | `Enable -> 1

  type list_hosts_reply = { mode : access_control_enum; hosts : host list }
  [@@deriving sexp]

  let encode_list_hosts buf =
    (* opcode *)
    encode_uint8 buf 110;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_list_hosts_reply length buf ~at : (list_hosts_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* mode, at =
      decode_enum decode_char Char.code access_control_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* hosts_len, at = decode_uint16 buf ~at in
    let hosts_len = hosts_len in
    let at = at + 22 in
    let* hosts, at = decode_list decode_host hosts_len buf ~at in
    ignore orig;
    Some ({ mode; hosts }, at)

  let encode_set_access_control ~(mode : access_control_enum) buf =
    (* opcode *)
    encode_uint8 buf 111;
    encode_enum encode_uint8 identity access_control_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type close_down_enum = [ `Destroy_all | `Retain_permanent | `Retain_temporary ]
  [@@deriving sexp]

  let close_down_enum_of_int : int -> [> close_down_enum ] option = function
    | 0 -> Some `Destroy_all
    | 1 -> Some `Retain_permanent
    | 2 -> Some `Retain_temporary
    | n ->
        Printf.printf "unknown close_down_enum: %d\n" n;
        None

  let close_down_int_of_enum : close_down_enum -> int = function
    | `Destroy_all -> 0
    | `Retain_permanent -> 1
    | `Retain_temporary -> 2

  let encode_set_close_down_mode ~(mode : close_down_enum) buf =
    (* opcode *)
    encode_uint8 buf 112;
    encode_enum encode_uint8 identity close_down_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type kill_enum = [ `All_temporary ] [@@deriving sexp]

  let kill_enum_of_int : int -> [> kill_enum ] option = function
    | 0 -> Some `All_temporary
    | n ->
        Printf.printf "unknown kill_enum: %d\n" n;
        None

  let kill_int_of_enum : kill_enum -> int = function `All_temporary -> 0

  let encode_kill_client ~(resource : kill_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 113;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_int32 identity kill_int_of_enum buf resource;
    (* write request length *)
    encode_request_length buf

  let encode_rotate_properties ~(window : window) ~(delta : int)
      ~(atoms : atom list) buf =
    (* opcode *)
    encode_uint8 buf 114;
    encode_pad buf 1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_window buf window;
    encode_uint16 buf (identity ((* Parsetree.Xid *) List.length atoms));
    encode_int16 buf delta;
    encode_list encode_atom buf atoms;
    (* write request length *)
    encode_request_length buf

  type screen_saver_enum = [ `Reset | `Active ] [@@deriving sexp]

  let screen_saver_enum_of_int : int -> [> screen_saver_enum ] option = function
    | 0 -> Some `Reset
    | 1 -> Some `Active
    | n ->
        Printf.printf "unknown screen_saver_enum: %d\n" n;
        None

  let screen_saver_int_of_enum : screen_saver_enum -> int = function
    | `Reset -> 0
    | `Active -> 1

  let encode_force_screen_saver ~(mode : screen_saver_enum) buf =
    (* opcode *)
    encode_uint8 buf 115;
    encode_enum encode_uint8 identity screen_saver_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type mapping_status_enum = [ `Success | `Busy | `Failure ] [@@deriving sexp]

  let mapping_status_enum_of_int : int -> [> mapping_status_enum ] option =
    function
    | 0 -> Some `Success
    | 1 -> Some `Busy
    | 2 -> Some `Failure
    | n ->
        Printf.printf "unknown mapping_status_enum: %d\n" n;
        None

  let mapping_status_int_of_enum : mapping_status_enum -> int = function
    | `Success -> 0
    | `Busy -> 1
    | `Failure -> 2

  type set_pointer_mapping_reply = mapping_status_enum [@@deriving sexp]

  let encode_set_pointer_mapping ~(map : int list) buf =
    (* opcode *)
    encode_uint8 buf 116;
    encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length map));
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_uint8 buf map;
    (* write request length *)
    encode_request_length buf

  let decode_set_pointer_mapping_reply length buf ~at :
      (set_pointer_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_char Char.code mapping_status_enum_of_int buf ~at
    in
    let at = at + 6 in
    ignore orig;
    Some (status, at)

  type get_pointer_mapping_reply = int list [@@deriving sexp]

  let encode_get_pointer_mapping buf =
    (* opcode *)
    encode_uint8 buf 117;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_pointer_mapping_reply length buf ~at :
      (get_pointer_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* map_len, at = decode_uint8 buf ~at in
    let map_len = map_len in
    let at = at + 6 in
    let at = at + 24 in
    let* map, at = decode_list decode_uint8 map_len buf ~at in
    ignore orig;
    Some (map, at)

  type map_index_enum =
    [ `Shift | `Lock | `Control | `D1 | `D2 | `D3 | `D4 | `D5 ]
  [@@deriving sexp]

  let map_index_enum_of_int : int -> [> map_index_enum ] option = function
    | 0 -> Some `Shift
    | 1 -> Some `Lock
    | 2 -> Some `Control
    | 3 -> Some `D1
    | 4 -> Some `D2
    | 5 -> Some `D3
    | 6 -> Some `D4
    | 7 -> Some `D5
    | n ->
        Printf.printf "unknown map_index_enum: %d\n" n;
        None

  let map_index_int_of_enum : map_index_enum -> int = function
    | `Shift -> 0
    | `Lock -> 1
    | `Control -> 2
    | `D1 -> 3
    | `D2 -> 4
    | `D3 -> 5
    | `D4 -> 6
    | `D5 -> 7

  type set_modifier_mapping_reply = mapping_status_enum [@@deriving sexp]

  let encode_set_modifier_mapping ~(keycodes : keycode list) buf =
    (* opcode *)
    encode_uint8 buf 118;
    encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length keycodes));
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_keycode buf keycodes;
    (* write request length *)
    encode_request_length buf

  let decode_set_modifier_mapping_reply length buf ~at :
      (set_modifier_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_char Char.code mapping_status_enum_of_int buf ~at
    in
    let at = at + 6 in
    ignore orig;
    Some (status, at)

  type get_modifier_mapping_reply = keycode list [@@deriving sexp]

  let encode_get_modifier_mapping buf =
    (* opcode *)
    encode_uint8 buf 119;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_modifier_mapping_reply length buf ~at :
      (get_modifier_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* keycodes_per_modifier, at = decode_uint8 buf ~at in
    let keycodes_per_modifier = keycodes_per_modifier / 8 in
    let at = at + 6 in
    let at = at + 24 in
    let* keycodes, at =
      decode_list decode_keycode keycodes_per_modifier buf ~at
    in
    ignore orig;
    Some (keycodes, at)

  let encode_no_operation buf =
    (* opcode *)
    encode_uint8 buf 127;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf
end

module Render = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type pict_type_enum = [ `Indexed | `Direct ] [@@deriving sexp]

  let pict_type_enum_of_int : int -> [> pict_type_enum ] option = function
    | 0 -> Some `Indexed
    | 1 -> Some `Direct
    | n ->
        Printf.printf "unknown pict_type_enum: %d\n" n;
        None

  let pict_type_int_of_enum : pict_type_enum -> int = function
    | `Indexed -> 0
    | `Direct -> 1

  type picture_enum = [ `None ] [@@deriving sexp]

  let picture_enum_of_int : int -> [> picture_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown picture_enum: %d\n" n;
        None

  let picture_int_of_enum : picture_enum -> int = function `None -> 0

  type pict_op_enum =
    [ `Clear
    | `Src
    | `Dst
    | `Over
    | `Over_reverse
    | `In
    | `In_reverse
    | `Out
    | `Out_reverse
    | `Atop
    | `Atop_reverse
    | `Xor
    | `Add
    | `Saturate
    | `Disjoint_clear
    | `Disjoint_src
    | `Disjoint_dst
    | `Disjoint_over
    | `Disjoint_over_reverse
    | `Disjoint_in
    | `Disjoint_in_reverse
    | `Disjoint_out
    | `Disjoint_out_reverse
    | `Disjoint_atop
    | `Disjoint_atop_reverse
    | `Disjoint_xor
    | `Conjoint_clear
    | `Conjoint_src
    | `Conjoint_dst
    | `Conjoint_over
    | `Conjoint_over_reverse
    | `Conjoint_in
    | `Conjoint_in_reverse
    | `Conjoint_out
    | `Conjoint_out_reverse
    | `Conjoint_atop
    | `Conjoint_atop_reverse
    | `Conjoint_xor
    | `Multiply
    | `Screen
    | `Overlay
    | `Darken
    | `Lighten
    | `Color_dodge
    | `Color_burn
    | `Hard_light
    | `Soft_light
    | `Difference
    | `Exclusion
    | `Hsl_hue
    | `Hsl_saturation
    | `Hsl_color
    | `Hsl_luminosity ]
  [@@deriving sexp]

  let pict_op_enum_of_int : int -> [> pict_op_enum ] option = function
    | 0 -> Some `Clear
    | 1 -> Some `Src
    | 2 -> Some `Dst
    | 3 -> Some `Over
    | 4 -> Some `Over_reverse
    | 5 -> Some `In
    | 6 -> Some `In_reverse
    | 7 -> Some `Out
    | 8 -> Some `Out_reverse
    | 9 -> Some `Atop
    | 10 -> Some `Atop_reverse
    | 11 -> Some `Xor
    | 12 -> Some `Add
    | 13 -> Some `Saturate
    | 16 -> Some `Disjoint_clear
    | 17 -> Some `Disjoint_src
    | 18 -> Some `Disjoint_dst
    | 19 -> Some `Disjoint_over
    | 20 -> Some `Disjoint_over_reverse
    | 21 -> Some `Disjoint_in
    | 22 -> Some `Disjoint_in_reverse
    | 23 -> Some `Disjoint_out
    | 24 -> Some `Disjoint_out_reverse
    | 25 -> Some `Disjoint_atop
    | 26 -> Some `Disjoint_atop_reverse
    | 27 -> Some `Disjoint_xor
    | 32 -> Some `Conjoint_clear
    | 33 -> Some `Conjoint_src
    | 34 -> Some `Conjoint_dst
    | 35 -> Some `Conjoint_over
    | 36 -> Some `Conjoint_over_reverse
    | 37 -> Some `Conjoint_in
    | 38 -> Some `Conjoint_in_reverse
    | 39 -> Some `Conjoint_out
    | 40 -> Some `Conjoint_out_reverse
    | 41 -> Some `Conjoint_atop
    | 42 -> Some `Conjoint_atop_reverse
    | 43 -> Some `Conjoint_xor
    | 48 -> Some `Multiply
    | 49 -> Some `Screen
    | 50 -> Some `Overlay
    | 51 -> Some `Darken
    | 52 -> Some `Lighten
    | 53 -> Some `Color_dodge
    | 54 -> Some `Color_burn
    | 55 -> Some `Hard_light
    | 56 -> Some `Soft_light
    | 57 -> Some `Difference
    | 58 -> Some `Exclusion
    | 59 -> Some `Hsl_hue
    | 60 -> Some `Hsl_saturation
    | 61 -> Some `Hsl_color
    | 62 -> Some `Hsl_luminosity
    | n ->
        Printf.printf "unknown pict_op_enum: %d\n" n;
        None

  let pict_op_int_of_enum : pict_op_enum -> int = function
    | `Clear -> 0
    | `Src -> 1
    | `Dst -> 2
    | `Over -> 3
    | `Over_reverse -> 4
    | `In -> 5
    | `In_reverse -> 6
    | `Out -> 7
    | `Out_reverse -> 8
    | `Atop -> 9
    | `Atop_reverse -> 10
    | `Xor -> 11
    | `Add -> 12
    | `Saturate -> 13
    | `Disjoint_clear -> 16
    | `Disjoint_src -> 17
    | `Disjoint_dst -> 18
    | `Disjoint_over -> 19
    | `Disjoint_over_reverse -> 20
    | `Disjoint_in -> 21
    | `Disjoint_in_reverse -> 22
    | `Disjoint_out -> 23
    | `Disjoint_out_reverse -> 24
    | `Disjoint_atop -> 25
    | `Disjoint_atop_reverse -> 26
    | `Disjoint_xor -> 27
    | `Conjoint_clear -> 32
    | `Conjoint_src -> 33
    | `Conjoint_dst -> 34
    | `Conjoint_over -> 35
    | `Conjoint_over_reverse -> 36
    | `Conjoint_in -> 37
    | `Conjoint_in_reverse -> 38
    | `Conjoint_out -> 39
    | `Conjoint_out_reverse -> 40
    | `Conjoint_atop -> 41
    | `Conjoint_atop_reverse -> 42
    | `Conjoint_xor -> 43
    | `Multiply -> 48
    | `Screen -> 49
    | `Overlay -> 50
    | `Darken -> 51
    | `Lighten -> 52
    | `Color_dodge -> 53
    | `Color_burn -> 54
    | `Hard_light -> 55
    | `Soft_light -> 56
    | `Difference -> 57
    | `Exclusion -> 58
    | `Hsl_hue -> 59
    | `Hsl_saturation -> 60
    | `Hsl_color -> 61
    | `Hsl_luminosity -> 62

  type poly_edge_enum = [ `Sharp | `Smooth ] [@@deriving sexp]

  let poly_edge_enum_of_int : int -> [> poly_edge_enum ] option = function
    | 0 -> Some `Sharp
    | 1 -> Some `Smooth
    | n ->
        Printf.printf "unknown poly_edge_enum: %d\n" n;
        None

  let poly_edge_int_of_enum : poly_edge_enum -> int = function
    | `Sharp -> 0
    | `Smooth -> 1

  type poly_mode_enum = [ `Precise | `Imprecise ] [@@deriving sexp]

  let poly_mode_enum_of_int : int -> [> poly_mode_enum ] option = function
    | 0 -> Some `Precise
    | 1 -> Some `Imprecise
    | n ->
        Printf.printf "unknown poly_mode_enum: %d\n" n;
        None

  let poly_mode_int_of_enum : poly_mode_enum -> int = function
    | `Precise -> 0
    | `Imprecise -> 1

  type cp_mask =
    [ `Repeat
    | `Alpha_map
    | `Alpha_x_origin
    | `Alpha_y_origin
    | `Clip_x_origin
    | `Clip_y_origin
    | `Clip_mask
    | `Graphics_exposure
    | `Subwindow_mode
    | `Poly_edge
    | `Poly_mode
    | `Dither
    | `Component_alpha ]
    list
  [@@deriving sexp]

  let cp_mask_of_int64 mask : cp_mask option =
    let of_int = function
      | 0 -> Some `Repeat
      | 1 -> Some `Alpha_map
      | 2 -> Some `Alpha_x_origin
      | 3 -> Some `Alpha_y_origin
      | 4 -> Some `Clip_x_origin
      | 5 -> Some `Clip_y_origin
      | 6 -> Some `Clip_mask
      | 7 -> Some `Graphics_exposure
      | 8 -> Some `Subwindow_mode
      | 9 -> Some `Poly_edge
      | 10 -> Some `Poly_mode
      | 11 -> Some `Dither
      | 12 -> Some `Component_alpha
      | _ -> None
    in
    mask_of_int of_int mask

  let cp_int_of_mask : cp_mask -> int =
    let to_bit = function
      | `Repeat -> 0
      | `Alpha_map -> 1
      | `Alpha_x_origin -> 2
      | `Alpha_y_origin -> 3
      | `Clip_x_origin -> 4
      | `Clip_y_origin -> 5
      | `Clip_mask -> 6
      | `Graphics_exposure -> 7
      | `Subwindow_mode -> 8
      | `Poly_edge -> 9
      | `Poly_mode -> 10
      | `Dither -> 11
      | `Component_alpha -> 12
    in
    int_of_mask to_bit

  type sub_pixel_enum =
    [ `Unknown
    | `Horizontal_rgb
    | `Horizontal_bgr
    | `Vertical_rgb
    | `Vertical_bgr
    | `None ]
  [@@deriving sexp]

  let sub_pixel_enum_of_int : int -> [> sub_pixel_enum ] option = function
    | 0 -> Some `Unknown
    | 1 -> Some `Horizontal_rgb
    | 2 -> Some `Horizontal_bgr
    | 3 -> Some `Vertical_rgb
    | 4 -> Some `Vertical_bgr
    | 5 -> Some `None
    | n ->
        Printf.printf "unknown sub_pixel_enum: %d\n" n;
        None

  let sub_pixel_int_of_enum : sub_pixel_enum -> int = function
    | `Unknown -> 0
    | `Horizontal_rgb -> 1
    | `Horizontal_bgr -> 2
    | `Vertical_rgb -> 3
    | `Vertical_bgr -> 4
    | `None -> 5

  type repeat_enum = [ `None | `Normal | `Pad | `Reflect ] [@@deriving sexp]

  let repeat_enum_of_int : int -> [> repeat_enum ] option = function
    | 0 -> Some `None
    | 1 -> Some `Normal
    | 2 -> Some `Pad
    | 3 -> Some `Reflect
    | n ->
        Printf.printf "unknown repeat_enum: %d\n" n;
        None

  let repeat_int_of_enum : repeat_enum -> int = function
    | `None -> 0
    | `Normal -> 1
    | `Pad -> 2
    | `Reflect -> 3

  type glyph = int [@@deriving sexp]

  let decode_glyph = decode_int32
  let encode_glyph = encode_int32

  type glyphset = xid [@@deriving sexp]

  let decode_glyphset = decode_xid
  let encode_glyphset = encode_xid

  type picture = xid [@@deriving sexp]

  let decode_picture = decode_xid
  let encode_picture = encode_xid

  type pictformat = xid [@@deriving sexp]

  let decode_pictformat = decode_xid
  let encode_pictformat = encode_xid

  type fixed = int [@@deriving sexp]

  let decode_fixed = decode_int32
  let encode_fixed = encode_int32

  type pict_format_error = unit [@@deriving sexp]
  type picture_error = unit [@@deriving sexp]
  type pict_op_error = unit [@@deriving sexp]
  type glyph_set_error = unit [@@deriving sexp]
  type glyph_error = unit [@@deriving sexp]

  type directformat = {
    red_shift : int;
    red_mask : int;
    green_shift : int;
    green_mask : int;
    blue_shift : int;
    blue_mask : int;
    alpha_shift : int;
    alpha_mask : int;
  }
  [@@deriving sexp]

  let decode_directformat buf ~at : (directformat * int) option =
    let orig = at in
    let* red_shift, at = decode_uint16 buf ~at in
    let* red_mask, at = decode_uint16 buf ~at in
    let* green_shift, at = decode_uint16 buf ~at in
    let* green_mask, at = decode_uint16 buf ~at in
    let* blue_shift, at = decode_uint16 buf ~at in
    let* blue_mask, at = decode_uint16 buf ~at in
    let* alpha_shift, at = decode_uint16 buf ~at in
    let* alpha_mask, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          red_shift;
          red_mask;
          green_shift;
          green_mask;
          blue_shift;
          blue_mask;
          alpha_shift;
          alpha_mask;
        },
        at )

  let encode_directformat buf (v : directformat) =
    encode_uint16 buf v.red_shift;
    encode_uint16 buf v.red_mask;
    encode_uint16 buf v.green_shift;
    encode_uint16 buf v.green_mask;
    encode_uint16 buf v.blue_shift;
    encode_uint16 buf v.blue_mask;
    encode_uint16 buf v.alpha_shift;
    encode_uint16 buf v.alpha_mask;
    ()

  type pictforminfo = {
    id : pictformat;
    type_ : pict_type_enum;
    depth : int;
    direct : directformat;
    colormap : Xproto.colormap;
  }
  [@@deriving sexp]

  let decode_pictforminfo buf ~at : (pictforminfo * int) option =
    let orig = at in
    let* id, at = decode_pictformat buf ~at in
    let* type_, at =
      decode_enum decode_uint8 identity pict_type_enum_of_int buf ~at
    in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 2 in
    let* direct, at = decode_directformat buf ~at in
    let* colormap, at = Xproto.decode_colormap buf ~at in
    ignore orig;
    Some ({ id; type_; depth; direct; colormap }, at)

  let encode_pictforminfo buf (v : pictforminfo) =
    encode_pictformat buf v.id;
    encode_enum encode_uint8 identity pict_type_int_of_enum buf v.type_;
    encode_uint8 buf v.depth;
    encode_pad buf 2;
    encode_directformat buf v.direct;
    Xproto.encode_colormap buf v.colormap;
    ()

  type pictvisual = { visual : Xproto.visualid; format : pictformat }
  [@@deriving sexp]

  let decode_pictvisual buf ~at : (pictvisual * int) option =
    let orig = at in
    let* visual, at = Xproto.decode_visualid buf ~at in
    let* format, at = decode_pictformat buf ~at in
    ignore orig;
    Some ({ visual; format }, at)

  let encode_pictvisual buf (v : pictvisual) =
    Xproto.encode_visualid buf v.visual;
    encode_pictformat buf v.format;
    ()

  type pictdepth = { depth : int; visuals : pictvisual list } [@@deriving sexp]

  let decode_pictdepth buf ~at : (pictdepth * int) option =
    let orig = at in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* num_visuals, at = decode_uint16 buf ~at in
    let num_visuals = num_visuals in
    let at = at + 4 in
    let* visuals, at = decode_list decode_pictvisual num_visuals buf ~at in
    ignore orig;
    Some ({ depth; visuals }, at)

  let encode_pictdepth buf (v : pictdepth) =
    encode_uint8 buf v.depth;
    encode_pad buf 1;
    encode_uint16 buf (identity ((* invalid_argument *) List.length v.visuals));
    encode_pad buf 4;
    encode_list encode_pictvisual buf v.visuals;
    ()

  type pictscreen = { fallback : pictformat; depths : pictdepth list }
  [@@deriving sexp]

  let decode_pictscreen buf ~at : (pictscreen * int) option =
    let orig = at in
    let* num_depths, at = decode_int32 buf ~at in
    let num_depths = num_depths in
    let* fallback, at = decode_pictformat buf ~at in
    let* depths, at = decode_list decode_pictdepth num_depths buf ~at in
    ignore orig;
    Some ({ fallback; depths }, at)

  let encode_pictscreen buf (v : pictscreen) =
    encode_int32 buf (identity ((* invalid_argument *) List.length v.depths));
    encode_pictformat buf v.fallback;
    encode_list encode_pictdepth buf v.depths;
    ()

  type indexvalue = {
    pixel : int;
    red : int;
    green : int;
    blue : int;
    alpha : int;
  }
  [@@deriving sexp]

  let decode_indexvalue buf ~at : (indexvalue * int) option =
    let orig = at in
    let* pixel, at = decode_int32 buf ~at in
    let* red, at = decode_uint16 buf ~at in
    let* green, at = decode_uint16 buf ~at in
    let* blue, at = decode_uint16 buf ~at in
    let* alpha, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ pixel; red; green; blue; alpha }, at)

  let encode_indexvalue buf (v : indexvalue) =
    encode_int32 buf v.pixel;
    encode_uint16 buf v.red;
    encode_uint16 buf v.green;
    encode_uint16 buf v.blue;
    encode_uint16 buf v.alpha;
    ()

  type color = { red : int; green : int; blue : int; alpha : int }
  [@@deriving sexp]

  let decode_color buf ~at : (color * int) option =
    let orig = at in
    let* red, at = decode_uint16 buf ~at in
    let* green, at = decode_uint16 buf ~at in
    let* blue, at = decode_uint16 buf ~at in
    let* alpha, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ red; green; blue; alpha }, at)

  let encode_color buf (v : color) =
    encode_uint16 buf v.red;
    encode_uint16 buf v.green;
    encode_uint16 buf v.blue;
    encode_uint16 buf v.alpha;
    ()

  type pointfix = { x : fixed; y : fixed } [@@deriving sexp]

  let decode_pointfix buf ~at : (pointfix * int) option =
    let orig = at in
    let* x, at = decode_fixed buf ~at in
    let* y, at = decode_fixed buf ~at in
    ignore orig;
    Some ({ x; y }, at)

  let encode_pointfix buf (v : pointfix) =
    encode_fixed buf v.x;
    encode_fixed buf v.y;
    ()

  type linefix = { p1 : pointfix; p2 : pointfix } [@@deriving sexp]

  let decode_linefix buf ~at : (linefix * int) option =
    let orig = at in
    let* p1, at = decode_pointfix buf ~at in
    let* p2, at = decode_pointfix buf ~at in
    ignore orig;
    Some ({ p1; p2 }, at)

  let encode_linefix buf (v : linefix) =
    encode_pointfix buf v.p1;
    encode_pointfix buf v.p2;
    ()

  type triangle = { p1 : pointfix; p2 : pointfix; p3 : pointfix }
  [@@deriving sexp]

  let decode_triangle buf ~at : (triangle * int) option =
    let orig = at in
    let* p1, at = decode_pointfix buf ~at in
    let* p2, at = decode_pointfix buf ~at in
    let* p3, at = decode_pointfix buf ~at in
    ignore orig;
    Some ({ p1; p2; p3 }, at)

  let encode_triangle buf (v : triangle) =
    encode_pointfix buf v.p1;
    encode_pointfix buf v.p2;
    encode_pointfix buf v.p3;
    ()

  type trapezoid = {
    top : fixed;
    bottom : fixed;
    left : linefix;
    right : linefix;
  }
  [@@deriving sexp]

  let decode_trapezoid buf ~at : (trapezoid * int) option =
    let orig = at in
    let* top, at = decode_fixed buf ~at in
    let* bottom, at = decode_fixed buf ~at in
    let* left, at = decode_linefix buf ~at in
    let* right, at = decode_linefix buf ~at in
    ignore orig;
    Some ({ top; bottom; left; right }, at)

  let encode_trapezoid buf (v : trapezoid) =
    encode_fixed buf v.top;
    encode_fixed buf v.bottom;
    encode_linefix buf v.left;
    encode_linefix buf v.right;
    ()

  type glyphinfo = {
    width : int;
    height : int;
    x : int;
    y : int;
    x_off : int;
    y_off : int;
  }
  [@@deriving sexp]

  let decode_glyphinfo buf ~at : (glyphinfo * int) option =
    let orig = at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* x_off, at = decode_int16 buf ~at in
    let* y_off, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ width; height; x; y; x_off; y_off }, at)

  let encode_glyphinfo buf (v : glyphinfo) =
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    encode_int16 buf v.x_off;
    encode_int16 buf v.y_off;
    ()

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type query_pict_formats_reply = {
    num_depths : int;
    num_visuals : int;
    formats : pictforminfo list;
    screens : pictscreen list;
    subpixels : sub_pixel_enum list;
  }
  [@@deriving sexp]

  let encode_query_pict_formats buf =
    (* opcode *)
    encode_uint8 buf 1;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_pict_formats_reply length buf ~at :
      (query_pict_formats_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_formats, at = decode_int32 buf ~at in
    let num_formats = num_formats in
    let* num_screens, at = decode_int32 buf ~at in
    let num_screens = num_screens in
    let* num_depths, at = decode_int32 buf ~at in
    let* num_visuals, at = decode_int32 buf ~at in
    let* num_subpixel, at = decode_int32 buf ~at in
    let num_subpixel = num_subpixel in
    let at = at + 4 in
    let* formats, at = decode_list decode_pictforminfo num_formats buf ~at in
    let* screens, at = decode_list decode_pictscreen num_screens buf ~at in
    let* subpixels, at =
      decode_list
        (decode_enum decode_int32 identity sub_pixel_enum_of_int)
        num_subpixel buf ~at
    in
    ignore orig;
    Some ({ num_depths; num_visuals; formats; screens; subpixels }, at)

  type query_pict_index_values_reply = indexvalue list [@@deriving sexp]

  let encode_query_pict_index_values ~(format : pictformat) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_pictformat buf format;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_pict_index_values_reply length buf ~at :
      (query_pict_index_values_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_values, at = decode_int32 buf ~at in
    let num_values = num_values in
    let at = at + 20 in
    let* values, at = decode_list decode_indexvalue num_values buf ~at in
    ignore orig;
    Some (values, at)

  let encode_create_picture ~(pid : picture) ~(drawable : Xproto.drawable)
      ~(format : pictformat) ?(repeat : repeat_enum option)
      ?(alphamap : picture option) ?(alphaxorigin : int option)
      ?(alphayorigin : int option) ?(clipxorigin : int option)
      ?(clipyorigin : int option) ?(clipmask : Xproto.pixmap option)
      ?(graphicsexposure : int option)
      ?(subwindowmode : Xproto.subwindow_mode_enum option)
      ?(polyedge : poly_edge_enum option) ?(polymode : poly_mode_enum option)
      ?(dither : Xproto.atom option) ?(componentalpha : int option) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_picture buf pid;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    encode_pictformat buf format;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some repeat, 0);
        (Option.is_some alphamap, 1);
        (Option.is_some alphaxorigin, 2);
        (Option.is_some alphayorigin, 3);
        (Option.is_some clipxorigin, 4);
        (Option.is_some clipyorigin, 5);
        (Option.is_some clipmask, 6);
        (Option.is_some graphicsexposure, 7);
        (Option.is_some subwindowmode, 8);
        (Option.is_some polyedge, 9);
        (Option.is_some polymode, 10);
        (Option.is_some dither, 11);
        (Option.is_some componentalpha, 12);
      ];
    (match repeat with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity repeat_int_of_enum buf v);
    (match alphamap with None -> () | Some v -> encode_picture buf v);
    (match alphaxorigin with None -> () | Some v -> encode_int32 buf v);
    (match alphayorigin with None -> () | Some v -> encode_int32 buf v);
    (match clipxorigin with None -> () | Some v -> encode_int32 buf v);
    (match clipyorigin with None -> () | Some v -> encode_int32 buf v);
    (match clipmask with None -> () | Some v -> Xproto.encode_pixmap buf v);
    (match graphicsexposure with None -> () | Some v -> encode_int32 buf v);
    (match subwindowmode with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity Xproto.subwindow_mode_int_of_enum buf
          v);
    (match polyedge with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity poly_edge_int_of_enum buf v);
    (match polymode with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity poly_mode_int_of_enum buf v);
    (match dither with None -> () | Some v -> Xproto.encode_atom buf v);
    (match componentalpha with None -> () | Some v -> encode_int32 buf v);
    (* write request length *)
    encode_request_length buf

  let encode_change_picture ~(picture : picture) ?(repeat : repeat_enum option)
      ?(alphamap : picture option) ?(alphaxorigin : int option)
      ?(alphayorigin : int option) ?(clipxorigin : int option)
      ?(clipyorigin : int option) ?(clipmask : Xproto.pixmap option)
      ?(graphicsexposure : int option)
      ?(subwindowmode : Xproto.subwindow_mode_enum option)
      ?(polyedge : poly_edge_enum option) ?(polymode : poly_mode_enum option)
      ?(dither : Xproto.atom option) ?(componentalpha : int option) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some repeat, 0);
        (Option.is_some alphamap, 1);
        (Option.is_some alphaxorigin, 2);
        (Option.is_some alphayorigin, 3);
        (Option.is_some clipxorigin, 4);
        (Option.is_some clipyorigin, 5);
        (Option.is_some clipmask, 6);
        (Option.is_some graphicsexposure, 7);
        (Option.is_some subwindowmode, 8);
        (Option.is_some polyedge, 9);
        (Option.is_some polymode, 10);
        (Option.is_some dither, 11);
        (Option.is_some componentalpha, 12);
      ];
    (match repeat with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity repeat_int_of_enum buf v);
    (match alphamap with None -> () | Some v -> encode_picture buf v);
    (match alphaxorigin with None -> () | Some v -> encode_int32 buf v);
    (match alphayorigin with None -> () | Some v -> encode_int32 buf v);
    (match clipxorigin with None -> () | Some v -> encode_int32 buf v);
    (match clipyorigin with None -> () | Some v -> encode_int32 buf v);
    (match clipmask with None -> () | Some v -> Xproto.encode_pixmap buf v);
    (match graphicsexposure with None -> () | Some v -> encode_int32 buf v);
    (match subwindowmode with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity Xproto.subwindow_mode_int_of_enum buf
          v);
    (match polyedge with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity poly_edge_int_of_enum buf v);
    (match polymode with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity poly_mode_int_of_enum buf v);
    (match dither with None -> () | Some v -> Xproto.encode_atom buf v);
    (match componentalpha with None -> () | Some v -> encode_int32 buf v);
    (* write request length *)
    encode_request_length buf

  let encode_set_picture_clip_rectangles ~(picture : picture)
      ~(clip_x_origin : int) ~(clip_y_origin : int)
      ~(rectangles : Xproto.rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf clip_x_origin;
    encode_int16 buf clip_y_origin;
    encode_list Xproto.encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_free_picture ~(picture : picture) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_composite ~(op : pict_op_enum) ~(src : picture)
      ~(mask : picture_enum alt_enum) ~(dst : picture) ~(src_x : int)
      ~(src_y : int) ~(mask_x : int) ~(mask_y : int) ~(dst_x : int)
      ~(dst_y : int) ~(width : int) ~(height : int) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_alt_enum encode_picture identity picture_int_of_enum buf mask;
    encode_picture buf dst;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_int16 buf mask_x;
    encode_int16 buf mask_y;
    encode_int16 buf dst_x;
    encode_int16 buf dst_y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let encode_trapezoids ~(op : pict_op_enum) ~(src : picture) ~(dst : picture)
      ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int)
      ~(traps : trapezoid list) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_trapezoid buf traps;
    (* write request length *)
    encode_request_length buf

  let encode_triangles ~(op : pict_op_enum) ~(src : picture) ~(dst : picture)
      ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int)
      ~(triangles : triangle list) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_triangle buf triangles;
    (* write request length *)
    encode_request_length buf

  let encode_tri_strip ~(op : pict_op_enum) ~(src : picture) ~(dst : picture)
      ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int)
      ~(points : pointfix list) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_pointfix buf points;
    (* write request length *)
    encode_request_length buf

  let encode_tri_fan ~(op : pict_op_enum) ~(src : picture) ~(dst : picture)
      ~(mask_format : pictformat) ~(src_x : int) ~(src_y : int)
      ~(points : pointfix list) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_pointfix buf points;
    (* write request length *)
    encode_request_length buf

  let encode_create_glyph_set ~(gsid : glyphset) ~(format : pictformat) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_glyphset buf gsid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pictformat buf format;
    (* write request length *)
    encode_request_length buf

  let encode_reference_glyph_set ~(gsid : glyphset) ~(existing : glyphset) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_glyphset buf gsid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_glyphset buf existing;
    (* write request length *)
    encode_request_length buf

  let encode_free_glyph_set ~(glyphset : glyphset) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_glyphset buf glyphset;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_add_glyphs ~(glyphset : glyphset) ~(glyphids : int list)
      ~(glyphs : glyphinfo list) ~(data : char list) buf =
    (* opcode *)
    encode_uint8 buf 20;
    encode_glyphset buf glyphset;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length glyphids));
    encode_list encode_int32 buf glyphids;
    encode_list encode_glyphinfo buf glyphs;
    encode_list encode_char buf data;
    (* write request length *)
    encode_request_length buf

  let encode_free_glyphs ~(glyphset : glyphset) ~(glyphs : glyph list) buf =
    (* opcode *)
    encode_uint8 buf 22;
    encode_glyphset buf glyphset;
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_glyph buf glyphs;
    (* write request length *)
    encode_request_length buf

  let encode_composite_glyphs8 ~(op : pict_op_enum) ~(src : picture)
      ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset)
      ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list) buf =
    (* opcode *)
    encode_uint8 buf 23;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_glyphset buf glyphset;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_char buf glyphcmds;
    (* write request length *)
    encode_request_length buf

  let encode_composite_glyphs16 ~(op : pict_op_enum) ~(src : picture)
      ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset)
      ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list) buf =
    (* opcode *)
    encode_uint8 buf 24;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_glyphset buf glyphset;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_char buf glyphcmds;
    (* write request length *)
    encode_request_length buf

  let encode_composite_glyphs32 ~(op : pict_op_enum) ~(src : picture)
      ~(dst : picture) ~(mask_format : pictformat) ~(glyphset : glyphset)
      ~(src_x : int) ~(src_y : int) ~(glyphcmds : char list) buf =
    (* opcode *)
    encode_uint8 buf 25;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf src;
    encode_picture buf dst;
    encode_pictformat buf mask_format;
    encode_glyphset buf glyphset;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_list encode_char buf glyphcmds;
    (* write request length *)
    encode_request_length buf

  let encode_fill_rectangles ~(op : pict_op_enum) ~(dst : picture)
      ~(color : color) ~(rects : Xproto.rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 26;
    encode_enum encode_uint8 identity pict_op_int_of_enum buf op;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_picture buf dst;
    encode_color buf color;
    encode_list Xproto.encode_rectangle buf rects;
    (* write request length *)
    encode_request_length buf

  let encode_create_cursor ~(cid : Xproto.cursor) ~(source : picture) ~(x : int)
      ~(y : int) buf =
    (* opcode *)
    encode_uint8 buf 27;
    Xproto.encode_cursor buf cid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_picture buf source;
    encode_uint16 buf x;
    encode_uint16 buf y;
    (* write request length *)
    encode_request_length buf

  type transform = {
    matrix11 : fixed;
    matrix12 : fixed;
    matrix13 : fixed;
    matrix21 : fixed;
    matrix22 : fixed;
    matrix23 : fixed;
    matrix31 : fixed;
    matrix32 : fixed;
    matrix33 : fixed;
  }
  [@@deriving sexp]

  let decode_transform buf ~at : (transform * int) option =
    let orig = at in
    let* matrix11, at = decode_fixed buf ~at in
    let* matrix12, at = decode_fixed buf ~at in
    let* matrix13, at = decode_fixed buf ~at in
    let* matrix21, at = decode_fixed buf ~at in
    let* matrix22, at = decode_fixed buf ~at in
    let* matrix23, at = decode_fixed buf ~at in
    let* matrix31, at = decode_fixed buf ~at in
    let* matrix32, at = decode_fixed buf ~at in
    let* matrix33, at = decode_fixed buf ~at in
    ignore orig;
    Some
      ( {
          matrix11;
          matrix12;
          matrix13;
          matrix21;
          matrix22;
          matrix23;
          matrix31;
          matrix32;
          matrix33;
        },
        at )

  let encode_transform buf (v : transform) =
    encode_fixed buf v.matrix11;
    encode_fixed buf v.matrix12;
    encode_fixed buf v.matrix13;
    encode_fixed buf v.matrix21;
    encode_fixed buf v.matrix22;
    encode_fixed buf v.matrix23;
    encode_fixed buf v.matrix31;
    encode_fixed buf v.matrix32;
    encode_fixed buf v.matrix33;
    ()

  let encode_set_picture_transform ~(picture : picture) ~(transform : transform)
      buf =
    (* opcode *)
    encode_uint8 buf 28;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_transform buf transform;
    (* write request length *)
    encode_request_length buf

  type query_filters_reply = { aliases : int list; filters : Xproto.str list }
  [@@deriving sexp]

  let encode_query_filters ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 29;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_filters_reply length buf ~at :
      (query_filters_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_aliases, at = decode_int32 buf ~at in
    let num_aliases = num_aliases in
    let* num_filters, at = decode_int32 buf ~at in
    let num_filters = num_filters in
    let at = at + 16 in
    let* aliases, at = decode_list decode_uint16 num_aliases buf ~at in
    let* filters, at = decode_list Xproto.decode_str num_filters buf ~at in
    ignore orig;
    Some ({ aliases; filters }, at)

  let encode_set_picture_filter ~(picture : picture) ~(filter : string)
      ~(values : fixed list) buf =
    (* opcode *)
    encode_uint8 buf 30;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity (String.length filter));
    encode_pad buf 2;
    encode_string buf filter;
    encode_align buf 4;
    encode_list encode_fixed buf values;
    (* write request length *)
    encode_request_length buf

  type animcursorelt = { cursor : Xproto.cursor; delay : int } [@@deriving sexp]

  let decode_animcursorelt buf ~at : (animcursorelt * int) option =
    let orig = at in
    let* cursor, at = Xproto.decode_cursor buf ~at in
    let* delay, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ cursor; delay }, at)

  let encode_animcursorelt buf (v : animcursorelt) =
    Xproto.encode_cursor buf v.cursor;
    encode_int32 buf v.delay;
    ()

  let encode_create_anim_cursor ~(cid : Xproto.cursor)
      ~(cursors : animcursorelt list) buf =
    (* opcode *)
    encode_uint8 buf 31;
    Xproto.encode_cursor buf cid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_animcursorelt buf cursors;
    (* write request length *)
    encode_request_length buf

  type spanfix = { l : fixed; r : fixed; y : fixed } [@@deriving sexp]

  let decode_spanfix buf ~at : (spanfix * int) option =
    let orig = at in
    let* l, at = decode_fixed buf ~at in
    let* r, at = decode_fixed buf ~at in
    let* y, at = decode_fixed buf ~at in
    ignore orig;
    Some ({ l; r; y }, at)

  let encode_spanfix buf (v : spanfix) =
    encode_fixed buf v.l;
    encode_fixed buf v.r;
    encode_fixed buf v.y;
    ()

  type trap = { top : spanfix; bot : spanfix } [@@deriving sexp]

  let decode_trap buf ~at : (trap * int) option =
    let orig = at in
    let* top, at = decode_spanfix buf ~at in
    let* bot, at = decode_spanfix buf ~at in
    ignore orig;
    Some ({ top; bot }, at)

  let encode_trap buf (v : trap) =
    encode_spanfix buf v.top;
    encode_spanfix buf v.bot;
    ()

  let encode_add_traps ~(picture : picture) ~(x_off : int) ~(y_off : int)
      ~(traps : trap list) buf =
    (* opcode *)
    encode_uint8 buf 32;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf x_off;
    encode_int16 buf y_off;
    encode_list encode_trap buf traps;
    (* write request length *)
    encode_request_length buf

  let encode_create_solid_fill ~(picture : picture) ~(color : color) buf =
    (* opcode *)
    encode_uint8 buf 33;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_color buf color;
    (* write request length *)
    encode_request_length buf

  let encode_create_linear_gradient ~(picture : picture) ~(p1 : pointfix)
      ~(p2 : pointfix) ~(stops : fixed list) ~(colors : color list) buf =
    (* opcode *)
    encode_uint8 buf 34;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pointfix buf p1;
    encode_pointfix buf p2;
    encode_int32 buf (identity ((* Parsetree.Int32 *) List.length stops));
    encode_list encode_fixed buf stops;
    encode_list encode_color buf colors;
    (* write request length *)
    encode_request_length buf

  let encode_create_radial_gradient ~(picture : picture) ~(inner : pointfix)
      ~(outer : pointfix) ~(inner_radius : fixed) ~(outer_radius : fixed)
      ~(stops : fixed list) ~(colors : color list) buf =
    (* opcode *)
    encode_uint8 buf 35;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pointfix buf inner;
    encode_pointfix buf outer;
    encode_fixed buf inner_radius;
    encode_fixed buf outer_radius;
    encode_int32 buf (identity ((* Parsetree.Int32 *) List.length stops));
    encode_list encode_fixed buf stops;
    encode_list encode_color buf colors;
    (* write request length *)
    encode_request_length buf

  let encode_create_conical_gradient ~(picture : picture) ~(center : pointfix)
      ~(angle : fixed) ~(stops : fixed list) ~(colors : color list) buf =
    (* opcode *)
    encode_uint8 buf 36;
    encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pointfix buf center;
    encode_fixed buf angle;
    encode_int32 buf (identity ((* Parsetree.Int32 *) List.length stops));
    encode_list encode_fixed buf stops;
    encode_list encode_color buf colors;
    (* write request length *)
    encode_request_length buf
end

module Shape = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type op = int [@@deriving sexp]

  let decode_op = decode_uint8
  let encode_op = encode_uint8

  type kind = int [@@deriving sexp]

  let decode_kind = decode_uint8
  let encode_kind = encode_uint8

  type so_enum = [ `Set | `Union | `Intersect | `Subtract | `Invert ]
  [@@deriving sexp]

  let so_enum_of_int : int -> [> so_enum ] option = function
    | 0 -> Some `Set
    | 1 -> Some `Union
    | 2 -> Some `Intersect
    | 3 -> Some `Subtract
    | 4 -> Some `Invert
    | n ->
        Printf.printf "unknown so_enum: %d\n" n;
        None

  let so_int_of_enum : so_enum -> int = function
    | `Set -> 0
    | `Union -> 1
    | `Intersect -> 2
    | `Subtract -> 3
    | `Invert -> 4

  type sk_enum = [ `Bounding | `Clip | `Input ] [@@deriving sexp]

  let sk_enum_of_int : int -> [> sk_enum ] option = function
    | 0 -> Some `Bounding
    | 1 -> Some `Clip
    | 2 -> Some `Input
    | n ->
        Printf.printf "unknown sk_enum: %d\n" n;
        None

  let sk_int_of_enum : sk_enum -> int = function
    | `Bounding -> 0
    | `Clip -> 1
    | `Input -> 2

  type notify_event = {
    shape_kind : sk_enum;
    affected_window : Xproto.window;
    extents_x : int;
    extents_y : int;
    extents_width : int;
    extents_height : int;
    server_time : Xproto.timestamp;
    shaped : bool;
  }
  [@@deriving sexp]

  let decode_notify_event buf ~at : (notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* shape_kind, at =
      decode_enum decode_kind identity sk_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* affected_window, at = Xproto.decode_window buf ~at in
    let* extents_x, at = decode_int16 buf ~at in
    let* extents_y, at = decode_int16 buf ~at in
    let* extents_width, at = decode_uint16 buf ~at in
    let* extents_height, at = decode_uint16 buf ~at in
    let* server_time, at = Xproto.decode_timestamp buf ~at in
    let* shaped, at = decode_bool buf ~at in
    let at = at + 11 in
    ignore orig;
    Some
      ( {
          shape_kind;
          affected_window;
          extents_x;
          extents_y;
          extents_width;
          extents_height;
          server_time;
          shaped;
        },
        at )

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  let encode_rectangles ~(operation : so_enum) ~(destination_kind : sk_enum)
      ~(ordering : Xproto.clip_ordering_enum)
      ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int)
      ~(rectangles : Xproto.rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_enum encode_op identity so_int_of_enum buf operation;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_kind identity sk_int_of_enum buf destination_kind;
    encode_enum encode_char Char.chr Xproto.clip_ordering_int_of_enum buf
      ordering;
    encode_pad buf 1;
    Xproto.encode_window buf destination_window;
    encode_int16 buf x_offset;
    encode_int16 buf y_offset;
    encode_list Xproto.encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_mask ~(operation : so_enum) ~(destination_kind : sk_enum)
      ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int)
      ~(source_bitmap : Xproto.pixmap_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_enum encode_op identity so_int_of_enum buf operation;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_kind identity sk_int_of_enum buf destination_kind;
    encode_pad buf 2;
    Xproto.encode_window buf destination_window;
    encode_int16 buf x_offset;
    encode_int16 buf y_offset;
    encode_alt_enum Xproto.encode_pixmap identity Xproto.pixmap_int_of_enum buf
      source_bitmap;
    (* write request length *)
    encode_request_length buf

  let encode_combine ~(operation : so_enum) ~(destination_kind : sk_enum)
      ~(source_kind : sk_enum) ~(destination_window : Xproto.window)
      ~(x_offset : int) ~(y_offset : int) ~(source_window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_enum encode_op identity so_int_of_enum buf operation;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_kind identity sk_int_of_enum buf destination_kind;
    encode_enum encode_kind identity sk_int_of_enum buf source_kind;
    encode_pad buf 1;
    Xproto.encode_window buf destination_window;
    encode_int16 buf x_offset;
    encode_int16 buf y_offset;
    Xproto.encode_window buf source_window;
    (* write request length *)
    encode_request_length buf

  let encode_offset ~(destination_kind : sk_enum)
      ~(destination_window : Xproto.window) ~(x_offset : int) ~(y_offset : int)
      buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_enum encode_kind identity sk_int_of_enum buf destination_kind;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    Xproto.encode_window buf destination_window;
    encode_int16 buf x_offset;
    encode_int16 buf y_offset;
    (* write request length *)
    encode_request_length buf

  type query_extents_reply = {
    bounding_shaped : bool;
    clip_shaped : bool;
    bounding_shape_extents_x : int;
    bounding_shape_extents_y : int;
    bounding_shape_extents_width : int;
    bounding_shape_extents_height : int;
    clip_shape_extents_x : int;
    clip_shape_extents_y : int;
    clip_shape_extents_width : int;
    clip_shape_extents_height : int;
  }
  [@@deriving sexp]

  let encode_query_extents ~(destination_window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 5;
    Xproto.encode_window buf destination_window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_extents_reply length buf ~at :
      (query_extents_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* bounding_shaped, at = decode_bool buf ~at in
    let* clip_shaped, at = decode_bool buf ~at in
    let at = at + 2 in
    let* bounding_shape_extents_x, at = decode_int16 buf ~at in
    let* bounding_shape_extents_y, at = decode_int16 buf ~at in
    let* bounding_shape_extents_width, at = decode_uint16 buf ~at in
    let* bounding_shape_extents_height, at = decode_uint16 buf ~at in
    let* clip_shape_extents_x, at = decode_int16 buf ~at in
    let* clip_shape_extents_y, at = decode_int16 buf ~at in
    let* clip_shape_extents_width, at = decode_uint16 buf ~at in
    let* clip_shape_extents_height, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          bounding_shaped;
          clip_shaped;
          bounding_shape_extents_x;
          bounding_shape_extents_y;
          bounding_shape_extents_width;
          bounding_shape_extents_height;
          clip_shape_extents_x;
          clip_shape_extents_y;
          clip_shape_extents_width;
          clip_shape_extents_height;
        },
        at )

  let encode_select_input ~(destination_window : Xproto.window) ~(enable : bool)
      buf =
    (* opcode *)
    encode_uint8 buf 6;
    Xproto.encode_window buf destination_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_bool buf enable;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type input_selected_reply = bool [@@deriving sexp]

  let encode_input_selected ~(destination_window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_window buf destination_window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_input_selected_reply length buf ~at :
      (input_selected_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* enabled, at = decode_bool buf ~at in
    let at = at + 6 in
    ignore orig;
    Some (enabled, at)

  type get_rectangles_reply = {
    ordering : Xproto.clip_ordering_enum;
    rectangles : Xproto.rectangle list;
  }
  [@@deriving sexp]

  let encode_get_rectangles ~(window : Xproto.window) ~(source_kind : sk_enum)
      buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_kind identity sk_int_of_enum buf source_kind;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_rectangles_reply length buf ~at :
      (get_rectangles_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* ordering, at =
      decode_enum decode_char Char.code Xproto.clip_ordering_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* rectangles_len, at = decode_int32 buf ~at in
    let rectangles_len = rectangles_len in
    let at = at + 20 in
    let* rectangles, at =
      decode_list Xproto.decode_rectangle rectangles_len buf ~at
    in
    ignore orig;
    Some ({ ordering; rectangles }, at)
end

module Xfixes = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type save_set_mode_enum = [ `Insert | `Delete ] [@@deriving sexp]

  let save_set_mode_enum_of_int : int -> [> save_set_mode_enum ] option =
    function
    | 0 -> Some `Insert
    | 1 -> Some `Delete
    | n ->
        Printf.printf "unknown save_set_mode_enum: %d\n" n;
        None

  let save_set_mode_int_of_enum : save_set_mode_enum -> int = function
    | `Insert -> 0
    | `Delete -> 1

  type save_set_target_enum = [ `Nearest | `Root ] [@@deriving sexp]

  let save_set_target_enum_of_int : int -> [> save_set_target_enum ] option =
    function
    | 0 -> Some `Nearest
    | 1 -> Some `Root
    | n ->
        Printf.printf "unknown save_set_target_enum: %d\n" n;
        None

  let save_set_target_int_of_enum : save_set_target_enum -> int = function
    | `Nearest -> 0
    | `Root -> 1

  type save_set_mapping_enum = [ `Map | `Unmap ] [@@deriving sexp]

  let save_set_mapping_enum_of_int : int -> [> save_set_mapping_enum ] option =
    function
    | 0 -> Some `Map
    | 1 -> Some `Unmap
    | n ->
        Printf.printf "unknown save_set_mapping_enum: %d\n" n;
        None

  let save_set_mapping_int_of_enum : save_set_mapping_enum -> int = function
    | `Map -> 0
    | `Unmap -> 1

  let encode_change_save_set ~(mode : save_set_mode_enum)
      ~(target : save_set_target_enum) ~(map : save_set_mapping_enum)
      ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_enum encode_char Char.chr save_set_mode_int_of_enum buf mode;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_char Char.chr save_set_target_int_of_enum buf target;
    encode_enum encode_char Char.chr save_set_mapping_int_of_enum buf map;
    encode_pad buf 1;
    Xproto.encode_window buf window;
    (* write request length *)
    encode_request_length buf

  type selection_event_enum =
    [ `Set_selection_owner
    | `Selection_window_destroy
    | `Selection_client_close ]
  [@@deriving sexp]

  let selection_event_enum_of_int : int -> [> selection_event_enum ] option =
    function
    | 0 -> Some `Set_selection_owner
    | 1 -> Some `Selection_window_destroy
    | 2 -> Some `Selection_client_close
    | n ->
        Printf.printf "unknown selection_event_enum: %d\n" n;
        None

  let selection_event_int_of_enum : selection_event_enum -> int = function
    | `Set_selection_owner -> 0
    | `Selection_window_destroy -> 1
    | `Selection_client_close -> 2

  type selection_event_mask =
    [ `Set_selection_owner
    | `Selection_window_destroy
    | `Selection_client_close ]
    list
  [@@deriving sexp]

  let selection_event_mask_mask_of_int64 mask : selection_event_mask option =
    let of_int = function
      | 0 -> Some `Set_selection_owner
      | 1 -> Some `Selection_window_destroy
      | 2 -> Some `Selection_client_close
      | _ -> None
    in
    mask_of_int of_int mask

  let selection_event_mask_int_of_mask : selection_event_mask -> int =
    let to_bit = function
      | `Set_selection_owner -> 0
      | `Selection_window_destroy -> 1
      | `Selection_client_close -> 2
    in
    int_of_mask to_bit

  type selection_notify_event = {
    subtype : selection_event_enum;
    window : Xproto.window;
    owner : Xproto.window;
    selection : Xproto.atom;
    timestamp : Xproto.timestamp;
    selection_timestamp : Xproto.timestamp;
  }
  [@@deriving sexp]

  let decode_selection_notify_event buf ~at :
      (selection_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* subtype, at =
      decode_enum decode_uint8 identity selection_event_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* owner, at = Xproto.decode_window buf ~at in
    let* selection, at = Xproto.decode_atom buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* selection_timestamp, at = Xproto.decode_timestamp buf ~at in
    let at = at + 8 in
    ignore orig;
    Some
      ({ subtype; window; owner; selection; timestamp; selection_timestamp }, at)

  let encode_select_selection_input ~(window : Xproto.window)
      ~(selection : Xproto.atom) ~(event_mask : selection_event_mask) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf selection;
    encode_mask encode_int32 identity selection_event_mask_int_of_mask buf
      event_mask;
    (* write request length *)
    encode_request_length buf

  type cursor_notify_enum = [ `Display_cursor ] [@@deriving sexp]

  let cursor_notify_enum_of_int : int -> [> cursor_notify_enum ] option =
    function
    | 0 -> Some `Display_cursor
    | n ->
        Printf.printf "unknown cursor_notify_enum: %d\n" n;
        None

  let cursor_notify_int_of_enum : cursor_notify_enum -> int = function
    | `Display_cursor -> 0

  type cursor_notify_mask = [ `Display_cursor ] list [@@deriving sexp]

  let cursor_notify_mask_mask_of_int64 mask : cursor_notify_mask option =
    let of_int = function 0 -> Some `Display_cursor | _ -> None in
    mask_of_int of_int mask

  let cursor_notify_mask_int_of_mask : cursor_notify_mask -> int =
    let to_bit = function `Display_cursor -> 0 in
    int_of_mask to_bit

  type cursor_notify_event = {
    subtype : cursor_notify_enum;
    window : Xproto.window;
    cursor_serial : int;
    timestamp : Xproto.timestamp;
    name : Xproto.atom_enum alt_enum;
  }
  [@@deriving sexp]

  let decode_cursor_notify_event buf ~at : (cursor_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* subtype, at =
      decode_enum decode_uint8 identity cursor_notify_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* cursor_serial, at = decode_int32 buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* name, at =
      decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf
        ~at
    in
    let at = at + 12 in
    ignore orig;
    Some ({ subtype; window; cursor_serial; timestamp; name }, at)

  let encode_select_cursor_input ~(window : Xproto.window)
      ~(event_mask : cursor_notify_mask) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mask encode_int32 identity cursor_notify_mask_int_of_mask buf
      event_mask;
    (* write request length *)
    encode_request_length buf

  type get_cursor_image_reply = {
    x : int;
    y : int;
    width : int;
    height : int;
    xhot : int;
    yhot : int;
    cursor_serial : int;
    cursor_image : int list;
  }
  [@@deriving sexp]

  let encode_get_cursor_image buf =
    (* opcode *)
    encode_uint8 buf 4;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_cursor_image_reply length buf ~at :
      (get_cursor_image_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* xhot, at = decode_uint16 buf ~at in
    let* yhot, at = decode_uint16 buf ~at in
    let* cursor_serial, at = decode_int32 buf ~at in
    let at = at + 8 in
    let* cursor_image, at =
      let length = width * height in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ x; y; width; height; xhot; yhot; cursor_serial; cursor_image }, at)

  type region = xid [@@deriving sexp]

  let decode_region = decode_xid
  let encode_region = encode_xid

  type bad_region_error = unit [@@deriving sexp]
  type region_enum = [ `None ] [@@deriving sexp]

  let region_enum_of_int : int -> [> region_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown region_enum: %d\n" n;
        None

  let region_int_of_enum : region_enum -> int = function `None -> 0

  let encode_create_region ~(region : region)
      ~(rectangles : Xproto.rectangle list) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    encode_list Xproto.encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_create_region_from_bitmap ~(region : region)
      ~(bitmap : Xproto.pixmap) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_pixmap buf bitmap;
    (* write request length *)
    encode_request_length buf

  let encode_create_region_from_window ~(region : region)
      ~(window : Xproto.window) ~(kind : Shape.sk_enum) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf window;
    encode_enum Shape.encode_kind identity Shape.sk_int_of_enum buf kind;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_create_region_from_gc ~(region : region) ~(gc : Xproto.gcontext)
      buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_gcontext buf gc;
    (* write request length *)
    encode_request_length buf

  let encode_create_region_from_picture ~(region : region)
      ~(picture : Render.picture) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    Render.encode_picture buf picture;
    (* write request length *)
    encode_request_length buf

  let encode_destroy_region ~(region : region) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_set_region ~(region : region) ~(rectangles : Xproto.rectangle list)
      buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    encode_list Xproto.encode_rectangle buf rectangles;
    (* write request length *)
    encode_request_length buf

  let encode_copy_region ~(source : region) ~(destination : region) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_region buf source;
    (* reserve request length *)
    encode_pad buf 2;
    encode_region buf destination;
    (* write request length *)
    encode_request_length buf

  let encode_union_region ~(source1 : region) ~(source2 : region)
      ~(destination : region) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_region buf source1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_region buf source2;
    encode_region buf destination;
    (* write request length *)
    encode_request_length buf

  let encode_intersect_region ~(source1 : region) ~(source2 : region)
      ~(destination : region) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_region buf source1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_region buf source2;
    encode_region buf destination;
    (* write request length *)
    encode_request_length buf

  let encode_subtract_region ~(source1 : region) ~(source2 : region)
      ~(destination : region) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_region buf source1;
    (* reserve request length *)
    encode_pad buf 2;
    encode_region buf source2;
    encode_region buf destination;
    (* write request length *)
    encode_request_length buf

  let encode_invert_region ~(source : region) ~(bounds : Xproto.rectangle)
      ~(destination : region) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_region buf source;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_rectangle buf bounds;
    encode_region buf destination;
    (* write request length *)
    encode_request_length buf

  let encode_translate_region ~(region : region) ~(dx : int) ~(dy : int) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf dx;
    encode_int16 buf dy;
    (* write request length *)
    encode_request_length buf

  let encode_region_extents ~(source : region) ~(destination : region) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_region buf source;
    (* reserve request length *)
    encode_pad buf 2;
    encode_region buf destination;
    (* write request length *)
    encode_request_length buf

  type fetch_region_reply = {
    extents : Xproto.rectangle;
    rectangles : Xproto.rectangle list;
  }
  [@@deriving sexp]

  let encode_fetch_region ~(region : region) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_fetch_region_reply length buf ~at :
      (fetch_region_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* extents, at = Xproto.decode_rectangle buf ~at in
    let at = at + 16 in
    let* rectangles, at =
      let length = length / 2 in
      decode_list Xproto.decode_rectangle length buf ~at
    in
    ignore orig;
    Some ({ extents; rectangles }, at)

  let encode_set_gc_clip_region ~(gc : Xproto.gcontext)
      ~(region : region_enum alt_enum) ~(x_origin : int) ~(y_origin : int) buf =
    (* opcode *)
    encode_uint8 buf 20;
    Xproto.encode_gcontext buf gc;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_region identity region_int_of_enum buf region;
    encode_int16 buf x_origin;
    encode_int16 buf y_origin;
    (* write request length *)
    encode_request_length buf

  let encode_set_window_shape_region ~(dest : Xproto.window)
      ~(dest_kind : Shape.sk_enum) ~(x_offset : int) ~(y_offset : int)
      ~(region : region_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 21;
    Xproto.encode_window buf dest;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum Shape.encode_kind identity Shape.sk_int_of_enum buf dest_kind;
    encode_pad buf 3;
    encode_int16 buf x_offset;
    encode_int16 buf y_offset;
    encode_alt_enum encode_region identity region_int_of_enum buf region;
    (* write request length *)
    encode_request_length buf

  let encode_set_picture_clip_region ~(picture : Render.picture)
      ~(region : region_enum alt_enum) ~(x_origin : int) ~(y_origin : int) buf =
    (* opcode *)
    encode_uint8 buf 22;
    Render.encode_picture buf picture;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_region identity region_int_of_enum buf region;
    encode_int16 buf x_origin;
    encode_int16 buf y_origin;
    (* write request length *)
    encode_request_length buf

  let encode_set_cursor_name ~(cursor : Xproto.cursor) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 23;
    Xproto.encode_cursor buf cursor;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  type get_cursor_name_reply = {
    atom : Xproto.atom_enum alt_enum;
    name : string;
  }
  [@@deriving sexp]

  let encode_get_cursor_name ~(cursor : Xproto.cursor) buf =
    (* opcode *)
    encode_uint8 buf 24;
    Xproto.encode_cursor buf cursor;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_cursor_name_reply length buf ~at :
      (get_cursor_name_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* atom, at =
      decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf
        ~at
    in
    let* nbytes, at = decode_uint16 buf ~at in
    let nbytes = nbytes in
    let at = at + 18 in
    let* name, at = decode_string nbytes buf ~at in
    ignore orig;
    Some ({ atom; name }, at)

  type get_cursor_image_and_name_reply = {
    x : int;
    y : int;
    width : int;
    height : int;
    xhot : int;
    yhot : int;
    cursor_serial : int;
    cursor_atom : Xproto.atom_enum alt_enum;
    cursor_image : int list;
    name : string;
  }
  [@@deriving sexp]

  let encode_get_cursor_image_and_name buf =
    (* opcode *)
    encode_uint8 buf 25;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_cursor_image_and_name_reply length buf ~at :
      (get_cursor_image_and_name_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* xhot, at = decode_uint16 buf ~at in
    let* yhot, at = decode_uint16 buf ~at in
    let* cursor_serial, at = decode_int32 buf ~at in
    let* cursor_atom, at =
      decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf
        ~at
    in
    let* nbytes, at = decode_uint16 buf ~at in
    let nbytes = nbytes in
    let at = at + 2 in
    let* cursor_image, at =
      let length = width * height in
      decode_list decode_int32 length buf ~at
    in
    let* name, at = decode_string nbytes buf ~at in
    ignore orig;
    Some
      ( {
          x;
          y;
          width;
          height;
          xhot;
          yhot;
          cursor_serial;
          cursor_atom;
          cursor_image;
          name;
        },
        at )

  let encode_change_cursor ~(source : Xproto.cursor)
      ~(destination : Xproto.cursor) buf =
    (* opcode *)
    encode_uint8 buf 26;
    Xproto.encode_cursor buf source;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_cursor buf destination;
    (* write request length *)
    encode_request_length buf

  let encode_change_cursor_by_name ~(src : Xproto.cursor) ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 27;
    Xproto.encode_cursor buf src;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity (String.length name));
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let encode_expand_region ~(source : region) ~(destination : region)
      ~(left : int) ~(right : int) ~(top : int) ~(bottom : int) buf =
    (* opcode *)
    encode_uint8 buf 28;
    encode_region buf source;
    (* reserve request length *)
    encode_pad buf 2;
    encode_region buf destination;
    encode_uint16 buf left;
    encode_uint16 buf right;
    encode_uint16 buf top;
    encode_uint16 buf bottom;
    (* write request length *)
    encode_request_length buf

  let encode_hide_cursor ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 29;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_show_cursor ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 30;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type barrier = xid [@@deriving sexp]

  let decode_barrier = decode_xid
  let encode_barrier = encode_xid

  type barrier_directions_mask =
    [ `Positive_x | `Positive_y | `Negative_x | `Negative_y ] list
  [@@deriving sexp]

  let barrier_directions_mask_of_int64 mask : barrier_directions_mask option =
    let of_int = function
      | 0 -> Some `Positive_x
      | 1 -> Some `Positive_y
      | 2 -> Some `Negative_x
      | 3 -> Some `Negative_y
      | _ -> None
    in
    mask_of_int of_int mask

  let barrier_directions_int_of_mask : barrier_directions_mask -> int =
    let to_bit = function
      | `Positive_x -> 0
      | `Positive_y -> 1
      | `Negative_x -> 2
      | `Negative_y -> 3
    in
    int_of_mask to_bit

  let encode_create_pointer_barrier ~(barrier : barrier)
      ~(window : Xproto.window) ~(x1 : int) ~(y1 : int) ~(x2 : int) ~(y2 : int)
      ~(directions : barrier_directions_mask) ~(devices : int list) buf =
    (* opcode *)
    encode_uint8 buf 31;
    encode_barrier buf barrier;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf window;
    encode_uint16 buf x1;
    encode_uint16 buf y1;
    encode_uint16 buf x2;
    encode_uint16 buf y2;
    encode_mask encode_int32 identity barrier_directions_int_of_mask buf
      directions;
    encode_pad buf 2;
    encode_uint16 buf (identity ((* Parsetree.Card16 *) List.length devices));
    encode_list encode_uint16 buf devices;
    (* write request length *)
    encode_request_length buf

  let encode_delete_pointer_barrier ~(barrier : barrier) buf =
    (* opcode *)
    encode_uint8 buf 32;
    encode_barrier buf barrier;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf
end

module Composite = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type redirect_enum = [ `Automatic | `Manual ] [@@deriving sexp]

  let redirect_enum_of_int : int -> [> redirect_enum ] option = function
    | 0 -> Some `Automatic
    | 1 -> Some `Manual
    | n ->
        Printf.printf "unknown redirect_enum: %d\n" n;
        None

  let redirect_int_of_enum : redirect_enum -> int = function
    | `Automatic -> 0
    | `Manual -> 1

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  let encode_redirect_window ~(window : Xproto.window) ~(update : redirect_enum)
      buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity redirect_int_of_enum buf update;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_redirect_subwindows ~(window : Xproto.window)
      ~(update : redirect_enum) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity redirect_int_of_enum buf update;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_unredirect_window ~(window : Xproto.window)
      ~(update : redirect_enum) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity redirect_int_of_enum buf update;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_unredirect_subwindows ~(window : Xproto.window)
      ~(update : redirect_enum) buf =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity redirect_int_of_enum buf update;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_create_region_from_border_clip ~(region : Xfixes.region)
      ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 5;
    Xfixes.encode_region buf region;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf window;
    (* write request length *)
    encode_request_length buf

  let encode_name_window_pixmap ~(window : Xproto.window)
      ~(pixmap : Xproto.pixmap) buf =
    (* opcode *)
    encode_uint8 buf 6;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_pixmap buf pixmap;
    (* write request length *)
    encode_request_length buf

  type get_overlay_window_reply = Xproto.window [@@deriving sexp]

  let encode_get_overlay_window ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_overlay_window_reply length buf ~at :
      (get_overlay_window_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* overlay_win, at = Xproto.decode_window buf ~at in
    let at = at + 20 in
    ignore orig;
    Some (overlay_win, at)

  let encode_release_overlay_window ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf
end

module Damage = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type damage = xid [@@deriving sexp]

  let decode_damage = decode_xid
  let encode_damage = encode_xid

  type report_level_enum =
    [ `Raw_rectangles | `Delta_rectangles | `Bounding_box | `Non_empty ]
  [@@deriving sexp]

  let report_level_enum_of_int : int -> [> report_level_enum ] option = function
    | 0 -> Some `Raw_rectangles
    | 1 -> Some `Delta_rectangles
    | 2 -> Some `Bounding_box
    | 3 -> Some `Non_empty
    | n ->
        Printf.printf "unknown report_level_enum: %d\n" n;
        None

  let report_level_int_of_enum : report_level_enum -> int = function
    | `Raw_rectangles -> 0
    | `Delta_rectangles -> 1
    | `Bounding_box -> 2
    | `Non_empty -> 3

  type bad_damage_error = unit [@@deriving sexp]

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  let encode_create ~(damage : damage) ~(drawable : Xproto.drawable)
      ~(level : report_level_enum) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_damage buf damage;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    encode_enum encode_uint8 identity report_level_int_of_enum buf level;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_destroy ~(damage : damage) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_damage buf damage;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_subtract ~(damage : damage) ~(repair : Xfixes.region_enum alt_enum)
      ~(parts : Xfixes.region_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_damage buf damage;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xfixes.encode_region identity Xfixes.region_int_of_enum buf
      repair;
    encode_alt_enum Xfixes.encode_region identity Xfixes.region_int_of_enum buf
      parts;
    (* write request length *)
    encode_request_length buf

  let encode_add ~(drawable : Xproto.drawable) ~(region : Xfixes.region) buf =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    Xfixes.encode_region buf region;
    (* write request length *)
    encode_request_length buf

  type notify_event = {
    level : report_level_enum;
    drawable : Xproto.drawable;
    damage : damage;
    timestamp : Xproto.timestamp;
    area : Xproto.rectangle;
    geometry : Xproto.rectangle;
  }
  [@@deriving sexp]

  let decode_notify_event buf ~at : (notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* level, at =
      decode_enum decode_uint8 identity report_level_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* drawable, at = Xproto.decode_drawable buf ~at in
    let* damage, at = decode_damage buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* area, at = Xproto.decode_rectangle buf ~at in
    let* geometry, at = Xproto.decode_rectangle buf ~at in
    ignore orig;
    Some ({ level; drawable; damage; timestamp; area; geometry }, at)
end

module Dpms = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type get_version_reply = {
    server_major_version : int;
    server_minor_version : int;
  }
  [@@deriving sexp]

  let encode_get_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint16 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_get_version_reply length buf ~at : (get_version_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* server_major_version, at = decode_uint16 buf ~at in
    let* server_minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ server_major_version; server_minor_version }, at)

  type capable_reply = bool [@@deriving sexp]

  let encode_capable buf =
    (* opcode *)
    encode_uint8 buf 1;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_capable_reply length buf ~at : (capable_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* capable, at = decode_bool buf ~at in
    let at = at + 23 in
    ignore orig;
    Some (capable, at)

  type get_timeouts_reply = {
    standby_timeout : int;
    suspend_timeout : int;
    off_timeout : int;
  }
  [@@deriving sexp]

  let encode_get_timeouts buf =
    (* opcode *)
    encode_uint8 buf 2;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_timeouts_reply length buf ~at :
      (get_timeouts_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* standby_timeout, at = decode_uint16 buf ~at in
    let* suspend_timeout, at = decode_uint16 buf ~at in
    let* off_timeout, at = decode_uint16 buf ~at in
    let at = at + 18 in
    ignore orig;
    Some ({ standby_timeout; suspend_timeout; off_timeout }, at)

  let encode_set_timeouts ~(standby_timeout : int) ~(suspend_timeout : int)
      ~(off_timeout : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_uint16 buf standby_timeout;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf suspend_timeout;
    encode_uint16 buf off_timeout;
    (* write request length *)
    encode_request_length buf

  let encode_enable buf =
    (* opcode *)
    encode_uint8 buf 4;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_disable buf =
    (* opcode *)
    encode_uint8 buf 5;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type dpms_mode_enum = [ `On | `Standby | `Suspend | `Off ] [@@deriving sexp]

  let dpms_mode_enum_of_int : int -> [> dpms_mode_enum ] option = function
    | 0 -> Some `On
    | 1 -> Some `Standby
    | 2 -> Some `Suspend
    | 3 -> Some `Off
    | n ->
        Printf.printf "unknown dpms_mode_enum: %d\n" n;
        None

  let dpms_mode_int_of_enum : dpms_mode_enum -> int = function
    | `On -> 0
    | `Standby -> 1
    | `Suspend -> 2
    | `Off -> 3

  let encode_force_level ~(power_level : dpms_mode_enum) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_enum encode_uint16 identity dpms_mode_int_of_enum buf power_level;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type info_reply = { power_level : dpms_mode_enum; state : bool }
  [@@deriving sexp]

  let encode_info buf =
    (* opcode *)
    encode_uint8 buf 7;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_info_reply length buf ~at : (info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* power_level, at =
      decode_enum decode_uint16 identity dpms_mode_enum_of_int buf ~at
    in
    let* state, at = decode_bool buf ~at in
    let at = at + 21 in
    ignore orig;
    Some ({ power_level; state }, at)
end

module Dri2 = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type attachment_enum =
    [ `Buffer_front_left
    | `Buffer_back_left
    | `Buffer_front_right
    | `Buffer_back_right
    | `Buffer_depth
    | `Buffer_stencil
    | `Buffer_accum
    | `Buffer_fake_front_left
    | `Buffer_fake_front_right
    | `Buffer_depth_stencil
    | `Buffer_hiz ]
  [@@deriving sexp]

  let attachment_enum_of_int : int -> [> attachment_enum ] option = function
    | 0 -> Some `Buffer_front_left
    | 1 -> Some `Buffer_back_left
    | 2 -> Some `Buffer_front_right
    | 3 -> Some `Buffer_back_right
    | 4 -> Some `Buffer_depth
    | 5 -> Some `Buffer_stencil
    | 6 -> Some `Buffer_accum
    | 7 -> Some `Buffer_fake_front_left
    | 8 -> Some `Buffer_fake_front_right
    | 9 -> Some `Buffer_depth_stencil
    | 10 -> Some `Buffer_hiz
    | n ->
        Printf.printf "unknown attachment_enum: %d\n" n;
        None

  let attachment_int_of_enum : attachment_enum -> int = function
    | `Buffer_front_left -> 0
    | `Buffer_back_left -> 1
    | `Buffer_front_right -> 2
    | `Buffer_back_right -> 3
    | `Buffer_depth -> 4
    | `Buffer_stencil -> 5
    | `Buffer_accum -> 6
    | `Buffer_fake_front_left -> 7
    | `Buffer_fake_front_right -> 8
    | `Buffer_depth_stencil -> 9
    | `Buffer_hiz -> 10

  type driver_type_enum = [ `Dri | `Vdpau ] [@@deriving sexp]

  let driver_type_enum_of_int : int -> [> driver_type_enum ] option = function
    | 0 -> Some `Dri
    | 1 -> Some `Vdpau
    | n ->
        Printf.printf "unknown driver_type_enum: %d\n" n;
        None

  let driver_type_int_of_enum : driver_type_enum -> int = function
    | `Dri -> 0
    | `Vdpau -> 1

  type event_type_enum = [ `Exchange_complete | `Blit_complete | `Flip_complete ]
  [@@deriving sexp]

  let event_type_enum_of_int : int -> [> event_type_enum ] option = function
    | 1 -> Some `Exchange_complete
    | 2 -> Some `Blit_complete
    | 3 -> Some `Flip_complete
    | n ->
        Printf.printf "unknown event_type_enum: %d\n" n;
        None

  let event_type_int_of_enum : event_type_enum -> int = function
    | `Exchange_complete -> 1
    | `Blit_complete -> 2
    | `Flip_complete -> 3

  type dri2_buffer = {
    attachment : attachment_enum;
    name : int;
    pitch : int;
    cpp : int;
    flags : int;
  }
  [@@deriving sexp]

  let decode_dri2_buffer buf ~at : (dri2_buffer * int) option =
    let orig = at in
    let* attachment, at =
      decode_enum decode_int32 identity attachment_enum_of_int buf ~at
    in
    let* name, at = decode_int32 buf ~at in
    let* pitch, at = decode_int32 buf ~at in
    let* cpp, at = decode_int32 buf ~at in
    let* flags, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ attachment; name; pitch; cpp; flags }, at)

  let encode_dri2_buffer buf (v : dri2_buffer) =
    encode_enum encode_int32 identity attachment_int_of_enum buf v.attachment;
    encode_int32 buf v.name;
    encode_int32 buf v.pitch;
    encode_int32 buf v.cpp;
    encode_int32 buf v.flags;
    ()

  type attach_format = { attachment : attachment_enum; format : int }
  [@@deriving sexp]

  let decode_attach_format buf ~at : (attach_format * int) option =
    let orig = at in
    let* attachment, at =
      decode_enum decode_int32 identity attachment_enum_of_int buf ~at
    in
    let* format, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ attachment; format }, at)

  let encode_attach_format buf (v : attach_format) =
    encode_enum encode_int32 identity attachment_int_of_enum buf v.attachment;
    encode_int32 buf v.format;
    ()

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type connect_reply = {
    driver_name : string;
    alignment_pad : string;
    device_name : string;
  }
  [@@deriving sexp]

  let encode_connect ~(window : Xproto.window) ~(driver_type : driver_type_enum)
      buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_int32 identity driver_type_int_of_enum buf driver_type;
    (* write request length *)
    encode_request_length buf

  let decode_connect_reply length buf ~at : (connect_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* driver_name_length, at = decode_int32 buf ~at in
    let driver_name_length = driver_name_length in
    let* device_name_length, at = decode_int32 buf ~at in
    let device_name_length = device_name_length in
    let at = at + 16 in
    let* driver_name, at = decode_string driver_name_length buf ~at in
    let* alignment_pad, at =
      let length =
        ((driver_name_length + 3) land lnot 3) - driver_name_length
      in
      decode_string length buf ~at
    in
    let* device_name, at = decode_string device_name_length buf ~at in
    ignore orig;
    Some ({ driver_name; alignment_pad; device_name }, at)

  type authenticate_reply = int [@@deriving sexp]

  let encode_authenticate ~(window : Xproto.window) ~(magic : int) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf magic;
    (* write request length *)
    encode_request_length buf

  let decode_authenticate_reply length buf ~at :
      (authenticate_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* authenticated, at = decode_int32 buf ~at in
    ignore orig;
    Some (authenticated, at)

  let encode_create_drawable ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_destroy_drawable ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type get_buffers_reply = {
    width : int;
    height : int;
    buffers : dri2_buffer list;
  }
  [@@deriving sexp]

  let encode_get_buffers ~(drawable : Xproto.drawable) ~(attachments : int list)
      buf =
    (* opcode *)
    encode_uint8 buf 5;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attachments));
    encode_list encode_int32 buf attachments;
    (* write request length *)
    encode_request_length buf

  let decode_get_buffers_reply length buf ~at : (get_buffers_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let* count, at = decode_int32 buf ~at in
    let count = count in
    let at = at + 12 in
    let* buffers, at = decode_list decode_dri2_buffer count buf ~at in
    ignore orig;
    Some ({ width; height; buffers }, at)

  type copy_region_reply = unit [@@deriving sexp]

  let encode_copy_region ~(drawable : Xproto.drawable) ~(region : int)
      ~(dest : int) ~(src : int) buf =
    (* opcode *)
    encode_uint8 buf 6;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf region;
    encode_int32 buf dest;
    encode_int32 buf src;
    (* write request length *)
    encode_request_length buf

  let decode_copy_region_reply length buf ~at : (copy_region_reply * int) option
      =
    ignore length;
    ignore buf;
    Some ((), at)

  type get_buffers_with_format_reply = {
    width : int;
    height : int;
    buffers : dri2_buffer list;
  }
  [@@deriving sexp]

  let encode_get_buffers_with_format ~(drawable : Xproto.drawable)
      ~(attachments : attach_format list) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* invalid_argument *) List.length attachments));
    encode_list encode_attach_format buf attachments;
    (* write request length *)
    encode_request_length buf

  let decode_get_buffers_with_format_reply length buf ~at :
      (get_buffers_with_format_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let* count, at = decode_int32 buf ~at in
    let count = count in
    let at = at + 12 in
    let* buffers, at = decode_list decode_dri2_buffer count buf ~at in
    ignore orig;
    Some ({ width; height; buffers }, at)

  type swap_buffers_reply = { swap_hi : int; swap_lo : int } [@@deriving sexp]

  let encode_swap_buffers ~(drawable : Xproto.drawable) ~(target_msc_hi : int)
      ~(target_msc_lo : int) ~(divisor_hi : int) ~(divisor_lo : int)
      ~(remainder_hi : int) ~(remainder_lo : int) buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target_msc_hi;
    encode_int32 buf target_msc_lo;
    encode_int32 buf divisor_hi;
    encode_int32 buf divisor_lo;
    encode_int32 buf remainder_hi;
    encode_int32 buf remainder_lo;
    (* write request length *)
    encode_request_length buf

  let decode_swap_buffers_reply length buf ~at :
      (swap_buffers_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* swap_hi, at = decode_int32 buf ~at in
    let* swap_lo, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ swap_hi; swap_lo }, at)

  type get_msc_reply = {
    ust_hi : int;
    ust_lo : int;
    msc_hi : int;
    msc_lo : int;
    sbc_hi : int;
    sbc_lo : int;
  }
  [@@deriving sexp]

  let encode_get_msc ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 9;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_msc_reply length buf ~at : (get_msc_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ust_hi, at = decode_int32 buf ~at in
    let* ust_lo, at = decode_int32 buf ~at in
    let* msc_hi, at = decode_int32 buf ~at in
    let* msc_lo, at = decode_int32 buf ~at in
    let* sbc_hi, at = decode_int32 buf ~at in
    let* sbc_lo, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ ust_hi; ust_lo; msc_hi; msc_lo; sbc_hi; sbc_lo }, at)

  type wait_msc_reply = {
    ust_hi : int;
    ust_lo : int;
    msc_hi : int;
    msc_lo : int;
    sbc_hi : int;
    sbc_lo : int;
  }
  [@@deriving sexp]

  let encode_wait_msc ~(drawable : Xproto.drawable) ~(target_msc_hi : int)
      ~(target_msc_lo : int) ~(divisor_hi : int) ~(divisor_lo : int)
      ~(remainder_hi : int) ~(remainder_lo : int) buf =
    (* opcode *)
    encode_uint8 buf 10;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target_msc_hi;
    encode_int32 buf target_msc_lo;
    encode_int32 buf divisor_hi;
    encode_int32 buf divisor_lo;
    encode_int32 buf remainder_hi;
    encode_int32 buf remainder_lo;
    (* write request length *)
    encode_request_length buf

  let decode_wait_msc_reply length buf ~at : (wait_msc_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ust_hi, at = decode_int32 buf ~at in
    let* ust_lo, at = decode_int32 buf ~at in
    let* msc_hi, at = decode_int32 buf ~at in
    let* msc_lo, at = decode_int32 buf ~at in
    let* sbc_hi, at = decode_int32 buf ~at in
    let* sbc_lo, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ ust_hi; ust_lo; msc_hi; msc_lo; sbc_hi; sbc_lo }, at)

  type wait_sbc_reply = {
    ust_hi : int;
    ust_lo : int;
    msc_hi : int;
    msc_lo : int;
    sbc_hi : int;
    sbc_lo : int;
  }
  [@@deriving sexp]

  let encode_wait_sbc ~(drawable : Xproto.drawable) ~(target_sbc_hi : int)
      ~(target_sbc_lo : int) buf =
    (* opcode *)
    encode_uint8 buf 11;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target_sbc_hi;
    encode_int32 buf target_sbc_lo;
    (* write request length *)
    encode_request_length buf

  let decode_wait_sbc_reply length buf ~at : (wait_sbc_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ust_hi, at = decode_int32 buf ~at in
    let* ust_lo, at = decode_int32 buf ~at in
    let* msc_hi, at = decode_int32 buf ~at in
    let* msc_lo, at = decode_int32 buf ~at in
    let* sbc_hi, at = decode_int32 buf ~at in
    let* sbc_lo, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ ust_hi; ust_lo; msc_hi; msc_lo; sbc_hi; sbc_lo }, at)

  let encode_swap_interval ~(drawable : Xproto.drawable) ~(interval : int) buf =
    (* opcode *)
    encode_uint8 buf 12;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf interval;
    (* write request length *)
    encode_request_length buf

  type get_param_reply = {
    is_param_recognized : bool;
    value_hi : int;
    value_lo : int;
  }
  [@@deriving sexp]

  let encode_get_param ~(drawable : Xproto.drawable) ~(param : int) buf =
    (* opcode *)
    encode_uint8 buf 13;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf param;
    (* write request length *)
    encode_request_length buf

  let decode_get_param_reply length buf ~at : (get_param_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* is_param_recognized, at = decode_bool buf ~at in
    let at = at + 6 in
    let* value_hi, at = decode_int32 buf ~at in
    let* value_lo, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ is_param_recognized; value_hi; value_lo }, at)

  type buffer_swap_complete_event = {
    event_type : event_type_enum;
    drawable : Xproto.drawable;
    ust_hi : int;
    ust_lo : int;
    msc_hi : int;
    msc_lo : int;
    sbc : int;
  }
  [@@deriving sexp]

  let decode_buffer_swap_complete_event buf ~at :
      (buffer_swap_complete_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event_type, at =
      decode_enum decode_uint16 identity event_type_enum_of_int buf ~at
    in
    let at = at + 2 in
    let* drawable, at = Xproto.decode_drawable buf ~at in
    let* ust_hi, at = decode_int32 buf ~at in
    let* ust_lo, at = decode_int32 buf ~at in
    let* msc_hi, at = decode_int32 buf ~at in
    let* msc_lo, at = decode_int32 buf ~at in
    let* sbc, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ event_type; drawable; ust_hi; ust_lo; msc_hi; msc_lo; sbc }, at)

  type invalidate_buffers_event = Xproto.drawable [@@deriving sexp]

  let decode_invalidate_buffers_event buf ~at :
      (invalidate_buffers_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* drawable, at = Xproto.decode_drawable buf ~at in
    ignore orig;
    Some (drawable, at)
end

module Dri3 = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type open_reply = { nfd : int; device_fd : Unix.file_descr } [@@deriving sexp]

  let encode_open ~(drawable : Xproto.drawable) ~(provider : int) buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf provider;
    (* write request length *)
    encode_request_length buf

  let decode_open_reply length buf ~at : (open_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* nfd, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* device_fd, at = decode_file_descr buf ~at in
    let at = at + 24 in
    ignore orig;
    Some ({ nfd; device_fd }, at)

  let encode_pixmap_from_buffer ~(pixmap : Xproto.pixmap)
      ~(drawable : Xproto.drawable) ~(size : int) ~(width : int) ~(height : int)
      ~(stride : int) ~(depth : int) ~(bpp : int) ~(pixmap_fd : Unix.file_descr)
      buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_pixmap buf pixmap;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    encode_int32 buf size;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_uint16 buf stride;
    encode_uint8 buf depth;
    encode_uint8 buf bpp;
    encode_file_descriptor buf pixmap_fd;
    (* write request length *)
    encode_request_length buf

  type buffer_from_pixmap_reply = {
    nfd : int;
    size : int;
    width : int;
    height : int;
    stride : int;
    depth : int;
    bpp : int;
    pixmap_fd : Unix.file_descr;
  }
  [@@deriving sexp]

  let encode_buffer_from_pixmap ~(pixmap : Xproto.pixmap) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_pixmap buf pixmap;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_buffer_from_pixmap_reply length buf ~at :
      (buffer_from_pixmap_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* nfd, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* size, at = decode_int32 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* stride, at = decode_uint16 buf ~at in
    let* depth, at = decode_uint8 buf ~at in
    let* bpp, at = decode_uint8 buf ~at in
    let* pixmap_fd, at = decode_file_descr buf ~at in
    let at = at + 12 in
    ignore orig;
    Some ({ nfd; size; width; height; stride; depth; bpp; pixmap_fd }, at)

  let encode_fence_from_fd ~(drawable : Xproto.drawable) ~(fence : int)
      ~(initially_triggered : bool) ~(fence_fd : Unix.file_descr) buf =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf fence;
    encode_bool buf initially_triggered;
    encode_pad buf 3;
    encode_file_descriptor buf fence_fd;
    (* write request length *)
    encode_request_length buf

  type fd_from_fence_reply = { nfd : int; fence_fd : Unix.file_descr }
  [@@deriving sexp]

  let encode_fd_from_fence ~(drawable : Xproto.drawable) ~(fence : int) buf =
    (* opcode *)
    encode_uint8 buf 5;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf fence;
    (* write request length *)
    encode_request_length buf

  let decode_fd_from_fence_reply length buf ~at :
      (fd_from_fence_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* nfd, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* fence_fd, at = decode_file_descr buf ~at in
    let at = at + 24 in
    ignore orig;
    Some ({ nfd; fence_fd }, at)

  type get_supported_modifiers_reply = {
    window_modifiers : int64 list;
    screen_modifiers : int64 list;
  }
  [@@deriving sexp]

  let encode_get_supported_modifiers ~(window : int) ~(depth : int) ~(bpp : int)
      buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_int32 buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf depth;
    encode_uint8 buf bpp;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_supported_modifiers_reply length buf ~at :
      (get_supported_modifiers_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_window_modifiers, at = decode_int32 buf ~at in
    let num_window_modifiers = num_window_modifiers in
    let* num_screen_modifiers, at = decode_int32 buf ~at in
    let num_screen_modifiers = num_screen_modifiers in
    let at = at + 16 in
    let* window_modifiers, at =
      decode_list decode_int64 num_window_modifiers buf ~at
    in
    let* screen_modifiers, at =
      decode_list decode_int64 num_screen_modifiers buf ~at
    in
    ignore orig;
    Some ({ window_modifiers; screen_modifiers }, at)

  let encode_pixmap_from_buffers ~(pixmap : Xproto.pixmap)
      ~(window : Xproto.window) ~(width : int) ~(height : int) ~(stride0 : int)
      ~(offset0 : int) ~(stride1 : int) ~(offset1 : int) ~(stride2 : int)
      ~(offset2 : int) ~(stride3 : int) ~(offset3 : int) ~(depth : int)
      ~(bpp : int) ~(modifier : int64) ~(buffers : Unix.file_descr list) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_pixmap buf pixmap;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf window;
    encode_uint8 buf (identity ((* Parsetree.Fd *) List.length buffers));
    encode_pad buf 3;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int32 buf stride0;
    encode_int32 buf offset0;
    encode_int32 buf stride1;
    encode_int32 buf offset1;
    encode_int32 buf stride2;
    encode_int32 buf offset2;
    encode_int32 buf stride3;
    encode_int32 buf offset3;
    encode_uint8 buf depth;
    encode_uint8 buf bpp;
    encode_pad buf 2;
    encode_int64 buf modifier;
    encode_list encode_file_descr buf buffers;
    (* write request length *)
    encode_request_length buf

  type buffers_from_pixmap_reply = {
    width : int;
    height : int;
    modifier : int64;
    depth : int;
    bpp : int;
    strides : int list;
    offsets : int list;
    buffers : Unix.file_descr list;
  }
  [@@deriving sexp]

  let encode_buffers_from_pixmap ~(pixmap : Xproto.pixmap) buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xproto.encode_pixmap buf pixmap;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_buffers_from_pixmap_reply length buf ~at :
      (buffers_from_pixmap_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* nfd, at = decode_uint8 buf ~at in
    let nfd = nfd in
    let at = at + 6 in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let at = at + 4 in
    let* modifier, at = decode_int64 buf ~at in
    let* depth, at = decode_uint8 buf ~at in
    let* bpp, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* strides, at = decode_list decode_int32 nfd buf ~at in
    let* offsets, at = decode_list decode_int32 nfd buf ~at in
    let* buffers, at = decode_list decode_file_descr nfd buf ~at in
    ignore orig;
    Some ({ width; height; modifier; depth; bpp; strides; offsets; buffers }, at)
end

module Ge = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint16 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ major_version; minor_version }, at)
end

module Glx = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type pixmap = xid [@@deriving sexp]

  let decode_pixmap = decode_xid
  let encode_pixmap = encode_xid

  type context = xid [@@deriving sexp]

  let decode_context = decode_xid
  let encode_context = encode_xid

  type pbuffer = xid [@@deriving sexp]

  let decode_pbuffer = decode_xid
  let encode_pbuffer = encode_xid

  type window = xid [@@deriving sexp]

  let decode_window = decode_xid
  let encode_window = encode_xid

  type fbconfig = xid [@@deriving sexp]

  let decode_fbconfig = decode_xid
  let encode_fbconfig = encode_xid

  type drawable = xid [@@deriving sexp]

  let decode_drawable = decode_xid
  let encode_drawable = encode_xid

  type float32 = float [@@deriving sexp]

  let decode_float32 = decode_float
  let encode_float32 = encode_float

  type float64 = float [@@deriving sexp]

  let decode_float64 = decode_float
  let encode_float64 = encode_float

  type bool32 = int [@@deriving sexp]

  let decode_bool32 = decode_int32
  let encode_bool32 = encode_int32

  type context_tag = int [@@deriving sexp]

  let decode_context_tag = decode_int32
  let encode_context_tag = encode_int32

  type generic_error = {
    bad_value : int;
    minor_opcode : int;
    major_opcode : int;
  }
  [@@deriving sexp]

  type bad_context_error = generic_error [@@deriving sexp]
  type bad_context_state_error = generic_error [@@deriving sexp]
  type bad_drawable_error = generic_error [@@deriving sexp]
  type bad_pixmap_error = generic_error [@@deriving sexp]
  type bad_context_tag_error = generic_error [@@deriving sexp]
  type bad_current_window_error = generic_error [@@deriving sexp]
  type bad_render_request_error = generic_error [@@deriving sexp]
  type bad_large_request_error = generic_error [@@deriving sexp]
  type unsupported_private_request_error = generic_error [@@deriving sexp]
  type bad_fb_config_error = generic_error [@@deriving sexp]
  type bad_pbuffer_error = generic_error [@@deriving sexp]
  type bad_current_drawable_error = generic_error [@@deriving sexp]
  type bad_window_error = generic_error [@@deriving sexp]
  type glx_bad_profile_arb_error = generic_error [@@deriving sexp]

  type pbuffer_clobber_event = {
    event_type : int;
    draw_type : int;
    drawable : drawable;
    b_mask : int;
    aux_buffer : int;
    x : int;
    y : int;
    width : int;
    height : int;
    count : int;
  }
  [@@deriving sexp]

  let decode_pbuffer_clobber_event buf ~at :
      (pbuffer_clobber_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event_type, at = decode_uint16 buf ~at in
    let* draw_type, at = decode_uint16 buf ~at in
    let* drawable, at = decode_drawable buf ~at in
    let* b_mask, at = decode_int32 buf ~at in
    let* aux_buffer, at = decode_uint16 buf ~at in
    let* x, at = decode_uint16 buf ~at in
    let* y, at = decode_uint16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* count, at = decode_uint16 buf ~at in
    let at = at + 4 in
    ignore orig;
    Some
      ( {
          event_type;
          draw_type;
          drawable;
          b_mask;
          aux_buffer;
          x;
          y;
          width;
          height;
          count;
        },
        at )

  type buffer_swap_complete_event = {
    event_type : int;
    drawable : drawable;
    ust_hi : int;
    ust_lo : int;
    msc_hi : int;
    msc_lo : int;
    sbc : int;
  }
  [@@deriving sexp]

  let decode_buffer_swap_complete_event buf ~at :
      (buffer_swap_complete_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event_type, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* drawable, at = decode_drawable buf ~at in
    let* ust_hi, at = decode_int32 buf ~at in
    let* ust_lo, at = decode_int32 buf ~at in
    let* msc_hi, at = decode_int32 buf ~at in
    let* msc_lo, at = decode_int32 buf ~at in
    let* sbc, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ event_type; drawable; ust_hi; ust_lo; msc_hi; msc_lo; sbc }, at)

  type pbcet_enum = [ `Damaged | `Saved ] [@@deriving sexp]

  let pbcet_enum_of_int : int -> [> pbcet_enum ] option = function
    | 32791 -> Some `Damaged
    | 32792 -> Some `Saved
    | n ->
        Printf.printf "unknown pbcet_enum: %d\n" n;
        None

  let pbcet_int_of_enum : pbcet_enum -> int = function
    | `Damaged -> 32791
    | `Saved -> 32792

  type pbcdt_enum = [ `Window | `Pbuffer ] [@@deriving sexp]

  let pbcdt_enum_of_int : int -> [> pbcdt_enum ] option = function
    | 32793 -> Some `Window
    | 32794 -> Some `Pbuffer
    | n ->
        Printf.printf "unknown pbcdt_enum: %d\n" n;
        None

  let pbcdt_int_of_enum : pbcdt_enum -> int = function
    | `Window -> 32793
    | `Pbuffer -> 32794

  let encode_render ~(context_tag : context_tag) ~(data : char list) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_char buf data;
    (* write request length *)
    encode_request_length buf

  let encode_render_large ~(context_tag : context_tag) ~(request_num : int)
      ~(request_total : int) ~(data : char list) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf request_num;
    encode_uint16 buf request_total;
    encode_int32 buf (identity ((* Parsetree.Byte *) List.length data));
    encode_list encode_char buf data;
    (* write request length *)
    encode_request_length buf

  let encode_create_context ~(context : context) ~(visual : Xproto.visualid)
      ~(screen : int) ~(share_list : context) ~(is_direct : bool) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_visualid buf visual;
    encode_int32 buf screen;
    encode_context buf share_list;
    encode_bool buf is_direct;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_destroy_context ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type make_current_reply = context_tag [@@deriving sexp]

  let encode_make_current ~(drawable : drawable) ~(context : context)
      ~(old_context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_context buf context;
    encode_context_tag buf old_context_tag;
    (* write request length *)
    encode_request_length buf

  let decode_make_current_reply length buf ~at :
      (make_current_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_tag, at = decode_context_tag buf ~at in
    let at = at + 20 in
    ignore orig;
    Some (context_tag, at)

  type is_direct_reply = bool [@@deriving sexp]

  let encode_is_direct ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_is_direct_reply length buf ~at : (is_direct_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* is_direct, at = decode_bool buf ~at in
    let at = at + 23 in
    ignore orig;
    Some (is_direct, at)

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  let encode_wait_gl ~(context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_wait_x ~(context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_copy_context ~(src : context) ~(dest : context) ~(mask : int)
      ~(src_context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_context buf src;
    (* reserve request length *)
    encode_pad buf 2;
    encode_context buf dest;
    encode_int32 buf mask;
    encode_context_tag buf src_context_tag;
    (* write request length *)
    encode_request_length buf

  type gc_mask =
    ( [ `Gl_current_bit
      | `Gl_point_bit
      | `Gl_line_bit
      | `Gl_polygon_bit
      | `Gl_polygon_stipple_bit
      | `Gl_pixel_mode_bit
      | `Gl_lighting_bit
      | `Gl_fog_bit
      | `Gl_depth_buffer_bit
      | `Gl_accum_buffer_bit
      | `Gl_stencil_buffer_bit
      | `Gl_viewport_bit
      | `Gl_transform_bit
      | `Gl_enable_bit
      | `Gl_color_buffer_bit
      | `Gl_hint_bit
      | `Gl_eval_bit
      | `Gl_list_bit
      | `Gl_texture_bit
      | `Gl_scissor_bit ]
      list,
      [ `Gl_all_attrib_bits ] )
    mask
  [@@deriving sexp]

  let gc_mask_of_int64 mask : gc_mask option =
    let of_enum = function
      | 16777215L -> Some `Gl_all_attrib_bits
      | _ -> None
    in
    let of_mask = function
      | 0 -> Some `Gl_current_bit
      | 1 -> Some `Gl_point_bit
      | 2 -> Some `Gl_line_bit
      | 3 -> Some `Gl_polygon_bit
      | 4 -> Some `Gl_polygon_stipple_bit
      | 5 -> Some `Gl_pixel_mode_bit
      | 6 -> Some `Gl_lighting_bit
      | 7 -> Some `Gl_fog_bit
      | 8 -> Some `Gl_depth_buffer_bit
      | 9 -> Some `Gl_accum_buffer_bit
      | 10 -> Some `Gl_stencil_buffer_bit
      | 11 -> Some `Gl_viewport_bit
      | 12 -> Some `Gl_transform_bit
      | 13 -> Some `Gl_enable_bit
      | 14 -> Some `Gl_color_buffer_bit
      | 15 -> Some `Gl_hint_bit
      | 16 -> Some `Gl_eval_bit
      | 17 -> Some `Gl_list_bit
      | 18 -> Some `Gl_texture_bit
      | 19 -> Some `Gl_scissor_bit
      | _ -> None
    in
    mask_value_of_int of_mask of_enum mask

  let gc_int_of_mask (mask : gc_mask) : int =
    let to_enum = function `Gl_all_attrib_bits -> 16777215 in
    let to_mask = function
      | `Gl_current_bit -> 0
      | `Gl_point_bit -> 1
      | `Gl_line_bit -> 2
      | `Gl_polygon_bit -> 3
      | `Gl_polygon_stipple_bit -> 4
      | `Gl_pixel_mode_bit -> 5
      | `Gl_lighting_bit -> 6
      | `Gl_fog_bit -> 7
      | `Gl_depth_buffer_bit -> 8
      | `Gl_accum_buffer_bit -> 9
      | `Gl_stencil_buffer_bit -> 10
      | `Gl_viewport_bit -> 11
      | `Gl_transform_bit -> 12
      | `Gl_enable_bit -> 13
      | `Gl_color_buffer_bit -> 14
      | `Gl_hint_bit -> 15
      | `Gl_eval_bit -> 16
      | `Gl_list_bit -> 17
      | `Gl_texture_bit -> 18
      | `Gl_scissor_bit -> 19
    in
    int_of_mask_value to_mask to_enum mask

  let encode_swap_buffers ~(context_tag : context_tag) ~(drawable : drawable)
      buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    (* write request length *)
    encode_request_length buf

  let encode_use_x_font ~(context_tag : context_tag) ~(font : Xproto.font)
      ~(first : int) ~(count : int) ~(list_base : int) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_font buf font;
    encode_int32 buf first;
    encode_int32 buf count;
    encode_int32 buf list_base;
    (* write request length *)
    encode_request_length buf

  let encode_create_glx_pixmap ~(screen : int) ~(visual : Xproto.visualid)
      ~(pixmap : Xproto.pixmap) ~(glx_pixmap : pixmap) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_visualid buf visual;
    Xproto.encode_pixmap buf pixmap;
    encode_pixmap buf glx_pixmap;
    (* write request length *)
    encode_request_length buf

  type get_visual_configs_reply = {
    num_visuals : int;
    num_properties : int;
    property_list : int list;
  }
  [@@deriving sexp]

  let encode_get_visual_configs ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_visual_configs_reply length buf ~at :
      (get_visual_configs_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_visuals, at = decode_int32 buf ~at in
    let* num_properties, at = decode_int32 buf ~at in
    let at = at + 16 in
    let* property_list, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ num_visuals; num_properties; property_list }, at)

  let encode_destroy_glx_pixmap ~(glx_pixmap : pixmap) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_pixmap buf glx_pixmap;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_vendor_private ~(vendor_code : int) ~(context_tag : context_tag)
      ~(data : char list) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_int32 buf vendor_code;
    (* reserve request length *)
    encode_pad buf 2;
    encode_context_tag buf context_tag;
    encode_list encode_char buf data;
    (* write request length *)
    encode_request_length buf

  type vendor_private_with_reply = {
    retval : int;
    data1 : char list;
    data2 : char list;
  }
  [@@deriving sexp]

  let encode_vendor_private_with_reply ~(vendor_code : int)
      ~(context_tag : context_tag) ~(data : char list) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_int32 buf vendor_code;
    (* reserve request length *)
    encode_pad buf 2;
    encode_context_tag buf context_tag;
    encode_list encode_char buf data;
    (* write request length *)
    encode_request_length buf

  let decode_vendor_private_with_reply_reply length buf ~at :
      (vendor_private_with_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* retval, at = decode_int32 buf ~at in
    let* data1, at =
      let length = 24 in
      decode_list decode_char length buf ~at
    in
    let* data2, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ retval; data1; data2 }, at)

  type query_extensions_string_reply = int [@@deriving sexp]

  let encode_query_extensions_string ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_extensions_string_reply length buf ~at :
      (query_extensions_string_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some (n, at)

  type query_server_string_reply = string [@@deriving sexp]

  let encode_query_server_string ~(screen : int) ~(name : int) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf name;
    (* write request length *)
    encode_request_length buf

  let decode_query_server_string_reply length buf ~at :
      (query_server_string_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* str_len, at = decode_int32 buf ~at in
    let str_len = str_len in
    let at = at + 16 in
    let* string, at = decode_string str_len buf ~at in
    ignore orig;
    Some (string, at)

  let encode_client_info ~(major_version : int) ~(minor_version : int)
      ~(string : string) buf =
    (* opcode *)
    encode_uint8 buf 20;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    encode_int32 buf (identity (String.length string));
    encode_string buf string;
    (* write request length *)
    encode_request_length buf

  type get_fb_configs_reply = {
    num_f_b_configs : int;
    num_properties : int;
    property_list : int list;
  }
  [@@deriving sexp]

  let encode_get_fb_configs ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 21;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_fb_configs_reply length buf ~at :
      (get_fb_configs_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_f_b_configs, at = decode_int32 buf ~at in
    let* num_properties, at = decode_int32 buf ~at in
    let at = at + 16 in
    let* property_list, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ num_f_b_configs; num_properties; property_list }, at)

  let encode_create_pixmap ~(screen : int) ~(fbconfig : fbconfig)
      ~(pixmap : Xproto.pixmap) ~(glx_pixmap : pixmap) ~(attribs : int list) buf
      =
    (* opcode *)
    encode_uint8 buf 22;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fbconfig buf fbconfig;
    Xproto.encode_pixmap buf pixmap;
    encode_pixmap buf glx_pixmap;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs));
    encode_list encode_int32 buf attribs;
    (* write request length *)
    encode_request_length buf

  let encode_destroy_pixmap ~(glx_pixmap : pixmap) buf =
    (* opcode *)
    encode_uint8 buf 23;
    encode_pixmap buf glx_pixmap;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_create_new_context ~(context : context) ~(fbconfig : fbconfig)
      ~(screen : int) ~(render_type : int) ~(share_list : context)
      ~(is_direct : bool) buf =
    (* opcode *)
    encode_uint8 buf 24;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fbconfig buf fbconfig;
    encode_int32 buf screen;
    encode_int32 buf render_type;
    encode_context buf share_list;
    encode_bool buf is_direct;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type query_context_reply = int list [@@deriving sexp]

  let encode_query_context ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 25;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_context_reply length buf ~at :
      (query_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_attribs, at = decode_int32 buf ~at in
    let num_attribs = num_attribs / 2 in
    let at = at + 20 in
    let* attribs, at = decode_list decode_int32 num_attribs buf ~at in
    ignore orig;
    Some (attribs, at)

  type make_context_current_reply = context_tag [@@deriving sexp]

  let encode_make_context_current ~(old_context_tag : context_tag)
      ~(drawable : drawable) ~(read_drawable : drawable) ~(context : context)
      buf =
    (* opcode *)
    encode_uint8 buf 26;
    encode_context_tag buf old_context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_drawable buf drawable;
    encode_drawable buf read_drawable;
    encode_context buf context;
    (* write request length *)
    encode_request_length buf

  let decode_make_context_current_reply length buf ~at :
      (make_context_current_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_tag, at = decode_context_tag buf ~at in
    let at = at + 20 in
    ignore orig;
    Some (context_tag, at)

  let encode_create_pbuffer ~(screen : int) ~(fbconfig : fbconfig)
      ~(pbuffer : pbuffer) ~(attribs : int list) buf =
    (* opcode *)
    encode_uint8 buf 27;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fbconfig buf fbconfig;
    encode_pbuffer buf pbuffer;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs));
    encode_list encode_int32 buf attribs;
    (* write request length *)
    encode_request_length buf

  let encode_destroy_pbuffer ~(pbuffer : pbuffer) buf =
    (* opcode *)
    encode_uint8 buf 28;
    encode_pbuffer buf pbuffer;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type get_drawable_attributes_reply = int list [@@deriving sexp]

  let encode_get_drawable_attributes ~(drawable : drawable) buf =
    (* opcode *)
    encode_uint8 buf 29;
    encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_drawable_attributes_reply length buf ~at :
      (get_drawable_attributes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_attribs, at = decode_int32 buf ~at in
    let num_attribs = num_attribs / 2 in
    let at = at + 20 in
    let* attribs, at = decode_list decode_int32 num_attribs buf ~at in
    ignore orig;
    Some (attribs, at)

  let encode_change_drawable_attributes ~(drawable : drawable)
      ~(attribs : int list) buf =
    (* opcode *)
    encode_uint8 buf 30;
    encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs));
    encode_list encode_int32 buf attribs;
    (* write request length *)
    encode_request_length buf

  let encode_create_window ~(screen : int) ~(fbconfig : fbconfig)
      ~(window : Xproto.window) ~(glx_window : window) ~(attribs : int list) buf
      =
    (* opcode *)
    encode_uint8 buf 31;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fbconfig buf fbconfig;
    Xproto.encode_window buf window;
    encode_window buf glx_window;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs));
    encode_list encode_int32 buf attribs;
    (* write request length *)
    encode_request_length buf

  let encode_delete_window ~(glxwindow : window) buf =
    (* opcode *)
    encode_uint8 buf 32;
    encode_window buf glxwindow;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_set_client_info_arb ~(major_version : int) ~(minor_version : int)
      ~(gl_versions : int list) ~(gl_extension_string : string)
      ~(glx_extension_string : string) buf =
    (* opcode *)
    encode_uint8 buf 33;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length gl_versions));
    encode_int32 buf (identity (String.length gl_extension_string));
    encode_int32 buf (identity (String.length glx_extension_string));
    encode_list encode_int32 buf gl_versions;
    encode_string buf gl_extension_string;
    encode_string buf glx_extension_string;
    (* write request length *)
    encode_request_length buf

  let encode_create_context_attribs_arb ~(context : context)
      ~(fbconfig : fbconfig) ~(screen : int) ~(share_list : context)
      ~(is_direct : bool) ~(attribs : int list) buf =
    (* opcode *)
    encode_uint8 buf 34;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fbconfig buf fbconfig;
    encode_int32 buf screen;
    encode_context buf share_list;
    encode_bool buf is_direct;
    encode_pad buf 3;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length attribs));
    encode_list encode_int32 buf attribs;
    (* write request length *)
    encode_request_length buf

  let encode_set_client_info2_arb ~(major_version : int) ~(minor_version : int)
      ~(gl_versions : int list) ~(gl_extension_string : string)
      ~(glx_extension_string : string) buf =
    (* opcode *)
    encode_uint8 buf 35;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length gl_versions));
    encode_int32 buf (identity (String.length gl_extension_string));
    encode_int32 buf (identity (String.length glx_extension_string));
    encode_list encode_int32 buf gl_versions;
    encode_string buf gl_extension_string;
    encode_string buf glx_extension_string;
    (* write request length *)
    encode_request_length buf

  let encode_new_list ~(context_tag : context_tag) ~(list : int) ~(mode : int)
      buf =
    (* opcode *)
    encode_uint8 buf 101;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf list;
    encode_int32 buf mode;
    (* write request length *)
    encode_request_length buf

  let encode_end_list ~(context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 102;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_delete_lists ~(context_tag : context_tag) ~(list : int)
      ~(range : int) buf =
    (* opcode *)
    encode_uint8 buf 103;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf list;
    encode_int32 buf range;
    (* write request length *)
    encode_request_length buf

  type gen_lists_reply = int [@@deriving sexp]

  let encode_gen_lists ~(context_tag : context_tag) ~(range : int) buf =
    (* opcode *)
    encode_uint8 buf 104;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf range;
    (* write request length *)
    encode_request_length buf

  let decode_gen_lists_reply length buf ~at : (gen_lists_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_int32 buf ~at in
    ignore orig;
    Some (ret_val, at)

  let encode_feedback_buffer ~(context_tag : context_tag) ~(size : int)
      ~(type_ : int) buf =
    (* opcode *)
    encode_uint8 buf 105;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf size;
    encode_int32 buf type_;
    (* write request length *)
    encode_request_length buf

  let encode_select_buffer ~(context_tag : context_tag) ~(size : int) buf =
    (* opcode *)
    encode_uint8 buf 106;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf size;
    (* write request length *)
    encode_request_length buf

  type render_mode_reply = { ret_val : int; new_mode : int; data : int list }
  [@@deriving sexp]

  let encode_render_mode ~(context_tag : context_tag) ~(mode : int) buf =
    (* opcode *)
    encode_uint8 buf 107;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf mode;
    (* write request length *)
    encode_request_length buf

  let decode_render_mode_reply length buf ~at : (render_mode_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_int32 buf ~at in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* new_mode, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ ret_val; new_mode; data }, at)

  type rm_enum = [ `Gl_render | `Gl_feedback | `Gl_select ] [@@deriving sexp]

  let rm_enum_of_int : int -> [> rm_enum ] option = function
    | 7168 -> Some `Gl_render
    | 7169 -> Some `Gl_feedback
    | 7170 -> Some `Gl_select
    | n ->
        Printf.printf "unknown rm_enum: %d\n" n;
        None

  let rm_int_of_enum : rm_enum -> int = function
    | `Gl_render -> 7168
    | `Gl_feedback -> 7169
    | `Gl_select -> 7170

  type finish_reply = unit [@@deriving sexp]

  let encode_finish ~(context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 108;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_finish_reply length buf ~at : (finish_reply * int) option =
    ignore length;
    ignore buf;
    Some ((), at)

  let encode_pixel_storef ~(context_tag : context_tag) ~(pname : int)
      ~(datum : float32) buf =
    (* opcode *)
    encode_uint8 buf 109;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf pname;
    encode_float32 buf datum;
    (* write request length *)
    encode_request_length buf

  let encode_pixel_storei ~(context_tag : context_tag) ~(pname : int)
      ~(datum : int) buf =
    (* opcode *)
    encode_uint8 buf 110;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf pname;
    encode_int32 buf datum;
    (* write request length *)
    encode_request_length buf

  type read_pixels_reply = char list [@@deriving sexp]

  let encode_read_pixels ~(context_tag : context_tag) ~(x : int) ~(y : int)
      ~(width : int) ~(height : int) ~(format : int) ~(type_ : int)
      ~(swap_bytes : bool) ~(lsb_first : bool) buf =
    (* opcode *)
    encode_uint8 buf 111;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf x;
    encode_int32 buf y;
    encode_int32 buf width;
    encode_int32 buf height;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    encode_bool buf lsb_first;
    (* write request length *)
    encode_request_length buf

  let decode_read_pixels_reply length buf ~at : (read_pixels_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some (data, at)

  type get_booleanv_reply = { datum : bool; data : bool list } [@@deriving sexp]

  let encode_get_booleanv ~(context_tag : context_tag) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 112;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_booleanv_reply length buf ~at :
      (get_booleanv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_bool buf ~at in
    let at = at + 15 in
    let* data, at = decode_list decode_bool n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_clip_plane_reply = float64 list [@@deriving sexp]

  let encode_get_clip_plane ~(context_tag : context_tag) ~(plane : int) buf =
    (* opcode *)
    encode_uint8 buf 113;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf plane;
    (* write request length *)
    encode_request_length buf

  let decode_get_clip_plane_reply length buf ~at :
      (get_clip_plane_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* data, at =
      let length = length / 2 in
      decode_list decode_float64 length buf ~at
    in
    ignore orig;
    Some (data, at)

  type get_doublev_reply = { datum : float64; data : float64 list }
  [@@deriving sexp]

  let encode_get_doublev ~(context_tag : context_tag) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 114;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_doublev_reply length buf ~at : (get_doublev_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float64 buf ~at in
    let at = at + 8 in
    let* data, at = decode_list decode_float64 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_error_reply = int [@@deriving sexp]

  let encode_get_error ~(context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 115;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_error_reply length buf ~at : (get_error_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* error, at = decode_int32 buf ~at in
    ignore orig;
    Some (error, at)

  type get_floatv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_floatv ~(context_tag : context_tag) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 116;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_floatv_reply length buf ~at : (get_floatv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_integerv_reply = { datum : int; data : int list } [@@deriving sexp]

  let encode_get_integerv ~(context_tag : context_tag) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 117;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_integerv_reply length buf ~at :
      (get_integerv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_lightfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_lightfv ~(context_tag : context_tag) ~(light : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 118;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf light;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_lightfv_reply length buf ~at : (get_lightfv_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_lightiv_reply = { datum : int; data : int list } [@@deriving sexp]

  let encode_get_lightiv ~(context_tag : context_tag) ~(light : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 119;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf light;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_lightiv_reply length buf ~at : (get_lightiv_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_mapdv_reply = { datum : float64; data : float64 list }
  [@@deriving sexp]

  let encode_get_mapdv ~(context_tag : context_tag) ~(target : int)
      ~(query : int) buf =
    (* opcode *)
    encode_uint8 buf 120;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf query;
    (* write request length *)
    encode_request_length buf

  let decode_get_mapdv_reply length buf ~at : (get_mapdv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float64 buf ~at in
    let at = at + 8 in
    let* data, at = decode_list decode_float64 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_mapfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_mapfv ~(context_tag : context_tag) ~(target : int)
      ~(query : int) buf =
    (* opcode *)
    encode_uint8 buf 121;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf query;
    (* write request length *)
    encode_request_length buf

  let decode_get_mapfv_reply length buf ~at : (get_mapfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_mapiv_reply = { datum : int; data : int list } [@@deriving sexp]

  let encode_get_mapiv ~(context_tag : context_tag) ~(target : int)
      ~(query : int) buf =
    (* opcode *)
    encode_uint8 buf 122;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf query;
    (* write request length *)
    encode_request_length buf

  let decode_get_mapiv_reply length buf ~at : (get_mapiv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_materialfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_materialfv ~(context_tag : context_tag) ~(face : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 123;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf face;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_materialfv_reply length buf ~at :
      (get_materialfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_materialiv_reply = { datum : int; data : int list } [@@deriving sexp]

  let encode_get_materialiv ~(context_tag : context_tag) ~(face : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 124;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf face;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_materialiv_reply length buf ~at :
      (get_materialiv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_pixel_mapfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_pixel_mapfv ~(context_tag : context_tag) ~(map : int) buf =
    (* opcode *)
    encode_uint8 buf 125;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf map;
    (* write request length *)
    encode_request_length buf

  let decode_get_pixel_mapfv_reply length buf ~at :
      (get_pixel_mapfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_pixel_mapuiv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_pixel_mapuiv ~(context_tag : context_tag) ~(map : int) buf =
    (* opcode *)
    encode_uint8 buf 126;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf map;
    (* write request length *)
    encode_request_length buf

  let decode_get_pixel_mapuiv_reply length buf ~at :
      (get_pixel_mapuiv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_pixel_mapusv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_pixel_mapusv ~(context_tag : context_tag) ~(map : int) buf =
    (* opcode *)
    encode_uint8 buf 127;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf map;
    (* write request length *)
    encode_request_length buf

  let decode_get_pixel_mapusv_reply length buf ~at :
      (get_pixel_mapusv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_uint16 buf ~at in
    let at = at + 16 in
    let* data, at = decode_list decode_uint16 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_polygon_stipple_reply = char list [@@deriving sexp]

  let encode_get_polygon_stipple ~(context_tag : context_tag)
      ~(lsb_first : bool) buf =
    (* opcode *)
    encode_uint8 buf 128;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_bool buf lsb_first;
    (* write request length *)
    encode_request_length buf

  let decode_get_polygon_stipple_reply length buf ~at :
      (get_polygon_stipple_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some (data, at)

  type get_string_reply = string [@@deriving sexp]

  let encode_get_string ~(context_tag : context_tag) ~(name : int) buf =
    (* opcode *)
    encode_uint8 buf 129;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf name;
    (* write request length *)
    encode_request_length buf

  let decode_get_string_reply length buf ~at : (get_string_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let at = at + 16 in
    let* string, at = decode_string n buf ~at in
    ignore orig;
    Some (string, at)

  type get_tex_envfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_tex_envfv ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 130;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_envfv_reply length buf ~at :
      (get_tex_envfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_enviv_reply = { datum : int; data : int list } [@@deriving sexp]

  let encode_get_tex_enviv ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 131;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_enviv_reply length buf ~at :
      (get_tex_enviv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_gendv_reply = { datum : float64; data : float64 list }
  [@@deriving sexp]

  let encode_get_tex_gendv ~(context_tag : context_tag) ~(coord : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 132;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf coord;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_gendv_reply length buf ~at :
      (get_tex_gendv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float64 buf ~at in
    let at = at + 8 in
    let* data, at = decode_list decode_float64 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_genfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_tex_genfv ~(context_tag : context_tag) ~(coord : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 133;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf coord;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_genfv_reply length buf ~at :
      (get_tex_genfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_geniv_reply = { datum : int; data : int list } [@@deriving sexp]

  let encode_get_tex_geniv ~(context_tag : context_tag) ~(coord : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 134;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf coord;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_geniv_reply length buf ~at :
      (get_tex_geniv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_image_reply = {
    width : int;
    height : int;
    depth : int;
    data : char list;
  }
  [@@deriving sexp]

  let encode_get_tex_image ~(context_tag : context_tag) ~(target : int)
      ~(level : int) ~(format : int) ~(type_ : int) ~(swap_bytes : bool) buf =
    (* opcode *)
    encode_uint8 buf 135;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf level;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_image_reply length buf ~at :
      (get_tex_image_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 8 in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let* depth, at = decode_int32 buf ~at in
    let at = at + 4 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ width; height; depth; data }, at)

  type get_tex_parameterfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_tex_parameterfv ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 136;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_parameterfv_reply length buf ~at :
      (get_tex_parameterfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_parameteriv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_tex_parameteriv ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 137;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_parameteriv_reply length buf ~at :
      (get_tex_parameteriv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_level_parameterfv_reply = {
    datum : float32;
    data : float32 list;
  }
  [@@deriving sexp]

  let encode_get_tex_level_parameterfv ~(context_tag : context_tag)
      ~(target : int) ~(level : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 138;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf level;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_level_parameterfv_reply length buf ~at :
      (get_tex_level_parameterfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_tex_level_parameteriv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_tex_level_parameteriv ~(context_tag : context_tag)
      ~(target : int) ~(level : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 139;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf level;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_tex_level_parameteriv_reply length buf ~at :
      (get_tex_level_parameteriv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type is_enabled_reply = bool32 [@@deriving sexp]

  let encode_is_enabled ~(context_tag : context_tag) ~(capability : int) buf =
    (* opcode *)
    encode_uint8 buf 140;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf capability;
    (* write request length *)
    encode_request_length buf

  let decode_is_enabled_reply length buf ~at : (is_enabled_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_bool32 buf ~at in
    ignore orig;
    Some (ret_val, at)

  type is_list_reply = bool32 [@@deriving sexp]

  let encode_is_list ~(context_tag : context_tag) ~(list : int) buf =
    (* opcode *)
    encode_uint8 buf 141;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf list;
    (* write request length *)
    encode_request_length buf

  let decode_is_list_reply length buf ~at : (is_list_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_bool32 buf ~at in
    ignore orig;
    Some (ret_val, at)

  let encode_flush ~(context_tag : context_tag) buf =
    (* opcode *)
    encode_uint8 buf 142;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type are_textures_resident_reply = { ret_val : bool32; data : bool list }
  [@@deriving sexp]

  let encode_are_textures_resident ~(context_tag : context_tag)
      ~(textures : int list) buf =
    (* opcode *)
    encode_uint8 buf 143;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length textures));
    encode_list encode_int32 buf textures;
    (* write request length *)
    encode_request_length buf

  let decode_are_textures_resident_reply length buf ~at :
      (are_textures_resident_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_bool32 buf ~at in
    let at = at + 20 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_bool length buf ~at
    in
    ignore orig;
    Some ({ ret_val; data }, at)

  let encode_delete_textures ~(context_tag : context_tag) ~(textures : int list)
      buf =
    (* opcode *)
    encode_uint8 buf 144;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length textures));
    encode_list encode_int32 buf textures;
    (* write request length *)
    encode_request_length buf

  type gen_textures_reply = int list [@@deriving sexp]

  let encode_gen_textures ~(context_tag : context_tag) ~(n : int) buf =
    (* opcode *)
    encode_uint8 buf 145;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf n;
    (* write request length *)
    encode_request_length buf

  let decode_gen_textures_reply length buf ~at :
      (gen_textures_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* data, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some (data, at)

  type is_texture_reply = bool32 [@@deriving sexp]

  let encode_is_texture ~(context_tag : context_tag) ~(texture : int) buf =
    (* opcode *)
    encode_uint8 buf 146;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf texture;
    (* write request length *)
    encode_request_length buf

  let decode_is_texture_reply length buf ~at : (is_texture_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_bool32 buf ~at in
    ignore orig;
    Some (ret_val, at)

  type get_color_table_reply = { width : int; data : char list }
  [@@deriving sexp]

  let encode_get_color_table ~(context_tag : context_tag) ~(target : int)
      ~(format : int) ~(type_ : int) ~(swap_bytes : bool) buf =
    (* opcode *)
    encode_uint8 buf 147;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    (* write request length *)
    encode_request_length buf

  let decode_get_color_table_reply length buf ~at :
      (get_color_table_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 8 in
    let* width, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ width; data }, at)

  type get_color_table_parameterfv_reply = {
    datum : float32;
    data : float32 list;
  }
  [@@deriving sexp]

  let encode_get_color_table_parameterfv ~(context_tag : context_tag)
      ~(target : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 148;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_color_table_parameterfv_reply length buf ~at :
      (get_color_table_parameterfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_color_table_parameteriv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_color_table_parameteriv ~(context_tag : context_tag)
      ~(target : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 149;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_color_table_parameteriv_reply length buf ~at :
      (get_color_table_parameteriv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_convolution_filter_reply = {
    width : int;
    height : int;
    data : char list;
  }
  [@@deriving sexp]

  let encode_get_convolution_filter ~(context_tag : context_tag) ~(target : int)
      ~(format : int) ~(type_ : int) ~(swap_bytes : bool) buf =
    (* opcode *)
    encode_uint8 buf 150;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    (* write request length *)
    encode_request_length buf

  let decode_get_convolution_filter_reply length buf ~at :
      (get_convolution_filter_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 8 in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let at = at + 8 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ width; height; data }, at)

  type get_convolution_parameterfv_reply = {
    datum : float32;
    data : float32 list;
  }
  [@@deriving sexp]

  let encode_get_convolution_parameterfv ~(context_tag : context_tag)
      ~(target : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 151;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_convolution_parameterfv_reply length buf ~at :
      (get_convolution_parameterfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_convolution_parameteriv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_convolution_parameteriv ~(context_tag : context_tag)
      ~(target : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 152;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_convolution_parameteriv_reply length buf ~at :
      (get_convolution_parameteriv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_separable_filter_reply = {
    row_w : int;
    col_h : int;
    rows_and_cols : char list;
  }
  [@@deriving sexp]

  let encode_get_separable_filter ~(context_tag : context_tag) ~(target : int)
      ~(format : int) ~(type_ : int) ~(swap_bytes : bool) buf =
    (* opcode *)
    encode_uint8 buf 153;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    (* write request length *)
    encode_request_length buf

  let decode_get_separable_filter_reply length buf ~at :
      (get_separable_filter_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 8 in
    let* row_w, at = decode_int32 buf ~at in
    let* col_h, at = decode_int32 buf ~at in
    let at = at + 8 in
    let* rows_and_cols, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ row_w; col_h; rows_and_cols }, at)

  type get_histogram_reply = { width : int; data : char list } [@@deriving sexp]

  let encode_get_histogram ~(context_tag : context_tag) ~(target : int)
      ~(format : int) ~(type_ : int) ~(swap_bytes : bool) ~(reset : bool) buf =
    (* opcode *)
    encode_uint8 buf 154;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    encode_bool buf reset;
    (* write request length *)
    encode_request_length buf

  let decode_get_histogram_reply length buf ~at :
      (get_histogram_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 8 in
    let* width, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ width; data }, at)

  type get_histogram_parameterfv_reply = {
    datum : float32;
    data : float32 list;
  }
  [@@deriving sexp]

  let encode_get_histogram_parameterfv ~(context_tag : context_tag)
      ~(target : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 155;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_histogram_parameterfv_reply length buf ~at :
      (get_histogram_parameterfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_histogram_parameteriv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_histogram_parameteriv ~(context_tag : context_tag)
      ~(target : int) ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 156;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_histogram_parameteriv_reply length buf ~at :
      (get_histogram_parameteriv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_minmax_reply = char list [@@deriving sexp]

  let encode_get_minmax ~(context_tag : context_tag) ~(target : int)
      ~(format : int) ~(type_ : int) ~(swap_bytes : bool) ~(reset : bool) buf =
    (* opcode *)
    encode_uint8 buf 157;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf format;
    encode_int32 buf type_;
    encode_bool buf swap_bytes;
    encode_bool buf reset;
    (* write request length *)
    encode_request_length buf

  let decode_get_minmax_reply length buf ~at : (get_minmax_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some (data, at)

  type get_minmax_parameterfv_reply = { datum : float32; data : float32 list }
  [@@deriving sexp]

  let encode_get_minmax_parameterfv ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 158;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_minmax_parameterfv_reply length buf ~at :
      (get_minmax_parameterfv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_float32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_float32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_minmax_parameteriv_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_minmax_parameteriv ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 159;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_minmax_parameteriv_reply length buf ~at :
      (get_minmax_parameteriv_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_compressed_tex_image_arb_reply = { size : int; data : char list }
  [@@deriving sexp]

  let encode_get_compressed_tex_image_arb ~(context_tag : context_tag)
      ~(target : int) ~(level : int) buf =
    (* opcode *)
    encode_uint8 buf 160;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf level;
    (* write request length *)
    encode_request_length buf

  let decode_get_compressed_tex_image_arb_reply length buf ~at :
      (get_compressed_tex_image_arb_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 8 in
    let* size, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ size; data }, at)

  let encode_delete_queries_arb ~(context_tag : context_tag) ~(ids : int list)
      buf =
    (* opcode *)
    encode_uint8 buf 161;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length ids));
    encode_list encode_int32 buf ids;
    (* write request length *)
    encode_request_length buf

  type gen_queries_arb_reply = int list [@@deriving sexp]

  let encode_gen_queries_arb ~(context_tag : context_tag) ~(n : int) buf =
    (* opcode *)
    encode_uint8 buf 162;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf n;
    (* write request length *)
    encode_request_length buf

  let decode_gen_queries_arb_reply length buf ~at :
      (gen_queries_arb_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* data, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some (data, at)

  type is_query_arb_reply = bool32 [@@deriving sexp]

  let encode_is_query_arb ~(context_tag : context_tag) ~(id : int) buf =
    (* opcode *)
    encode_uint8 buf 163;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf id;
    (* write request length *)
    encode_request_length buf

  let decode_is_query_arb_reply length buf ~at :
      (is_query_arb_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ret_val, at = decode_bool32 buf ~at in
    ignore orig;
    Some (ret_val, at)

  type get_queryiv_arb_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_queryiv_arb ~(context_tag : context_tag) ~(target : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 164;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf target;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_queryiv_arb_reply length buf ~at :
      (get_queryiv_arb_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_query_objectiv_arb_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_query_objectiv_arb ~(context_tag : context_tag) ~(id : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 165;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf id;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_query_objectiv_arb_reply length buf ~at :
      (get_query_objectiv_arb_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)

  type get_query_objectuiv_arb_reply = { datum : int; data : int list }
  [@@deriving sexp]

  let encode_get_query_objectuiv_arb ~(context_tag : context_tag) ~(id : int)
      ~(pname : int) buf =
    (* opcode *)
    encode_uint8 buf 166;
    encode_context_tag buf context_tag;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf id;
    encode_int32 buf pname;
    (* write request length *)
    encode_request_length buf

  let decode_get_query_objectuiv_arb_reply length buf ~at :
      (get_query_objectuiv_arb_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 4 in
    let* n, at = decode_int32 buf ~at in
    let n = n in
    let* datum, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at = decode_list decode_int32 n buf ~at in
    ignore orig;
    Some ({ datum; data }, at)
end

module Randr = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type mode = xid [@@deriving sexp]

  let decode_mode = decode_xid
  let encode_mode = encode_xid

  type crtc = xid [@@deriving sexp]

  let decode_crtc = decode_xid
  let encode_crtc = encode_xid

  type output = xid [@@deriving sexp]

  let decode_output = decode_xid
  let encode_output = encode_xid

  type provider = xid [@@deriving sexp]

  let decode_provider = decode_xid
  let encode_provider = encode_xid

  type lease = xid [@@deriving sexp]

  let decode_lease = decode_xid
  let encode_lease = encode_xid

  type bad_output_error = unit [@@deriving sexp]
  type bad_crtc_error = unit [@@deriving sexp]
  type bad_mode_error = unit [@@deriving sexp]
  type bad_provider_error = unit [@@deriving sexp]

  type rotation_mask =
    [ `Rotate_0
    | `Rotate_90
    | `Rotate_180
    | `Rotate_270
    | `Reflect_x
    | `Reflect_y ]
    list
  [@@deriving sexp]

  let rotation_mask_of_int64 mask : rotation_mask option =
    let of_int = function
      | 0 -> Some `Rotate_0
      | 1 -> Some `Rotate_90
      | 2 -> Some `Rotate_180
      | 3 -> Some `Rotate_270
      | 4 -> Some `Reflect_x
      | 5 -> Some `Reflect_y
      | _ -> None
    in
    mask_of_int of_int mask

  let rotation_int_of_mask : rotation_mask -> int =
    let to_bit = function
      | `Rotate_0 -> 0
      | `Rotate_90 -> 1
      | `Rotate_180 -> 2
      | `Rotate_270 -> 3
      | `Reflect_x -> 4
      | `Reflect_y -> 5
    in
    int_of_mask to_bit

  type screen_size = { width : int; height : int; mwidth : int; mheight : int }
  [@@deriving sexp]

  let decode_screen_size buf ~at : (screen_size * int) option =
    let orig = at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* mwidth, at = decode_uint16 buf ~at in
    let* mheight, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ width; height; mwidth; mheight }, at)

  let encode_screen_size buf (v : screen_size) =
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_uint16 buf v.mwidth;
    encode_uint16 buf v.mheight;
    ()

  type refresh_rates = int list [@@deriving sexp]

  let decode_refresh_rates buf ~at : (refresh_rates * int) option =
    let orig = at in
    let* n_rates, at = decode_uint16 buf ~at in
    let n_rates = n_rates in
    let* rates, at = decode_list decode_uint16 n_rates buf ~at in
    ignore orig;
    Some (rates, at)

  let encode_refresh_rates buf (v : refresh_rates) =
    encode_list encode_uint16 buf v;
    ()

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type set_config_enum =
    [ `Success | `Invalid_config_time | `Invalid_time | `Failed ]
  [@@deriving sexp]

  let set_config_enum_of_int : int -> [> set_config_enum ] option = function
    | 0 -> Some `Success
    | 1 -> Some `Invalid_config_time
    | 2 -> Some `Invalid_time
    | 3 -> Some `Failed
    | n ->
        Printf.printf "unknown set_config_enum: %d\n" n;
        None

  let set_config_int_of_enum : set_config_enum -> int = function
    | `Success -> 0
    | `Invalid_config_time -> 1
    | `Invalid_time -> 2
    | `Failed -> 3

  type set_screen_config_reply = {
    status : set_config_enum;
    new_timestamp : Xproto.timestamp;
    config_timestamp : Xproto.timestamp;
    root : Xproto.window;
    subpixel_order : Render.sub_pixel_enum;
  }
  [@@deriving sexp]

  let encode_set_screen_config ~(window : Xproto.window)
      ~(timestamp : Xproto.timestamp) ~(config_timestamp : Xproto.timestamp)
      ~(size_id : int) ~(rotation : rotation_mask) ~(rate : int) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_timestamp buf timestamp;
    Xproto.encode_timestamp buf config_timestamp;
    encode_uint16 buf size_id;
    encode_mask encode_uint16 identity rotation_int_of_mask buf rotation;
    encode_uint16 buf rate;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_set_screen_config_reply length buf ~at :
      (set_screen_config_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_uint8 identity set_config_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* new_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* root, at = Xproto.decode_window buf ~at in
    let* subpixel_order, at =
      decode_enum decode_uint16 identity Render.sub_pixel_enum_of_int buf ~at
    in
    let at = at + 10 in
    ignore orig;
    Some ({ status; new_timestamp; config_timestamp; root; subpixel_order }, at)

  type notify_mask =
    [ `Screen_change
    | `Crtc_change
    | `Output_change
    | `Output_property
    | `Provider_change
    | `Provider_property
    | `Resource_change
    | `Lease ]
    list
  [@@deriving sexp]

  let notify_mask_mask_of_int64 mask : notify_mask option =
    let of_int = function
      | 0 -> Some `Screen_change
      | 1 -> Some `Crtc_change
      | 2 -> Some `Output_change
      | 3 -> Some `Output_property
      | 4 -> Some `Provider_change
      | 5 -> Some `Provider_property
      | 6 -> Some `Resource_change
      | 7 -> Some `Lease
      | _ -> None
    in
    mask_of_int of_int mask

  let notify_mask_int_of_mask : notify_mask -> int =
    let to_bit = function
      | `Screen_change -> 0
      | `Crtc_change -> 1
      | `Output_change -> 2
      | `Output_property -> 3
      | `Provider_change -> 4
      | `Provider_property -> 5
      | `Resource_change -> 6
      | `Lease -> 7
    in
    int_of_mask to_bit

  let encode_select_input ~(window : Xproto.window) ~(enable : notify_mask) buf
      =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mask encode_uint16 identity notify_mask_int_of_mask buf enable;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type get_screen_info_reply = {
    rotations : rotation_mask;
    root : Xproto.window;
    timestamp : Xproto.timestamp;
    config_timestamp : Xproto.timestamp;
    size_id : int;
    rotation : rotation_mask;
    rate : int;
    n_info : int;
    sizes : screen_size list;
    rates : refresh_rates list;
  }
  [@@deriving sexp]

  let encode_get_screen_info ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 5;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_screen_info_reply length buf ~at :
      (get_screen_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* rotations, at =
      decode_mask decode_uint8 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let at = at + 6 in
    let* root, at = Xproto.decode_window buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* n_sizes, at = decode_uint16 buf ~at in
    let n_sizes = n_sizes in
    let* size_id, at = decode_uint16 buf ~at in
    let* rotation, at =
      decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let* rate, at = decode_uint16 buf ~at in
    let* n_info, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* sizes, at = decode_list decode_screen_size n_sizes buf ~at in
    let* rates, at =
      let length = n_info - n_sizes in
      decode_list decode_refresh_rates length buf ~at
    in
    ignore orig;
    Some
      ( {
          rotations;
          root;
          timestamp;
          config_timestamp;
          size_id;
          rotation;
          rate;
          n_info;
          sizes;
          rates;
        },
        at )

  type get_screen_size_range_reply = {
    min_width : int;
    min_height : int;
    max_width : int;
    max_height : int;
  }
  [@@deriving sexp]

  let encode_get_screen_size_range ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 6;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_screen_size_range_reply length buf ~at :
      (get_screen_size_range_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* min_width, at = decode_uint16 buf ~at in
    let* min_height, at = decode_uint16 buf ~at in
    let* max_width, at = decode_uint16 buf ~at in
    let* max_height, at = decode_uint16 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ min_width; min_height; max_width; max_height }, at)

  let encode_set_screen_size ~(window : Xproto.window) ~(width : int)
      ~(height : int) ~(mm_width : int) ~(mm_height : int) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int32 buf mm_width;
    encode_int32 buf mm_height;
    (* write request length *)
    encode_request_length buf

  type mode_flag_mask =
    [ `Hsync_positive
    | `Hsync_negative
    | `Vsync_positive
    | `Vsync_negative
    | `Interlace
    | `Double_scan
    | `Csync
    | `Csync_positive
    | `Csync_negative
    | `Hskew_present
    | `Bcast
    | `Pixel_multiplex
    | `Double_clock
    | `Halve_clock ]
    list
  [@@deriving sexp]

  let mode_flag_mask_of_int64 mask : mode_flag_mask option =
    let of_int = function
      | 0 -> Some `Hsync_positive
      | 1 -> Some `Hsync_negative
      | 2 -> Some `Vsync_positive
      | 3 -> Some `Vsync_negative
      | 4 -> Some `Interlace
      | 5 -> Some `Double_scan
      | 6 -> Some `Csync
      | 7 -> Some `Csync_positive
      | 8 -> Some `Csync_negative
      | 9 -> Some `Hskew_present
      | 10 -> Some `Bcast
      | 11 -> Some `Pixel_multiplex
      | 12 -> Some `Double_clock
      | 13 -> Some `Halve_clock
      | _ -> None
    in
    mask_of_int of_int mask

  let mode_flag_int_of_mask : mode_flag_mask -> int =
    let to_bit = function
      | `Hsync_positive -> 0
      | `Hsync_negative -> 1
      | `Vsync_positive -> 2
      | `Vsync_negative -> 3
      | `Interlace -> 4
      | `Double_scan -> 5
      | `Csync -> 6
      | `Csync_positive -> 7
      | `Csync_negative -> 8
      | `Hskew_present -> 9
      | `Bcast -> 10
      | `Pixel_multiplex -> 11
      | `Double_clock -> 12
      | `Halve_clock -> 13
    in
    int_of_mask to_bit

  type mode_info = {
    id : int;
    width : int;
    height : int;
    dot_clock : int;
    hsync_start : int;
    hsync_end : int;
    htotal : int;
    hskew : int;
    vsync_start : int;
    vsync_end : int;
    vtotal : int;
    name_len : int;
    mode_flags : mode_flag_mask;
  }
  [@@deriving sexp]

  let decode_mode_info buf ~at : (mode_info * int) option =
    let orig = at in
    let* id, at = decode_int32 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* dot_clock, at = decode_int32 buf ~at in
    let* hsync_start, at = decode_uint16 buf ~at in
    let* hsync_end, at = decode_uint16 buf ~at in
    let* htotal, at = decode_uint16 buf ~at in
    let* hskew, at = decode_uint16 buf ~at in
    let* vsync_start, at = decode_uint16 buf ~at in
    let* vsync_end, at = decode_uint16 buf ~at in
    let* vtotal, at = decode_uint16 buf ~at in
    let* name_len, at = decode_uint16 buf ~at in
    let* mode_flags, at =
      decode_mask decode_int32 Int64.of_int mode_flag_mask_of_int64 buf ~at
    in
    ignore orig;
    Some
      ( {
          id;
          width;
          height;
          dot_clock;
          hsync_start;
          hsync_end;
          htotal;
          hskew;
          vsync_start;
          vsync_end;
          vtotal;
          name_len;
          mode_flags;
        },
        at )

  let encode_mode_info buf (v : mode_info) =
    encode_int32 buf v.id;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_int32 buf v.dot_clock;
    encode_uint16 buf v.hsync_start;
    encode_uint16 buf v.hsync_end;
    encode_uint16 buf v.htotal;
    encode_uint16 buf v.hskew;
    encode_uint16 buf v.vsync_start;
    encode_uint16 buf v.vsync_end;
    encode_uint16 buf v.vtotal;
    encode_uint16 buf v.name_len;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf v.mode_flags;
    ()

  type get_screen_resources_reply = {
    timestamp : Xproto.timestamp;
    config_timestamp : Xproto.timestamp;
    crtcs : crtc list;
    outputs : output list;
    modes : mode_info list;
    names : char list;
  }
  [@@deriving sexp]

  let encode_get_screen_resources ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_screen_resources_reply length buf ~at :
      (get_screen_resources_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* num_crtcs, at = decode_uint16 buf ~at in
    let num_crtcs = num_crtcs in
    let* num_outputs, at = decode_uint16 buf ~at in
    let num_outputs = num_outputs in
    let* num_modes, at = decode_uint16 buf ~at in
    let num_modes = num_modes in
    let* names_len, at = decode_uint16 buf ~at in
    let names_len = names_len in
    let at = at + 8 in
    let* crtcs, at = decode_list decode_crtc num_crtcs buf ~at in
    let* outputs, at = decode_list decode_output num_outputs buf ~at in
    let* modes, at = decode_list decode_mode_info num_modes buf ~at in
    let* names, at = decode_list decode_char names_len buf ~at in
    ignore orig;
    Some ({ timestamp; config_timestamp; crtcs; outputs; modes; names }, at)

  type connection_enum = [ `Connected | `Disconnected | `Unknown ]
  [@@deriving sexp]

  let connection_enum_of_int : int -> [> connection_enum ] option = function
    | 0 -> Some `Connected
    | 1 -> Some `Disconnected
    | 2 -> Some `Unknown
    | n ->
        Printf.printf "unknown connection_enum: %d\n" n;
        None

  let connection_int_of_enum : connection_enum -> int = function
    | `Connected -> 0
    | `Disconnected -> 1
    | `Unknown -> 2

  type get_output_info_reply = {
    status : set_config_enum;
    timestamp : Xproto.timestamp;
    crtc : crtc;
    mm_width : int;
    mm_height : int;
    connection : connection_enum;
    subpixel_order : Render.sub_pixel_enum;
    num_preferred : int;
    crtcs : crtc list;
    modes : mode list;
    clones : output list;
    name : char list;
  }
  [@@deriving sexp]

  let encode_get_output_info ~(output : output)
      ~(config_timestamp : Xproto.timestamp) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_timestamp buf config_timestamp;
    (* write request length *)
    encode_request_length buf

  let decode_get_output_info_reply length buf ~at :
      (get_output_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_uint8 identity set_config_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* crtc, at = decode_crtc buf ~at in
    let* mm_width, at = decode_int32 buf ~at in
    let* mm_height, at = decode_int32 buf ~at in
    let* connection, at =
      decode_enum decode_uint8 identity connection_enum_of_int buf ~at
    in
    let* subpixel_order, at =
      decode_enum decode_uint8 identity Render.sub_pixel_enum_of_int buf ~at
    in
    let* num_crtcs, at = decode_uint16 buf ~at in
    let num_crtcs = num_crtcs in
    let* num_modes, at = decode_uint16 buf ~at in
    let num_modes = num_modes in
    let* num_preferred, at = decode_uint16 buf ~at in
    let* num_clones, at = decode_uint16 buf ~at in
    let num_clones = num_clones in
    let* name_len, at = decode_uint16 buf ~at in
    let name_len = name_len in
    let* crtcs, at = decode_list decode_crtc num_crtcs buf ~at in
    let* modes, at = decode_list decode_mode num_modes buf ~at in
    let* clones, at = decode_list decode_output num_clones buf ~at in
    let* name, at = decode_list decode_char name_len buf ~at in
    ignore orig;
    Some
      ( {
          status;
          timestamp;
          crtc;
          mm_width;
          mm_height;
          connection;
          subpixel_order;
          num_preferred;
          crtcs;
          modes;
          clones;
          name;
        },
        at )

  type list_output_properties_reply = Xproto.atom list [@@deriving sexp]

  let encode_list_output_properties ~(output : output) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_list_output_properties_reply length buf ~at :
      (list_output_properties_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_atoms, at = decode_uint16 buf ~at in
    let num_atoms = num_atoms in
    let at = at + 22 in
    let* atoms, at = decode_list Xproto.decode_atom num_atoms buf ~at in
    ignore orig;
    Some (atoms, at)

  type query_output_property_reply = {
    pending : bool;
    range : bool;
    immutable : bool;
    valid_values : int list;
  }
  [@@deriving sexp]

  let encode_query_output_property ~(output : output) ~(property : Xproto.atom)
      buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  let decode_query_output_property_reply length buf ~at :
      (query_output_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* pending, at = decode_bool buf ~at in
    let* range, at = decode_bool buf ~at in
    let* immutable, at = decode_bool buf ~at in
    let at = at + 21 in
    let* valid_values, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ pending; range; immutable; valid_values }, at)

  let encode_configure_output_property ~(output : output)
      ~(property : Xproto.atom) ~(pending : bool) ~(range : bool)
      ~(values : int list) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    encode_bool buf pending;
    encode_bool buf range;
    encode_pad buf 2;
    encode_list encode_int32 buf values;
    (* write request length *)
    encode_request_length buf

  let encode_change_output_property ~(output : output) ~(property : Xproto.atom)
      ~(type_ : Xproto.atom) ~(format : int) ~(mode : Xproto.prop_mode_enum)
      ~(num_units : int) ~(data : string) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    Xproto.encode_atom buf type_;
    encode_uint8 buf format;
    encode_enum encode_uint8 identity Xproto.prop_mode_int_of_enum buf mode;
    encode_pad buf 2;
    encode_int32 buf num_units;
    encode_string buf data;
    (* write request length *)
    encode_request_length buf

  let encode_delete_output_property ~(output : output) ~(property : Xproto.atom)
      buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  type get_output_property_reply = {
    format : int;
    type_ : Xproto.atom_enum alt_enum;
    bytes_after : int;
    num_items : int;
    data : char list;
  }
  [@@deriving sexp]

  let encode_get_output_property ~(output : output) ~(property : Xproto.atom)
      ~(type_ : Xproto.get_property_type_enum alt_enum) ~(long_offset : int)
      ~(long_length : int) ~(delete : bool) ~(pending : bool) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    encode_alt_enum Xproto.encode_atom identity
      Xproto.get_property_type_int_of_enum buf type_;
    encode_int32 buf long_offset;
    encode_int32 buf long_length;
    encode_bool buf delete;
    encode_bool buf pending;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_output_property_reply length buf ~at :
      (get_output_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* format, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* type_, at =
      decode_alt_enum Xproto.decode_atom identity Xproto.atom_enum_of_int buf
        ~at
    in
    let* bytes_after, at = decode_int32 buf ~at in
    let* num_items, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at =
      let length = num_items * (format / 8) in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some ({ format; type_; bytes_after; num_items; data }, at)

  type create_mode_reply = mode [@@deriving sexp]

  let encode_create_mode ~(window : Xproto.window) ~(mode_info : mode_info)
      ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 16;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mode_info buf mode_info;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_create_mode_reply length buf ~at : (create_mode_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* mode, at = decode_mode buf ~at in
    let at = at + 20 in
    ignore orig;
    Some (mode, at)

  let encode_destroy_mode ~(mode : mode) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_mode buf mode;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_add_output_mode ~(output : output) ~(mode : mode) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mode buf mode;
    (* write request length *)
    encode_request_length buf

  let encode_delete_output_mode ~(output : output) ~(mode : mode) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_output buf output;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mode buf mode;
    (* write request length *)
    encode_request_length buf

  type get_crtc_info_reply = {
    status : set_config_enum;
    timestamp : Xproto.timestamp;
    x : int;
    y : int;
    width : int;
    height : int;
    mode : mode;
    rotation : rotation_mask;
    rotations : rotation_mask;
    outputs : output list;
    possible : output list;
  }
  [@@deriving sexp]

  let encode_get_crtc_info ~(crtc : crtc) ~(config_timestamp : Xproto.timestamp)
      buf =
    (* opcode *)
    encode_uint8 buf 20;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_timestamp buf config_timestamp;
    (* write request length *)
    encode_request_length buf

  let decode_get_crtc_info_reply length buf ~at :
      (get_crtc_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_uint8 identity set_config_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* mode, at = decode_mode buf ~at in
    let* rotation, at =
      decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let* rotations, at =
      decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let* num_outputs, at = decode_uint16 buf ~at in
    let num_outputs = num_outputs in
    let* num_possible_outputs, at = decode_uint16 buf ~at in
    let num_possible_outputs = num_possible_outputs in
    let* outputs, at = decode_list decode_output num_outputs buf ~at in
    let* possible, at =
      decode_list decode_output num_possible_outputs buf ~at
    in
    ignore orig;
    Some
      ( {
          status;
          timestamp;
          x;
          y;
          width;
          height;
          mode;
          rotation;
          rotations;
          outputs;
          possible;
        },
        at )

  type set_crtc_config_reply = {
    status : set_config_enum;
    timestamp : Xproto.timestamp;
  }
  [@@deriving sexp]

  let encode_set_crtc_config ~(crtc : crtc) ~(timestamp : Xproto.timestamp)
      ~(config_timestamp : Xproto.timestamp) ~(x : int) ~(y : int)
      ~(mode : mode) ~(rotation : rotation_mask) ~(outputs : output list) buf =
    (* opcode *)
    encode_uint8 buf 21;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_timestamp buf timestamp;
    Xproto.encode_timestamp buf config_timestamp;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_mode buf mode;
    encode_mask encode_uint16 identity rotation_int_of_mask buf rotation;
    encode_pad buf 2;
    encode_list encode_output buf outputs;
    (* write request length *)
    encode_request_length buf

  let decode_set_crtc_config_reply length buf ~at :
      (set_crtc_config_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_uint8 identity set_config_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ status; timestamp }, at)

  type get_crtc_gamma_size_reply = int [@@deriving sexp]

  let encode_get_crtc_gamma_size ~(crtc : crtc) buf =
    (* opcode *)
    encode_uint8 buf 22;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_crtc_gamma_size_reply length buf ~at :
      (get_crtc_gamma_size_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* size, at = decode_uint16 buf ~at in
    let at = at + 22 in
    ignore orig;
    Some (size, at)

  type get_crtc_gamma_reply = {
    red : int list;
    green : int list;
    blue : int list;
  }
  [@@deriving sexp]

  let encode_get_crtc_gamma ~(crtc : crtc) buf =
    (* opcode *)
    encode_uint8 buf 23;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_crtc_gamma_reply length buf ~at :
      (get_crtc_gamma_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* size, at = decode_uint16 buf ~at in
    let size = size in
    let at = at + 22 in
    let* red, at = decode_list decode_uint16 size buf ~at in
    let* green, at = decode_list decode_uint16 size buf ~at in
    let* blue, at = decode_list decode_uint16 size buf ~at in
    ignore orig;
    Some ({ red; green; blue }, at)

  let encode_set_crtc_gamma ~(crtc : crtc) ~(red : int list) ~(green : int list)
      ~(blue : int list) buf =
    (* opcode *)
    encode_uint8 buf 24;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity ((* Parsetree.Card16 *) List.length red));
    encode_pad buf 2;
    encode_list encode_uint16 buf red;
    encode_list encode_uint16 buf green;
    encode_list encode_uint16 buf blue;
    (* write request length *)
    encode_request_length buf

  type get_screen_resources_current_reply = {
    timestamp : Xproto.timestamp;
    config_timestamp : Xproto.timestamp;
    crtcs : crtc list;
    outputs : output list;
    modes : mode_info list;
    names : char list;
  }
  [@@deriving sexp]

  let encode_get_screen_resources_current ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 25;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_screen_resources_current_reply length buf ~at :
      (get_screen_resources_current_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* num_crtcs, at = decode_uint16 buf ~at in
    let num_crtcs = num_crtcs in
    let* num_outputs, at = decode_uint16 buf ~at in
    let num_outputs = num_outputs in
    let* num_modes, at = decode_uint16 buf ~at in
    let num_modes = num_modes in
    let* names_len, at = decode_uint16 buf ~at in
    let names_len = names_len in
    let at = at + 8 in
    let* crtcs, at = decode_list decode_crtc num_crtcs buf ~at in
    let* outputs, at = decode_list decode_output num_outputs buf ~at in
    let* modes, at = decode_list decode_mode_info num_modes buf ~at in
    let* names, at = decode_list decode_char names_len buf ~at in
    ignore orig;
    Some ({ timestamp; config_timestamp; crtcs; outputs; modes; names }, at)

  type transform_mask = [ `Unit | `Scale_up | `Scale_down | `Projective ] list
  [@@deriving sexp]

  let transform_mask_of_int64 mask : transform_mask option =
    let of_int = function
      | 0 -> Some `Unit
      | 1 -> Some `Scale_up
      | 2 -> Some `Scale_down
      | 3 -> Some `Projective
      | _ -> None
    in
    mask_of_int of_int mask

  let transform_int_of_mask : transform_mask -> int =
    let to_bit = function
      | `Unit -> 0
      | `Scale_up -> 1
      | `Scale_down -> 2
      | `Projective -> 3
    in
    int_of_mask to_bit

  let encode_set_crtc_transform ~(crtc : crtc) ~(transform : Render.transform)
      ~(filter_name : string) ~(filter_params : Render.fixed list) buf =
    (* opcode *)
    encode_uint8 buf 26;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;
    Render.encode_transform buf transform;
    encode_uint16 buf (identity (String.length filter_name));
    encode_pad buf 2;
    encode_string buf filter_name;
    encode_align buf 4;
    encode_list Render.encode_fixed buf filter_params;
    (* write request length *)
    encode_request_length buf

  type get_crtc_transform_reply = {
    pending_transform : Render.transform;
    has_transforms : bool;
    current_transform : Render.transform;
    pending_filter_name : string;
    pending_params : Render.fixed list;
    current_filter_name : string;
    current_params : Render.fixed list;
  }
  [@@deriving sexp]

  let encode_get_crtc_transform ~(crtc : crtc) buf =
    (* opcode *)
    encode_uint8 buf 27;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_crtc_transform_reply length buf ~at :
      (get_crtc_transform_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* pending_transform, at = Render.decode_transform buf ~at in
    let* has_transforms, at = decode_bool buf ~at in
    let at = at + 3 in
    let* current_transform, at = Render.decode_transform buf ~at in
    let at = at + 4 in
    let* pending_len, at = decode_uint16 buf ~at in
    let pending_len = pending_len in
    let* pending_nparams, at = decode_uint16 buf ~at in
    let pending_nparams = pending_nparams in
    let* current_len, at = decode_uint16 buf ~at in
    let current_len = current_len in
    let* current_nparams, at = decode_uint16 buf ~at in
    let current_nparams = current_nparams in
    let* pending_filter_name, at = decode_string pending_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* pending_params, at =
      decode_list Render.decode_fixed pending_nparams buf ~at
    in
    let* current_filter_name, at = decode_string current_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* current_params, at =
      decode_list Render.decode_fixed current_nparams buf ~at
    in
    ignore orig;
    Some
      ( {
          pending_transform;
          has_transforms;
          current_transform;
          pending_filter_name;
          pending_params;
          current_filter_name;
          current_params;
        },
        at )

  type get_panning_reply = {
    status : set_config_enum;
    timestamp : Xproto.timestamp;
    left : int;
    top : int;
    width : int;
    height : int;
    track_left : int;
    track_top : int;
    track_width : int;
    track_height : int;
    border_left : int;
    border_top : int;
    border_right : int;
    border_bottom : int;
  }
  [@@deriving sexp]

  let encode_get_panning ~(crtc : crtc) buf =
    (* opcode *)
    encode_uint8 buf 28;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_panning_reply length buf ~at : (get_panning_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_uint8 identity set_config_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* left, at = decode_uint16 buf ~at in
    let* top, at = decode_uint16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* track_left, at = decode_uint16 buf ~at in
    let* track_top, at = decode_uint16 buf ~at in
    let* track_width, at = decode_uint16 buf ~at in
    let* track_height, at = decode_uint16 buf ~at in
    let* border_left, at = decode_int16 buf ~at in
    let* border_top, at = decode_int16 buf ~at in
    let* border_right, at = decode_int16 buf ~at in
    let* border_bottom, at = decode_int16 buf ~at in
    ignore orig;
    Some
      ( {
          status;
          timestamp;
          left;
          top;
          width;
          height;
          track_left;
          track_top;
          track_width;
          track_height;
          border_left;
          border_top;
          border_right;
          border_bottom;
        },
        at )

  type set_panning_reply = {
    status : set_config_enum;
    timestamp : Xproto.timestamp;
  }
  [@@deriving sexp]

  let encode_set_panning ~(crtc : crtc) ~(timestamp : Xproto.timestamp)
      ~(left : int) ~(top : int) ~(width : int) ~(height : int)
      ~(track_left : int) ~(track_top : int) ~(track_width : int)
      ~(track_height : int) ~(border_left : int) ~(border_top : int)
      ~(border_right : int) ~(border_bottom : int) buf =
    (* opcode *)
    encode_uint8 buf 29;
    encode_crtc buf crtc;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_timestamp buf timestamp;
    encode_uint16 buf left;
    encode_uint16 buf top;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_uint16 buf track_left;
    encode_uint16 buf track_top;
    encode_uint16 buf track_width;
    encode_uint16 buf track_height;
    encode_int16 buf border_left;
    encode_int16 buf border_top;
    encode_int16 buf border_right;
    encode_int16 buf border_bottom;
    (* write request length *)
    encode_request_length buf

  let decode_set_panning_reply length buf ~at : (set_panning_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* status, at =
      decode_enum decode_uint8 identity set_config_enum_of_int buf ~at
    in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    ignore orig;
    Some ({ status; timestamp }, at)

  let encode_set_output_primary ~(window : Xproto.window) ~(output : output) buf
      =
    (* opcode *)
    encode_uint8 buf 30;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_output buf output;
    (* write request length *)
    encode_request_length buf

  type get_output_primary_reply = output [@@deriving sexp]

  let encode_get_output_primary ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 31;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_output_primary_reply length buf ~at :
      (get_output_primary_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* output, at = decode_output buf ~at in
    ignore orig;
    Some (output, at)

  type get_providers_reply = {
    timestamp : Xproto.timestamp;
    providers : provider list;
  }
  [@@deriving sexp]

  let encode_get_providers ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 32;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_providers_reply length buf ~at :
      (get_providers_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* num_providers, at = decode_uint16 buf ~at in
    let num_providers = num_providers in
    let at = at + 18 in
    let* providers, at = decode_list decode_provider num_providers buf ~at in
    ignore orig;
    Some ({ timestamp; providers }, at)

  type provider_capability_mask =
    [ `Source_output | `Sink_output | `Source_offload | `Sink_offload ] list
  [@@deriving sexp]

  let provider_capability_mask_of_int64 mask : provider_capability_mask option =
    let of_int = function
      | 0 -> Some `Source_output
      | 1 -> Some `Sink_output
      | 2 -> Some `Source_offload
      | 3 -> Some `Sink_offload
      | _ -> None
    in
    mask_of_int of_int mask

  let provider_capability_int_of_mask : provider_capability_mask -> int =
    let to_bit = function
      | `Source_output -> 0
      | `Sink_output -> 1
      | `Source_offload -> 2
      | `Sink_offload -> 3
    in
    int_of_mask to_bit

  type get_provider_info_reply = {
    status : int;
    timestamp : Xproto.timestamp;
    capabilities : provider_capability_mask;
    crtcs : crtc list;
    outputs : output list;
    associated_providers : provider list;
    associated_capability : int list;
    name : string;
  }
  [@@deriving sexp]

  let encode_get_provider_info ~(provider : provider)
      ~(config_timestamp : Xproto.timestamp) buf =
    (* opcode *)
    encode_uint8 buf 33;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_timestamp buf config_timestamp;
    (* write request length *)
    encode_request_length buf

  let decode_get_provider_info_reply length buf ~at :
      (get_provider_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* capabilities, at =
      decode_mask decode_int32 Int64.of_int provider_capability_mask_of_int64
        buf ~at
    in
    let* num_crtcs, at = decode_uint16 buf ~at in
    let num_crtcs = num_crtcs in
    let* num_outputs, at = decode_uint16 buf ~at in
    let num_outputs = num_outputs in
    let* num_associated_providers, at = decode_uint16 buf ~at in
    let num_associated_providers = num_associated_providers in
    let* name_len, at = decode_uint16 buf ~at in
    let name_len = name_len in
    let at = at + 8 in
    let* crtcs, at = decode_list decode_crtc num_crtcs buf ~at in
    let* outputs, at = decode_list decode_output num_outputs buf ~at in
    let* associated_providers, at =
      decode_list decode_provider num_associated_providers buf ~at
    in
    let* associated_capability, at =
      decode_list decode_int32 num_associated_providers buf ~at
    in
    let* name, at = decode_string name_len buf ~at in
    ignore orig;
    Some
      ( {
          status;
          timestamp;
          capabilities;
          crtcs;
          outputs;
          associated_providers;
          associated_capability;
          name;
        },
        at )

  let encode_set_provider_offload_sink ~(provider : provider)
      ~(sink_provider : provider) ~(config_timestamp : Xproto.timestamp) buf =
    (* opcode *)
    encode_uint8 buf 34;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    encode_provider buf sink_provider;
    Xproto.encode_timestamp buf config_timestamp;
    (* write request length *)
    encode_request_length buf

  let encode_set_provider_output_source ~(provider : provider)
      ~(source_provider : provider) ~(config_timestamp : Xproto.timestamp) buf =
    (* opcode *)
    encode_uint8 buf 35;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    encode_provider buf source_provider;
    Xproto.encode_timestamp buf config_timestamp;
    (* write request length *)
    encode_request_length buf

  type list_provider_properties_reply = Xproto.atom list [@@deriving sexp]

  let encode_list_provider_properties ~(provider : provider) buf =
    (* opcode *)
    encode_uint8 buf 36;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_list_provider_properties_reply length buf ~at :
      (list_provider_properties_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_atoms, at = decode_uint16 buf ~at in
    let num_atoms = num_atoms in
    let at = at + 22 in
    let* atoms, at = decode_list Xproto.decode_atom num_atoms buf ~at in
    ignore orig;
    Some (atoms, at)

  type query_provider_property_reply = {
    pending : bool;
    range : bool;
    immutable : bool;
    valid_values : int list;
  }
  [@@deriving sexp]

  let encode_query_provider_property ~(provider : provider)
      ~(property : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 37;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  let decode_query_provider_property_reply length buf ~at :
      (query_provider_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* pending, at = decode_bool buf ~at in
    let* range, at = decode_bool buf ~at in
    let* immutable, at = decode_bool buf ~at in
    let at = at + 21 in
    let* valid_values, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ pending; range; immutable; valid_values }, at)

  let encode_configure_provider_property ~(provider : provider)
      ~(property : Xproto.atom) ~(pending : bool) ~(range : bool)
      ~(values : int list) buf =
    (* opcode *)
    encode_uint8 buf 38;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    encode_bool buf pending;
    encode_bool buf range;
    encode_pad buf 2;
    encode_list encode_int32 buf values;
    (* write request length *)
    encode_request_length buf

  let encode_change_provider_property ~(provider : provider)
      ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(format : int)
      ~(mode : int) ~(num_items : int) ~(data : string) buf =
    (* opcode *)
    encode_uint8 buf 39;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    Xproto.encode_atom buf type_;
    encode_uint8 buf format;
    encode_uint8 buf mode;
    encode_pad buf 2;
    encode_int32 buf num_items;
    encode_string buf data;
    (* write request length *)
    encode_request_length buf

  let encode_delete_provider_property ~(provider : provider)
      ~(property : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 40;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  type get_provider_property_reply = {
    format : int;
    type_ : Xproto.atom;
    bytes_after : int;
    num_items : int;
    data : string;
  }
  [@@deriving sexp]

  let encode_get_provider_property ~(provider : provider)
      ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(long_offset : int)
      ~(long_length : int) ~(delete : bool) ~(pending : bool) buf =
    (* opcode *)
    encode_uint8 buf 41;
    encode_provider buf provider;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    Xproto.encode_atom buf type_;
    encode_int32 buf long_offset;
    encode_int32 buf long_length;
    encode_bool buf delete;
    encode_bool buf pending;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_provider_property_reply length buf ~at :
      (get_provider_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* format, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* type_, at = Xproto.decode_atom buf ~at in
    let* bytes_after, at = decode_int32 buf ~at in
    let* num_items, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* data, at =
      let length = num_items * (format / 8) in
      decode_string length buf ~at
    in
    ignore orig;
    Some ({ format; type_; bytes_after; num_items; data }, at)

  type screen_change_notify_event = {
    rotation : rotation_mask;
    timestamp : Xproto.timestamp;
    config_timestamp : Xproto.timestamp;
    root : Xproto.window;
    request_window : Xproto.window;
    size_id : int;
    subpixel_order : Render.sub_pixel_enum;
    width : int;
    height : int;
    mwidth : int;
    mheight : int;
  }
  [@@deriving sexp]

  let decode_screen_change_notify_event buf ~at :
      (screen_change_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* rotation, at =
      decode_mask decode_uint8 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* root, at = Xproto.decode_window buf ~at in
    let* request_window, at = Xproto.decode_window buf ~at in
    let* size_id, at = decode_uint16 buf ~at in
    let* subpixel_order, at =
      decode_enum decode_uint16 identity Render.sub_pixel_enum_of_int buf ~at
    in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* mwidth, at = decode_uint16 buf ~at in
    let* mheight, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          rotation;
          timestamp;
          config_timestamp;
          root;
          request_window;
          size_id;
          subpixel_order;
          width;
          height;
          mwidth;
          mheight;
        },
        at )

  type notify_enum =
    [ `Crtc_change
    | `Output_change
    | `Output_property
    | `Provider_change
    | `Provider_property
    | `Resource_change
    | `Lease ]
  [@@deriving sexp]

  let notify_enum_of_int : int -> [> notify_enum ] option = function
    | 0 -> Some `Crtc_change
    | 1 -> Some `Output_change
    | 2 -> Some `Output_property
    | 3 -> Some `Provider_change
    | 4 -> Some `Provider_property
    | 5 -> Some `Resource_change
    | 6 -> Some `Lease
    | n ->
        Printf.printf "unknown notify_enum: %d\n" n;
        None

  let notify_int_of_enum : notify_enum -> int = function
    | `Crtc_change -> 0
    | `Output_change -> 1
    | `Output_property -> 2
    | `Provider_change -> 3
    | `Provider_property -> 4
    | `Resource_change -> 5
    | `Lease -> 6

  type crtc_change = {
    timestamp : Xproto.timestamp;
    window : Xproto.window;
    crtc : crtc;
    mode : mode;
    rotation : rotation_mask;
    x : int;
    y : int;
    width : int;
    height : int;
  }
  [@@deriving sexp]

  let decode_crtc_change buf ~at : (crtc_change * int) option =
    let orig = at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* crtc, at = decode_crtc buf ~at in
    let* mode, at = decode_mode buf ~at in
    let* rotation, at =
      decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let at = at + 2 in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ timestamp; window; crtc; mode; rotation; x; y; width; height }, at)

  let encode_crtc_change buf (v : crtc_change) =
    Xproto.encode_timestamp buf v.timestamp;
    Xproto.encode_window buf v.window;
    encode_crtc buf v.crtc;
    encode_mode buf v.mode;
    encode_mask encode_uint16 identity rotation_int_of_mask buf v.rotation;
    encode_pad buf 2;
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    ()

  type output_change = {
    timestamp : Xproto.timestamp;
    config_timestamp : Xproto.timestamp;
    window : Xproto.window;
    output : output;
    crtc : crtc;
    mode : mode;
    rotation : rotation_mask;
    connection : connection_enum;
    subpixel_order : Render.sub_pixel_enum;
  }
  [@@deriving sexp]

  let decode_output_change buf ~at : (output_change * int) option =
    let orig = at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* config_timestamp, at = Xproto.decode_timestamp buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* output, at = decode_output buf ~at in
    let* crtc, at = decode_crtc buf ~at in
    let* mode, at = decode_mode buf ~at in
    let* rotation, at =
      decode_mask decode_uint16 Int64.of_int rotation_mask_of_int64 buf ~at
    in
    let* connection, at =
      decode_enum decode_uint8 identity connection_enum_of_int buf ~at
    in
    let* subpixel_order, at =
      decode_enum decode_uint8 identity Render.sub_pixel_enum_of_int buf ~at
    in
    ignore orig;
    Some
      ( {
          timestamp;
          config_timestamp;
          window;
          output;
          crtc;
          mode;
          rotation;
          connection;
          subpixel_order;
        },
        at )

  let encode_output_change buf (v : output_change) =
    Xproto.encode_timestamp buf v.timestamp;
    Xproto.encode_timestamp buf v.config_timestamp;
    Xproto.encode_window buf v.window;
    encode_output buf v.output;
    encode_crtc buf v.crtc;
    encode_mode buf v.mode;
    encode_mask encode_uint16 identity rotation_int_of_mask buf v.rotation;
    encode_enum encode_uint8 identity connection_int_of_enum buf v.connection;
    encode_enum encode_uint8 identity Render.sub_pixel_int_of_enum buf
      v.subpixel_order;
    ()

  type output_property = {
    window : Xproto.window;
    output : output;
    atom : Xproto.atom;
    timestamp : Xproto.timestamp;
    status : Xproto.property_enum;
  }
  [@@deriving sexp]

  let decode_output_property buf ~at : (output_property * int) option =
    let orig = at in
    let* window, at = Xproto.decode_window buf ~at in
    let* output, at = decode_output buf ~at in
    let* atom, at = Xproto.decode_atom buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.property_enum_of_int buf ~at
    in
    let at = at + 11 in
    ignore orig;
    Some ({ window; output; atom; timestamp; status }, at)

  let encode_output_property buf (v : output_property) =
    Xproto.encode_window buf v.window;
    encode_output buf v.output;
    Xproto.encode_atom buf v.atom;
    Xproto.encode_timestamp buf v.timestamp;
    encode_enum encode_uint8 identity Xproto.property_int_of_enum buf v.status;
    encode_pad buf 11;
    ()

  type provider_change = {
    timestamp : Xproto.timestamp;
    window : Xproto.window;
    provider : provider;
  }
  [@@deriving sexp]

  let decode_provider_change buf ~at : (provider_change * int) option =
    let orig = at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* provider, at = decode_provider buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ timestamp; window; provider }, at)

  let encode_provider_change buf (v : provider_change) =
    Xproto.encode_timestamp buf v.timestamp;
    Xproto.encode_window buf v.window;
    encode_provider buf v.provider;
    encode_pad buf 16;
    ()

  type provider_property = {
    window : Xproto.window;
    provider : provider;
    atom : Xproto.atom;
    timestamp : Xproto.timestamp;
    state : int;
  }
  [@@deriving sexp]

  let decode_provider_property buf ~at : (provider_property * int) option =
    let orig = at in
    let* window, at = Xproto.decode_window buf ~at in
    let* provider, at = decode_provider buf ~at in
    let* atom, at = Xproto.decode_atom buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* state, at = decode_uint8 buf ~at in
    let at = at + 11 in
    ignore orig;
    Some ({ window; provider; atom; timestamp; state }, at)

  let encode_provider_property buf (v : provider_property) =
    Xproto.encode_window buf v.window;
    encode_provider buf v.provider;
    Xproto.encode_atom buf v.atom;
    Xproto.encode_timestamp buf v.timestamp;
    encode_uint8 buf v.state;
    encode_pad buf 11;
    ()

  type resource_change = {
    timestamp : Xproto.timestamp;
    window : Xproto.window;
  }
  [@@deriving sexp]

  let decode_resource_change buf ~at : (resource_change * int) option =
    let orig = at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ timestamp; window }, at)

  let encode_resource_change buf (v : resource_change) =
    Xproto.encode_timestamp buf v.timestamp;
    Xproto.encode_window buf v.window;
    encode_pad buf 20;
    ()

  type monitor_info = {
    name : Xproto.atom;
    primary : bool;
    automatic : bool;
    x : int;
    y : int;
    width : int;
    height : int;
    width_in_millimeters : int;
    height_in_millimeters : int;
    outputs : output list;
  }
  [@@deriving sexp]

  let decode_monitor_info buf ~at : (monitor_info * int) option =
    let orig = at in
    let* name, at = Xproto.decode_atom buf ~at in
    let* primary, at = decode_bool buf ~at in
    let* automatic, at = decode_bool buf ~at in
    let* n_output, at = decode_uint16 buf ~at in
    let n_output = n_output in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* width_in_millimeters, at = decode_int32 buf ~at in
    let* height_in_millimeters, at = decode_int32 buf ~at in
    let* outputs, at = decode_list decode_output n_output buf ~at in
    ignore orig;
    Some
      ( {
          name;
          primary;
          automatic;
          x;
          y;
          width;
          height;
          width_in_millimeters;
          height_in_millimeters;
          outputs;
        },
        at )

  let encode_monitor_info buf (v : monitor_info) =
    Xproto.encode_atom buf v.name;
    encode_bool buf v.primary;
    encode_bool buf v.automatic;
    encode_uint16 buf (identity ((* Parsetree.Xid *) List.length v.outputs));
    encode_int16 buf v.x;
    encode_int16 buf v.y;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_int32 buf v.width_in_millimeters;
    encode_int32 buf v.height_in_millimeters;
    encode_list encode_output buf v.outputs;
    ()

  type get_monitors_reply = {
    timestamp : Xproto.timestamp;
    n_outputs : int;
    monitors : monitor_info list;
  }
  [@@deriving sexp]

  let encode_get_monitors ~(window : Xproto.window) ~(get_active : bool) buf =
    (* opcode *)
    encode_uint8 buf 42;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_bool buf get_active;
    (* write request length *)
    encode_request_length buf

  let decode_get_monitors_reply length buf ~at :
      (get_monitors_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* n_monitors, at = decode_int32 buf ~at in
    let n_monitors = n_monitors in
    let* n_outputs, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* monitors, at = decode_list decode_monitor_info n_monitors buf ~at in
    ignore orig;
    Some ({ timestamp; n_outputs; monitors }, at)

  let encode_set_monitor ~(window : Xproto.window) ~(monitorinfo : monitor_info)
      buf =
    (* opcode *)
    encode_uint8 buf 43;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_monitor_info buf monitorinfo;
    (* write request length *)
    encode_request_length buf

  let encode_delete_monitor ~(window : Xproto.window) ~(name : Xproto.atom) buf
      =
    (* opcode *)
    encode_uint8 buf 44;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf name;
    (* write request length *)
    encode_request_length buf

  type create_lease_reply = { nfd : int; master_fd : Unix.file_descr }
  [@@deriving sexp]

  let encode_create_lease ~(window : Xproto.window) ~(lid : lease)
      ~(crtcs : crtc list) ~(outputs : output list) buf =
    (* opcode *)
    encode_uint8 buf 45;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_lease buf lid;
    encode_uint16 buf (identity ((* Parsetree.Xid *) List.length crtcs));
    encode_uint16 buf (identity ((* Parsetree.Xid *) List.length outputs));
    encode_list encode_crtc buf crtcs;
    encode_list encode_output buf outputs;
    (* write request length *)
    encode_request_length buf

  let decode_create_lease_reply length buf ~at :
      (create_lease_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* nfd, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* master_fd, at = decode_file_descr buf ~at in
    let at = at + 24 in
    ignore orig;
    Some ({ nfd; master_fd }, at)

  let encode_free_lease ~(lid : lease) ~(terminate : char) buf =
    (* opcode *)
    encode_uint8 buf 46;
    encode_lease buf lid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_char buf terminate;
    (* write request length *)
    encode_request_length buf

  type lease_notify = {
    timestamp : Xproto.timestamp;
    window : Xproto.window;
    lease : lease;
    created : int;
  }
  [@@deriving sexp]

  let decode_lease_notify buf ~at : (lease_notify * int) option =
    let orig = at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* lease, at = decode_lease buf ~at in
    let* created, at = decode_uint8 buf ~at in
    let at = at + 15 in
    ignore orig;
    Some ({ timestamp; window; lease; created }, at)

  let encode_lease_notify buf (v : lease_notify) =
    Xproto.encode_timestamp buf v.timestamp;
    Xproto.encode_window buf v.window;
    encode_lease buf v.lease;
    encode_uint8 buf v.created;
    encode_pad buf 15;
    ()

  type notify_variant =
    | Crtc_change of { cc : crtc_change }
    | Output_change of { oc : output_change }
    | Output_property of { op : output_property }
    | Provider_change of { pc : provider_change }
    | Provider_property of { pp : provider_property }
    | Resource_change of { rc : resource_change }
    | Lease of { lc : lease_notify }
  [@@deriving sexp]

  let decode_notify_variant tag buf ~at : (notify_variant * int) option =
    match tag with
    | 0 ->
        let* cc, at = decode_crtc_change buf ~at in
        Some (Crtc_change { cc }, at)
    | 1 ->
        let* oc, at = decode_output_change buf ~at in
        Some (Output_change { oc }, at)
    | 2 ->
        let* op, at = decode_output_property buf ~at in
        Some (Output_property { op }, at)
    | 3 ->
        let* pc, at = decode_provider_change buf ~at in
        Some (Provider_change { pc }, at)
    | 4 ->
        let* pp, at = decode_provider_property buf ~at in
        Some (Provider_property { pp }, at)
    | 5 ->
        let* rc, at = decode_resource_change buf ~at in
        Some (Resource_change { rc }, at)
    | 6 ->
        let* lc, at = decode_lease_notify buf ~at in
        Some (Lease { lc }, at)
    | _ -> None

  type notify_event = notify_variant [@@deriving sexp]

  let decode_notify_event buf ~at : (notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* u_tag, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* u, at = decode_notify_variant u_tag buf ~at in
    ignore orig;
    Some (u, at)
end

module Sync = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type alarm = xid [@@deriving sexp]

  let decode_alarm = decode_xid
  let encode_alarm = encode_xid

  type alarmstate_enum = [ `Active | `Inactive | `Destroyed ] [@@deriving sexp]

  let alarmstate_enum_of_int : int -> [> alarmstate_enum ] option = function
    | 0 -> Some `Active
    | 1 -> Some `Inactive
    | 2 -> Some `Destroyed
    | n ->
        Printf.printf "unknown alarmstate_enum: %d\n" n;
        None

  let alarmstate_int_of_enum : alarmstate_enum -> int = function
    | `Active -> 0
    | `Inactive -> 1
    | `Destroyed -> 2

  type counter = xid [@@deriving sexp]

  let decode_counter = decode_xid
  let encode_counter = encode_xid

  type fence = xid [@@deriving sexp]

  let decode_fence = decode_xid
  let encode_fence = encode_xid

  type testtype_enum =
    [ `Positive_transition
    | `Negative_transition
    | `Positive_comparison
    | `Negative_comparison ]
  [@@deriving sexp]

  let testtype_enum_of_int : int -> [> testtype_enum ] option = function
    | 0 -> Some `Positive_transition
    | 1 -> Some `Negative_transition
    | 2 -> Some `Positive_comparison
    | 3 -> Some `Negative_comparison
    | n ->
        Printf.printf "unknown testtype_enum: %d\n" n;
        None

  let testtype_int_of_enum : testtype_enum -> int = function
    | `Positive_transition -> 0
    | `Negative_transition -> 1
    | `Positive_comparison -> 2
    | `Negative_comparison -> 3

  type valuetype_enum = [ `Absolute | `Relative ] [@@deriving sexp]

  let valuetype_enum_of_int : int -> [> valuetype_enum ] option = function
    | 0 -> Some `Absolute
    | 1 -> Some `Relative
    | n ->
        Printf.printf "unknown valuetype_enum: %d\n" n;
        None

  let valuetype_int_of_enum : valuetype_enum -> int = function
    | `Absolute -> 0
    | `Relative -> 1

  type ca_mask =
    [ `Counter | `Value_type | `Value | `Test_type | `Delta | `Events ] list
  [@@deriving sexp]

  let ca_mask_of_int64 mask : ca_mask option =
    let of_int = function
      | 0 -> Some `Counter
      | 1 -> Some `Value_type
      | 2 -> Some `Value
      | 3 -> Some `Test_type
      | 4 -> Some `Delta
      | 5 -> Some `Events
      | _ -> None
    in
    mask_of_int of_int mask

  let ca_int_of_mask : ca_mask -> int =
    let to_bit = function
      | `Counter -> 0
      | `Value_type -> 1
      | `Value -> 2
      | `Test_type -> 3
      | `Delta -> 4
      | `Events -> 5
    in
    int_of_mask to_bit

  type int64 = { hi : int; lo : int } [@@deriving sexp]

  let decode_int64 buf ~at : (int64 * int) option =
    let orig = at in
    let* hi, at = decode_int32 buf ~at in
    let* lo, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ hi; lo }, at)

  let encode_int64 buf (v : int64) =
    encode_int32 buf v.hi;
    encode_int32 buf v.lo;
    ()

  type systemcounter = { counter : counter; resolution : int64; name : string }
  [@@deriving sexp]

  let decode_systemcounter buf ~at : (systemcounter * int) option =
    let orig = at in
    let* counter, at = decode_counter buf ~at in
    let* resolution, at = decode_int64 buf ~at in
    let* name_len, at = decode_uint16 buf ~at in
    let name_len = name_len in
    let* name, at = decode_string name_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ counter; resolution; name }, at)

  let encode_systemcounter buf (v : systemcounter) =
    encode_counter buf v.counter;
    encode_int64 buf v.resolution;
    encode_uint16 buf (identity (String.length v.name));
    encode_string buf v.name;
    encode_align buf 4;
    ()

  type trigger = {
    counter : counter;
    wait_type : valuetype_enum;
    wait_value : int64;
    test_type : testtype_enum;
  }
  [@@deriving sexp]

  let decode_trigger buf ~at : (trigger * int) option =
    let orig = at in
    let* counter, at = decode_counter buf ~at in
    let* wait_type, at =
      decode_enum decode_int32 identity valuetype_enum_of_int buf ~at
    in
    let* wait_value, at = decode_int64 buf ~at in
    let* test_type, at =
      decode_enum decode_int32 identity testtype_enum_of_int buf ~at
    in
    ignore orig;
    Some ({ counter; wait_type; wait_value; test_type }, at)

  let encode_trigger buf (v : trigger) =
    encode_counter buf v.counter;
    encode_enum encode_int32 identity valuetype_int_of_enum buf v.wait_type;
    encode_int64 buf v.wait_value;
    encode_enum encode_int32 identity testtype_int_of_enum buf v.test_type;
    ()

  type waitcondition = { trigger : trigger; event_threshold : int64 }
  [@@deriving sexp]

  let decode_waitcondition buf ~at : (waitcondition * int) option =
    let orig = at in
    let* trigger, at = decode_trigger buf ~at in
    let* event_threshold, at = decode_int64 buf ~at in
    ignore orig;
    Some ({ trigger; event_threshold }, at)

  let encode_waitcondition buf (v : waitcondition) =
    encode_trigger buf v.trigger;
    encode_int64 buf v.event_threshold;
    ()

  type counter_error = {
    bad_counter : int;
    minor_opcode : int;
    major_opcode : int;
  }
  [@@deriving sexp]

  type alarm_error = { bad_alarm : int; minor_opcode : int; major_opcode : int }
  [@@deriving sexp]

  type initialize_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_initialize ~(desired_major_version : int)
      ~(desired_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint8 buf desired_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf desired_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_initialize_reply length buf ~at : (initialize_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint8 buf ~at in
    let* minor_version, at = decode_uint8 buf ~at in
    let at = at + 22 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type list_system_counters_reply = systemcounter list [@@deriving sexp]

  let encode_list_system_counters buf =
    (* opcode *)
    encode_uint8 buf 1;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_list_system_counters_reply length buf ~at :
      (list_system_counters_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* counters_len, at = decode_int32 buf ~at in
    let counters_len = counters_len in
    let at = at + 20 in
    let* counters, at = decode_list decode_systemcounter counters_len buf ~at in
    ignore orig;
    Some (counters, at)

  let encode_create_counter ~(id : counter) ~(initial_value : int64) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_counter buf id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int64 buf initial_value;
    (* write request length *)
    encode_request_length buf

  let encode_destroy_counter ~(counter : counter) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_counter buf counter;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type query_counter_reply = int64 [@@deriving sexp]

  let encode_query_counter ~(counter : counter) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_counter buf counter;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_counter_reply length buf ~at :
      (query_counter_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* counter_value, at = decode_int64 buf ~at in
    ignore orig;
    Some (counter_value, at)

  let encode_await ~(wait_list : waitcondition list) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_list encode_waitcondition buf wait_list;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_change_counter ~(counter : counter) ~(amount : int64) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_counter buf counter;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int64 buf amount;
    (* write request length *)
    encode_request_length buf

  let encode_set_counter ~(counter : counter) ~(value : int64) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_counter buf counter;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int64 buf value;
    (* write request length *)
    encode_request_length buf

  let encode_create_alarm ~(id : alarm) ?(counter : counter option)
      ?(value_type : valuetype_enum option) ?(value : int64 option)
      ?(test_type : testtype_enum option) ?(delta : int64 option)
      ?(events : int option) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_alarm buf id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some counter, 0);
        (Option.is_some value_type, 1);
        (Option.is_some value, 2);
        (Option.is_some test_type, 3);
        (Option.is_some delta, 4);
        (Option.is_some events, 5);
      ];
    (match counter with None -> () | Some v -> encode_counter buf v);
    (match value_type with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity valuetype_int_of_enum buf v);
    (match value with None -> () | Some v -> encode_int64 buf v);
    (match test_type with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity testtype_int_of_enum buf v);
    (match delta with None -> () | Some v -> encode_int64 buf v);
    (match events with None -> () | Some v -> encode_int32 buf v);
    (* write request length *)
    encode_request_length buf

  let encode_change_alarm ~(id : alarm) ?(counter : counter option)
      ?(value_type : valuetype_enum option) ?(value : int64 option)
      ?(test_type : testtype_enum option) ?(delta : int64 option)
      ?(events : int option) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_alarm buf id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some counter, 0);
        (Option.is_some value_type, 1);
        (Option.is_some value, 2);
        (Option.is_some test_type, 3);
        (Option.is_some delta, 4);
        (Option.is_some events, 5);
      ];
    (match counter with None -> () | Some v -> encode_counter buf v);
    (match value_type with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity valuetype_int_of_enum buf v);
    (match value with None -> () | Some v -> encode_int64 buf v);
    (match test_type with
    | None -> ()
    | Some v -> encode_enum encode_int32 identity testtype_int_of_enum buf v);
    (match delta with None -> () | Some v -> encode_int64 buf v);
    (match events with None -> () | Some v -> encode_int32 buf v);
    (* write request length *)
    encode_request_length buf

  let encode_destroy_alarm ~(alarm : alarm) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_alarm buf alarm;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type query_alarm_reply = {
    trigger : trigger;
    delta : int64;
    events : bool;
    state : alarmstate_enum;
  }
  [@@deriving sexp]

  let encode_query_alarm ~(alarm : alarm) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_alarm buf alarm;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_alarm_reply length buf ~at : (query_alarm_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* trigger, at = decode_trigger buf ~at in
    let* delta, at = decode_int64 buf ~at in
    let* events, at = decode_bool buf ~at in
    let* state, at =
      decode_enum decode_uint8 identity alarmstate_enum_of_int buf ~at
    in
    let at = at + 2 in
    ignore orig;
    Some ({ trigger; delta; events; state }, at)

  let encode_set_priority ~(id : int) ~(priority : int) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_int32 buf id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf priority;
    (* write request length *)
    encode_request_length buf

  type get_priority_reply = int [@@deriving sexp]

  let encode_get_priority ~(id : int) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_int32 buf id;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_priority_reply length buf ~at :
      (get_priority_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* priority, at = decode_int32 buf ~at in
    ignore orig;
    Some (priority, at)

  let encode_create_fence ~(drawable : Xproto.drawable) ~(fence : fence)
      ~(initially_triggered : bool) buf =
    (* opcode *)
    encode_uint8 buf 14;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_fence buf fence;
    encode_bool buf initially_triggered;
    (* write request length *)
    encode_request_length buf

  let encode_trigger_fence ~(fence : fence) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_fence buf fence;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_reset_fence ~(fence : fence) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_fence buf fence;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_destroy_fence ~(fence : fence) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_fence buf fence;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type query_fence_reply = bool [@@deriving sexp]

  let encode_query_fence ~(fence : fence) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_fence buf fence;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_fence_reply length buf ~at : (query_fence_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* triggered, at = decode_bool buf ~at in
    let at = at + 23 in
    ignore orig;
    Some (triggered, at)

  let encode_await_fence ~(fence_list : fence list) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_list encode_fence buf fence_list;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type counter_notify_event = {
    kind : int;
    counter : counter;
    wait_value : int64;
    counter_value : int64;
    timestamp : Xproto.timestamp;
    count : int;
    destroyed : bool;
  }
  [@@deriving sexp]

  let decode_counter_notify_event buf ~at : (counter_notify_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* kind, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* counter, at = decode_counter buf ~at in
    let* wait_value, at = decode_int64 buf ~at in
    let* counter_value, at = decode_int64 buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* count, at = decode_uint16 buf ~at in
    let* destroyed, at = decode_bool buf ~at in
    let at = at + 1 in
    ignore orig;
    Some
      ( { kind; counter; wait_value; counter_value; timestamp; count; destroyed },
        at )

  type alarm_notify_event = {
    kind : int;
    alarm : alarm;
    counter_value : int64;
    alarm_value : int64;
    timestamp : Xproto.timestamp;
    state : alarmstate_enum;
  }
  [@@deriving sexp]

  let decode_alarm_notify_event buf ~at : (alarm_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* kind, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* alarm, at = decode_alarm buf ~at in
    let* counter_value, at = decode_int64 buf ~at in
    let* alarm_value, at = decode_int64 buf ~at in
    let* timestamp, at = Xproto.decode_timestamp buf ~at in
    let* state, at =
      decode_enum decode_uint8 identity alarmstate_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some ({ kind; alarm; counter_value; alarm_value; timestamp; state }, at)
end

module Present = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type event_enum =
    [ `Configure_notify | `Complete_notify | `Idle_notify | `Redirect_notify ]
  [@@deriving sexp]

  let event_enum_of_int : int -> [> event_enum ] option = function
    | 0 -> Some `Configure_notify
    | 1 -> Some `Complete_notify
    | 2 -> Some `Idle_notify
    | 3 -> Some `Redirect_notify
    | n ->
        Printf.printf "unknown event_enum: %d\n" n;
        None

  let event_int_of_enum : event_enum -> int = function
    | `Configure_notify -> 0
    | `Complete_notify -> 1
    | `Idle_notify -> 2
    | `Redirect_notify -> 3

  type event_mask =
    [ `Configure_notify | `Complete_notify | `Idle_notify | `Redirect_notify ]
    list
    option
  [@@deriving sexp]

  let event_mask_mask_of_int64 mask : event_mask option =
    let of_mask = function
      | 0 -> Some `Configure_notify
      | 1 -> Some `Complete_notify
      | 2 -> Some `Idle_notify
      | 3 -> Some `Redirect_notify
      | _ -> None
    in
    if mask = 0L then Some None
    else mask_of_int of_mask mask |> Option.map (fun m -> Some m)

  let event_mask_int_of_mask (mask : event_mask) : int =
    let to_mask = function
      | `Configure_notify -> 0
      | `Complete_notify -> 1
      | `Idle_notify -> 2
      | `Redirect_notify -> 3
    in
    match mask with None -> 0 | Some mask -> int_of_mask to_mask mask

  type option_mask = [ `Async | `Copy | `Ust | `Suboptimal ] list option
  [@@deriving sexp]

  let option_mask_of_int64 mask : option_mask option =
    let of_mask = function
      | 0 -> Some `Async
      | 1 -> Some `Copy
      | 2 -> Some `Ust
      | 3 -> Some `Suboptimal
      | _ -> None
    in
    if mask = 0L then Some None
    else mask_of_int of_mask mask |> Option.map (fun m -> Some m)

  let option_int_of_mask (mask : option_mask) : int =
    let to_mask = function
      | `Async -> 0
      | `Copy -> 1
      | `Ust -> 2
      | `Suboptimal -> 3
    in
    match mask with None -> 0 | Some mask -> int_of_mask to_mask mask

  type capability_mask = [ `Async | `Fence | `Ust ] list option
  [@@deriving sexp]

  let capability_mask_of_int64 mask : capability_mask option =
    let of_mask = function
      | 0 -> Some `Async
      | 1 -> Some `Fence
      | 2 -> Some `Ust
      | _ -> None
    in
    if mask = 0L then Some None
    else mask_of_int of_mask mask |> Option.map (fun m -> Some m)

  let capability_int_of_mask (mask : capability_mask) : int =
    let to_mask = function `Async -> 0 | `Fence -> 1 | `Ust -> 2 in
    match mask with None -> 0 | Some mask -> int_of_mask to_mask mask

  type complete_kind_enum = [ `Pixmap | `Notify_msc ] [@@deriving sexp]

  let complete_kind_enum_of_int : int -> [> complete_kind_enum ] option =
    function
    | 0 -> Some `Pixmap
    | 1 -> Some `Notify_msc
    | n ->
        Printf.printf "unknown complete_kind_enum: %d\n" n;
        None

  let complete_kind_int_of_enum : complete_kind_enum -> int = function
    | `Pixmap -> 0
    | `Notify_msc -> 1

  type complete_mode_enum = [ `Copy | `Flip | `Skip | `Suboptimal_copy ]
  [@@deriving sexp]

  let complete_mode_enum_of_int : int -> [> complete_mode_enum ] option =
    function
    | 0 -> Some `Copy
    | 1 -> Some `Flip
    | 2 -> Some `Skip
    | 3 -> Some `Suboptimal_copy
    | n ->
        Printf.printf "unknown complete_mode_enum: %d\n" n;
        None

  let complete_mode_int_of_enum : complete_mode_enum -> int = function
    | `Copy -> 0
    | `Flip -> 1
    | `Skip -> 2
    | `Suboptimal_copy -> 3

  type notify = { window : Xproto.window; serial : int } [@@deriving sexp]

  let decode_notify buf ~at : (notify * int) option =
    let orig = at in
    let* window, at = Xproto.decode_window buf ~at in
    let* serial, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ window; serial }, at)

  let encode_notify buf (v : notify) =
    Xproto.encode_window buf v.window;
    encode_int32 buf v.serial;
    ()

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_int32 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_int32 buf ~at in
    let* minor_version, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  let encode_pixmap ~(window : Xproto.window) ~(pixmap : Xproto.pixmap)
      ~(serial : int) ~(valid : Xfixes.region) ~(update : Xfixes.region)
      ~(x_off : int) ~(y_off : int) ~(target_crtc : Randr.crtc)
      ~(wait_fence : Sync.fence) ~(idle_fence : Sync.fence) ~(options : int)
      ~(target_msc : int64) ~(divisor : int64) ~(remainder : int64)
      ~(notifies : notify list) buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_pixmap buf pixmap;
    encode_int32 buf serial;
    Xfixes.encode_region buf valid;
    Xfixes.encode_region buf update;
    encode_int16 buf x_off;
    encode_int16 buf y_off;
    Randr.encode_crtc buf target_crtc;
    Sync.encode_fence buf wait_fence;
    Sync.encode_fence buf idle_fence;
    encode_int32 buf options;
    encode_pad buf 4;
    encode_int64 buf target_msc;
    encode_int64 buf divisor;
    encode_int64 buf remainder;
    encode_list encode_notify buf notifies;
    (* write request length *)
    encode_request_length buf

  let encode_notify_msc ~(window : Xproto.window) ~(serial : int)
      ~(target_msc : int64) ~(divisor : int64) ~(remainder : int64) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf serial;
    encode_pad buf 4;
    encode_int64 buf target_msc;
    encode_int64 buf divisor;
    encode_int64 buf remainder;
    (* write request length *)
    encode_request_length buf

  type event = xid [@@deriving sexp]

  let decode_event = decode_xid
  let encode_event = encode_xid

  let encode_select_input ~(eid : event) ~(window : Xproto.window)
      ~(event_mask : event_mask) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_event buf eid;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf window;
    encode_mask encode_int32 identity event_mask_int_of_mask buf event_mask;
    (* write request length *)
    encode_request_length buf

  type query_capabilities_reply = int [@@deriving sexp]

  let encode_query_capabilities ~(target : int) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_int32 buf target;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_capabilities_reply length buf ~at :
      (query_capabilities_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* capabilities, at = decode_int32 buf ~at in
    ignore orig;
    Some (capabilities, at)

  type generic_event = {
    extension : int;
    length : int;
    evtype : int;
    event : event;
  }
  [@@deriving sexp]

  let decode_generic_event buf ~at : (generic_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* extension, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* length, at = decode_int32 buf ~at in
    let* evtype, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* event, at = decode_event buf ~at in
    ignore orig;
    Some ({ extension; length; evtype; event }, at)

  type configure_notify_event = {
    event : event;
    window : Xproto.window;
    x : int;
    y : int;
    width : int;
    height : int;
    off_x : int;
    off_y : int;
    pixmap_width : int;
    pixmap_height : int;
    pixmap_flags : int;
  }
  [@@deriving sexp]

  let decode_configure_notify_event buf ~at :
      (configure_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 2 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_event buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* x, at = decode_int16 buf ~at in
    let* y, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* off_x, at = decode_int16 buf ~at in
    let* off_y, at = decode_int16 buf ~at in
    let* pixmap_width, at = decode_uint16 buf ~at in
    let* pixmap_height, at = decode_uint16 buf ~at in
    let* pixmap_flags, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( {
          event;
          window;
          x;
          y;
          width;
          height;
          off_x;
          off_y;
          pixmap_width;
          pixmap_height;
          pixmap_flags;
        },
        at )

  type complete_notify_event = {
    kind : complete_kind_enum;
    mode : complete_mode_enum;
    event : event;
    window : Xproto.window;
    serial : int;
    ust : int64;
    msc : int64;
  }
  [@@deriving sexp]

  let decode_complete_notify_event buf ~at :
      (complete_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* kind, at =
      decode_enum decode_uint8 identity complete_kind_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* mode, at =
      decode_enum decode_uint8 identity complete_mode_enum_of_int buf ~at
    in
    let* event, at = decode_event buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* serial, at = decode_int32 buf ~at in
    let* ust, at = decode_int64 buf ~at in
    let* msc, at = decode_int64 buf ~at in
    ignore orig;
    Some ({ kind; mode; event; window; serial; ust; msc }, at)

  type idle_notify_event = {
    event : event;
    window : Xproto.window;
    serial : int;
    pixmap : Xproto.pixmap;
    idle_fence : Sync.fence;
  }
  [@@deriving sexp]

  let decode_idle_notify_event buf ~at : (idle_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 2 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* event, at = decode_event buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* serial, at = decode_int32 buf ~at in
    let* pixmap, at = Xproto.decode_pixmap buf ~at in
    let* idle_fence, at = Sync.decode_fence buf ~at in
    ignore orig;
    Some ({ event; window; serial; pixmap; idle_fence }, at)

  type redirect_notify_event = {
    update_window : bool;
    event : event;
    event_window : Xproto.window;
    window : Xproto.window;
    pixmap : Xproto.pixmap;
    serial : int;
    valid_region : Xfixes.region;
    update_region : Xfixes.region;
    valid_rect : Xproto.rectangle;
    update_rect : Xproto.rectangle;
    x_off : int;
    y_off : int;
    target_crtc : Randr.crtc;
    wait_fence : Sync.fence;
    idle_fence : Sync.fence;
    options : int;
    target_msc : int64;
    divisor : int64;
    remainder : int64;
    notifies : notify list;
  }
  [@@deriving sexp]
end

module Record = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type context = xid [@@deriving sexp]

  let decode_context = decode_xid
  let encode_context = encode_xid

  type range8 = { first : int; last : int } [@@deriving sexp]

  let decode_range8 buf ~at : (range8 * int) option =
    let orig = at in
    let* first, at = decode_uint8 buf ~at in
    let* last, at = decode_uint8 buf ~at in
    ignore orig;
    Some ({ first; last }, at)

  let encode_range8 buf (v : range8) =
    encode_uint8 buf v.first;
    encode_uint8 buf v.last;
    ()

  type range16 = { first : int; last : int } [@@deriving sexp]

  let decode_range16 buf ~at : (range16 * int) option =
    let orig = at in
    let* first, at = decode_uint16 buf ~at in
    let* last, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ first; last }, at)

  let encode_range16 buf (v : range16) =
    encode_uint16 buf v.first;
    encode_uint16 buf v.last;
    ()

  type ext_range = { major : range8; minor : range16 } [@@deriving sexp]

  let decode_ext_range buf ~at : (ext_range * int) option =
    let orig = at in
    let* major, at = decode_range8 buf ~at in
    let* minor, at = decode_range16 buf ~at in
    ignore orig;
    Some ({ major; minor }, at)

  let encode_ext_range buf (v : ext_range) =
    encode_range8 buf v.major;
    encode_range16 buf v.minor;
    ()

  type range = {
    core_requests : range8;
    core_replies : range8;
    ext_requests : ext_range;
    ext_replies : ext_range;
    delivered_events : range8;
    device_events : range8;
    errors : range8;
    client_started : bool;
    client_died : bool;
  }
  [@@deriving sexp]

  let decode_range buf ~at : (range * int) option =
    let orig = at in
    let* core_requests, at = decode_range8 buf ~at in
    let* core_replies, at = decode_range8 buf ~at in
    let* ext_requests, at = decode_ext_range buf ~at in
    let* ext_replies, at = decode_ext_range buf ~at in
    let* delivered_events, at = decode_range8 buf ~at in
    let* device_events, at = decode_range8 buf ~at in
    let* errors, at = decode_range8 buf ~at in
    let* client_started, at = decode_bool buf ~at in
    let* client_died, at = decode_bool buf ~at in
    ignore orig;
    Some
      ( {
          core_requests;
          core_replies;
          ext_requests;
          ext_replies;
          delivered_events;
          device_events;
          errors;
          client_started;
          client_died;
        },
        at )

  let encode_range buf (v : range) =
    encode_range8 buf v.core_requests;
    encode_range8 buf v.core_replies;
    encode_ext_range buf v.ext_requests;
    encode_ext_range buf v.ext_replies;
    encode_range8 buf v.delivered_events;
    encode_range8 buf v.device_events;
    encode_range8 buf v.errors;
    encode_bool buf v.client_started;
    encode_bool buf v.client_died;
    ()

  type element_header = int [@@deriving sexp]

  let decode_element_header = decode_uint8
  let encode_element_header = encode_uint8

  type h_type_mask =
    [ `From_server_time | `From_client_time | `From_client_sequence ] list
  [@@deriving sexp]

  let h_type_mask_of_int64 mask : h_type_mask option =
    let of_int = function
      | 0 -> Some `From_server_time
      | 1 -> Some `From_client_time
      | 2 -> Some `From_client_sequence
      | _ -> None
    in
    mask_of_int of_int mask

  let h_type_int_of_mask : h_type_mask -> int =
    let to_bit = function
      | `From_server_time -> 0
      | `From_client_time -> 1
      | `From_client_sequence -> 2
    in
    int_of_mask to_bit

  type client_spec = int [@@deriving sexp]

  let decode_client_spec = decode_int32
  let encode_client_spec = encode_int32

  type cs_enum = [ `Current_clients | `Future_clients | `All_clients ]
  [@@deriving sexp]

  let cs_enum_of_int : int -> [> cs_enum ] option = function
    | 1 -> Some `Current_clients
    | 2 -> Some `Future_clients
    | 3 -> Some `All_clients
    | n ->
        Printf.printf "unknown cs_enum: %d\n" n;
        None

  let cs_int_of_enum : cs_enum -> int = function
    | `Current_clients -> 1
    | `Future_clients -> 2
    | `All_clients -> 3

  type client_info = { client_resource : client_spec; ranges : range list }
  [@@deriving sexp]

  let decode_client_info buf ~at : (client_info * int) option =
    let orig = at in
    let* client_resource, at = decode_client_spec buf ~at in
    let* num_ranges, at = decode_int32 buf ~at in
    let num_ranges = num_ranges in
    let* ranges, at = decode_list decode_range num_ranges buf ~at in
    ignore orig;
    Some ({ client_resource; ranges }, at)

  let encode_client_info buf (v : client_info) =
    encode_client_spec buf v.client_resource;
    encode_int32 buf (identity ((* invalid_argument *) List.length v.ranges));
    encode_list encode_range buf v.ranges;
    ()

  type bad_context_error = int [@@deriving sexp]

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint16 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  let encode_create_context ~(context : context)
      ~(element_header : element_header) ~(client_specs : client_spec list)
      ~(ranges : range list) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_element_header buf element_header;
    encode_pad buf 3;
    encode_int32 buf
      (identity ((* Parsetree.Card32 *) List.length client_specs));
    encode_int32 buf (identity ((* invalid_argument *) List.length ranges));
    encode_list encode_client_spec buf client_specs;
    encode_list encode_range buf ranges;
    (* write request length *)
    encode_request_length buf

  let encode_register_clients ~(context : context)
      ~(element_header : element_header) ~(client_specs : client_spec list)
      ~(ranges : range list) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_element_header buf element_header;
    encode_pad buf 3;
    encode_int32 buf
      (identity ((* Parsetree.Card32 *) List.length client_specs));
    encode_int32 buf (identity ((* invalid_argument *) List.length ranges));
    encode_list encode_client_spec buf client_specs;
    encode_list encode_range buf ranges;
    (* write request length *)
    encode_request_length buf

  let encode_unregister_clients ~(context : context)
      ~(client_specs : client_spec list) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf
      (identity ((* Parsetree.Card32 *) List.length client_specs));
    encode_list encode_client_spec buf client_specs;
    (* write request length *)
    encode_request_length buf

  type get_context_reply = {
    enabled : bool;
    element_header : element_header;
    intercepted_clients : client_info list;
  }
  [@@deriving sexp]

  let encode_get_context ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_context_reply length buf ~at : (get_context_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* enabled, at = decode_bool buf ~at in
    let at = at + 6 in
    let* element_header, at = decode_element_header buf ~at in
    let at = at + 3 in
    let* num_intercepted_clients, at = decode_int32 buf ~at in
    let num_intercepted_clients = num_intercepted_clients in
    let at = at + 16 in
    let* intercepted_clients, at =
      decode_list decode_client_info num_intercepted_clients buf ~at
    in
    ignore orig;
    Some ({ enabled; element_header; intercepted_clients }, at)

  type enable_context_reply = {
    category : int;
    element_header : element_header;
    client_swapped : bool;
    xid_base : int;
    server_time : int;
    rec_sequence_num : int;
    data : char list;
  }
  [@@deriving sexp]

  let encode_enable_context ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_enable_context_reply length buf ~at :
      (enable_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* category, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* element_header, at = decode_element_header buf ~at in
    let* client_swapped, at = decode_bool buf ~at in
    let at = at + 2 in
    let* xid_base, at = decode_int32 buf ~at in
    let* server_time, at = decode_int32 buf ~at in
    let* rec_sequence_num, at = decode_int32 buf ~at in
    let at = at + 8 in
    let* data, at =
      let length = length * 4 in
      decode_list decode_char length buf ~at
    in
    ignore orig;
    Some
      ( {
          category;
          element_header;
          client_swapped;
          xid_base;
          server_time;
          rec_sequence_num;
          data;
        },
        at )

  let encode_disable_context ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_free_context ~(context : context) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_context buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf
end

module Res = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type client = { resource_base : int; resource_mask : int } [@@deriving sexp]

  let decode_client buf ~at : (client * int) option =
    let orig = at in
    let* resource_base, at = decode_int32 buf ~at in
    let* resource_mask, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ resource_base; resource_mask }, at)

  let encode_client buf (v : client) =
    encode_int32 buf v.resource_base;
    encode_int32 buf v.resource_mask;
    ()

  type type_ = { resource_type : Xproto.atom; count : int } [@@deriving sexp]

  let decode_type buf ~at : (type_ * int) option =
    let orig = at in
    let* resource_type, at = Xproto.decode_atom buf ~at in
    let* count, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ resource_type; count }, at)

  let encode_type buf (v : type_) =
    Xproto.encode_atom buf v.resource_type;
    encode_int32 buf v.count;
    ()

  type client_id_mask = [ `Client_xid | `Local_client_pid ] list
  [@@deriving sexp]

  let client_id_mask_mask_of_int64 mask : client_id_mask option =
    let of_int = function
      | 0 -> Some `Client_xid
      | 1 -> Some `Local_client_pid
      | _ -> None
    in
    mask_of_int of_int mask

  let client_id_mask_int_of_mask : client_id_mask -> int =
    let to_bit = function `Client_xid -> 0 | `Local_client_pid -> 1 in
    int_of_mask to_bit

  type client_id_spec = { client : int; mask : client_id_mask }
  [@@deriving sexp]

  let decode_client_id_spec buf ~at : (client_id_spec * int) option =
    let orig = at in
    let* client, at = decode_int32 buf ~at in
    let* mask, at =
      decode_mask decode_int32 Int64.of_int client_id_mask_mask_of_int64 buf ~at
    in
    ignore orig;
    Some ({ client; mask }, at)

  let encode_client_id_spec buf (v : client_id_spec) =
    encode_int32 buf v.client;
    encode_mask encode_int32 identity client_id_mask_int_of_mask buf v.mask;
    ()

  type client_id_value = { spec : client_id_spec; value : int list }
  [@@deriving sexp]

  let decode_client_id_value buf ~at : (client_id_value * int) option =
    let orig = at in
    let* spec, at = decode_client_id_spec buf ~at in
    let* length, at = decode_int32 buf ~at in
    let length = length * 4 in
    let* value, at = decode_list decode_int32 length buf ~at in
    ignore orig;
    Some ({ spec; value }, at)

  let encode_client_id_value buf (v : client_id_value) =
    encode_client_id_spec buf v.spec;
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length v.value));
    encode_list encode_int32 buf v.value;
    ()

  type resource_id_spec = { resource : int; type_ : int } [@@deriving sexp]

  let decode_resource_id_spec buf ~at : (resource_id_spec * int) option =
    let orig = at in
    let* resource, at = decode_int32 buf ~at in
    let* type_, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ resource; type_ }, at)

  let encode_resource_id_spec buf (v : resource_id_spec) =
    encode_int32 buf v.resource;
    encode_int32 buf v.type_;
    ()

  type resource_size_spec = {
    spec : resource_id_spec;
    bytes : int;
    ref_count : int;
    use_count : int;
  }
  [@@deriving sexp]

  let decode_resource_size_spec buf ~at : (resource_size_spec * int) option =
    let orig = at in
    let* spec, at = decode_resource_id_spec buf ~at in
    let* bytes, at = decode_int32 buf ~at in
    let* ref_count, at = decode_int32 buf ~at in
    let* use_count, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ spec; bytes; ref_count; use_count }, at)

  let encode_resource_size_spec buf (v : resource_size_spec) =
    encode_resource_id_spec buf v.spec;
    encode_int32 buf v.bytes;
    encode_int32 buf v.ref_count;
    encode_int32 buf v.use_count;
    ()

  type resource_size_value = {
    size : resource_size_spec;
    cross_references : resource_size_spec list;
  }
  [@@deriving sexp]

  let decode_resource_size_value buf ~at : (resource_size_value * int) option =
    let orig = at in
    let* size, at = decode_resource_size_spec buf ~at in
    let* num_cross_references, at = decode_int32 buf ~at in
    let num_cross_references = num_cross_references in
    let* cross_references, at =
      decode_list decode_resource_size_spec num_cross_references buf ~at
    in
    ignore orig;
    Some ({ size; cross_references }, at)

  let encode_resource_size_value buf (v : resource_size_value) =
    encode_resource_size_spec buf v.size;
    encode_int32 buf
      (identity ((* invalid_argument *) List.length v.cross_references));
    encode_list encode_resource_size_spec buf v.cross_references;
    ()

  type query_version_reply = { server_major : int; server_minor : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major : int) ~(client_minor : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint8 buf client_major;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf client_minor;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* server_major, at = decode_uint16 buf ~at in
    let* server_minor, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ server_major; server_minor }, at)

  type query_clients_reply = client list [@@deriving sexp]

  let encode_query_clients buf =
    (* opcode *)
    encode_uint8 buf 1;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_clients_reply length buf ~at :
      (query_clients_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_clients, at = decode_int32 buf ~at in
    let num_clients = num_clients in
    let at = at + 20 in
    let* clients, at = decode_list decode_client num_clients buf ~at in
    ignore orig;
    Some (clients, at)

  type query_client_resources_reply = type_ list [@@deriving sexp]

  let encode_query_client_resources ~(xid : int) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_int32 buf xid;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_client_resources_reply length buf ~at :
      (query_client_resources_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_types, at = decode_int32 buf ~at in
    let num_types = num_types in
    let at = at + 20 in
    let* types, at = decode_list decode_type num_types buf ~at in
    ignore orig;
    Some (types, at)

  type query_client_pixmap_bytes_reply = { bytes : int; bytes_overflow : int }
  [@@deriving sexp]

  let encode_query_client_pixmap_bytes ~(xid : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_int32 buf xid;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_client_pixmap_bytes_reply length buf ~at :
      (query_client_pixmap_bytes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* bytes, at = decode_int32 buf ~at in
    let* bytes_overflow, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ bytes; bytes_overflow }, at)

  type query_client_ids_reply = client_id_value list [@@deriving sexp]

  let encode_query_client_ids ~(specs : client_id_spec list) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_int32 buf (identity ((* invalid_argument *) List.length specs));
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_client_id_spec buf specs;
    (* write request length *)
    encode_request_length buf

  let decode_query_client_ids_reply length buf ~at :
      (query_client_ids_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_ids, at = decode_int32 buf ~at in
    let num_ids = num_ids in
    let at = at + 20 in
    let* ids, at = decode_list decode_client_id_value num_ids buf ~at in
    ignore orig;
    Some (ids, at)

  type query_resource_bytes_reply = resource_size_value list [@@deriving sexp]

  let encode_query_resource_bytes ~(client : int)
      ~(specs : resource_id_spec list) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_int32 buf client;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* invalid_argument *) List.length specs));
    encode_list encode_resource_id_spec buf specs;
    (* write request length *)
    encode_request_length buf

  let decode_query_resource_bytes_reply length buf ~at :
      (query_resource_bytes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_sizes, at = decode_int32 buf ~at in
    let num_sizes = num_sizes in
    let at = at + 20 in
    let* sizes, at = decode_list decode_resource_size_value num_sizes buf ~at in
    ignore orig;
    Some (sizes, at)
end

module Screensaver = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type kind_enum = [ `Blanked | `Internal | `External ] [@@deriving sexp]

  let kind_enum_of_int : int -> [> kind_enum ] option = function
    | 0 -> Some `Blanked
    | 1 -> Some `Internal
    | 2 -> Some `External
    | n ->
        Printf.printf "unknown kind_enum: %d\n" n;
        None

  let kind_int_of_enum : kind_enum -> int = function
    | `Blanked -> 0
    | `Internal -> 1
    | `External -> 2

  type event_mask = [ `Notify_mask | `Cycle_mask ] list [@@deriving sexp]

  let event_mask_of_int64 mask : event_mask option =
    let of_int = function
      | 0 -> Some `Notify_mask
      | 1 -> Some `Cycle_mask
      | _ -> None
    in
    mask_of_int of_int mask

  let event_int_of_mask : event_mask -> int =
    let to_bit = function `Notify_mask -> 0 | `Cycle_mask -> 1 in
    int_of_mask to_bit

  type state_enum = [ `Off | `On | `Cycle | `Disabled ] [@@deriving sexp]

  let state_enum_of_int : int -> [> state_enum ] option = function
    | 0 -> Some `Off
    | 1 -> Some `On
    | 2 -> Some `Cycle
    | 3 -> Some `Disabled
    | n ->
        Printf.printf "unknown state_enum: %d\n" n;
        None

  let state_int_of_enum : state_enum -> int = function
    | `Off -> 0
    | `On -> 1
    | `Cycle -> 2
    | `Disabled -> 3

  type query_version_reply = {
    server_major_version : int;
    server_minor_version : int;
  }
  [@@deriving sexp]

  let encode_query_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint8 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf client_minor_version;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* server_major_version, at = decode_uint16 buf ~at in
    let* server_minor_version, at = decode_uint16 buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ server_major_version; server_minor_version }, at)

  type query_info_reply = {
    state : int;
    saver_window : Xproto.window;
    ms_until_server : int;
    ms_since_user_input : int;
    event_mask : int;
    kind : kind_enum;
  }
  [@@deriving sexp]

  let encode_query_info ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_info_reply length buf ~at : (query_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* state, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* saver_window, at = Xproto.decode_window buf ~at in
    let* ms_until_server, at = decode_int32 buf ~at in
    let* ms_since_user_input, at = decode_int32 buf ~at in
    let* event_mask, at = decode_int32 buf ~at in
    let* kind, at =
      decode_enum decode_char Char.code kind_enum_of_int buf ~at
    in
    let at = at + 7 in
    ignore orig;
    Some
      ( {
          state;
          saver_window;
          ms_until_server;
          ms_since_user_input;
          event_mask;
          kind;
        },
        at )

  let encode_select_input ~(drawable : Xproto.drawable)
      ~(event_mask : event_mask) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mask encode_int32 identity event_int_of_mask buf event_mask;
    (* write request length *)
    encode_request_length buf

  let encode_set_attributes ~(drawable : Xproto.drawable) ~(x : int) ~(y : int)
      ~(width : int) ~(height : int) ~(border_width : int)
      ~(class_ : Xproto.window_class_enum) ~(depth : int)
      ~(visual : Xproto.visualid)
      ?(background_pixmap : Xproto.back_pixmap_enum alt_enum option)
      ?(background_pixel : int option)
      ?(border_pixmap : Xproto.pixmap_enum alt_enum option)
      ?(border_pixel : int option) ?(bit_gravity : Xproto.gravity_enum option)
      ?(win_gravity : Xproto.gravity_enum option)
      ?(backing_store : Xproto.backing_store_enum option)
      ?(backing_planes : int option) ?(backing_pixel : int option)
      ?(override_redirect : Xproto.bool32 option)
      ?(save_under : Xproto.bool32 option)
      ?(event_mask : Xproto.event_mask option)
      ?(do_not_propogate_mask : Xproto.event_mask option)
      ?(colormap : Xproto.colormap_enum alt_enum option)
      ?(cursor : Xproto.cursor_enum alt_enum option) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_uint16 buf border_width;
    encode_enum encode_char Char.chr Xproto.window_class_int_of_enum buf class_;
    encode_uint8 buf depth;
    Xproto.encode_visualid buf visual;
    encode_optional_mask encode_int32 buf
      [
        (Option.is_some background_pixmap, 0);
        (Option.is_some background_pixel, 1);
        (Option.is_some border_pixmap, 2);
        (Option.is_some border_pixel, 3);
        (Option.is_some bit_gravity, 4);
        (Option.is_some win_gravity, 5);
        (Option.is_some backing_store, 6);
        (Option.is_some backing_planes, 7);
        (Option.is_some backing_pixel, 8);
        (Option.is_some override_redirect, 9);
        (Option.is_some save_under, 10);
        (Option.is_some event_mask, 11);
        (Option.is_some do_not_propogate_mask, 12);
        (Option.is_some colormap, 13);
        (Option.is_some cursor, 14);
      ];
    (match background_pixmap with
    | None -> ()
    | Some v ->
        encode_alt_enum Xproto.encode_pixmap identity
          Xproto.back_pixmap_int_of_enum buf v);
    (match background_pixel with None -> () | Some v -> encode_int32 buf v);
    (match border_pixmap with
    | None -> ()
    | Some v ->
        encode_alt_enum Xproto.encode_pixmap identity Xproto.pixmap_int_of_enum
          buf v);
    (match border_pixel with None -> () | Some v -> encode_int32 buf v);
    (match bit_gravity with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity Xproto.gravity_int_of_enum buf v);
    (match win_gravity with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity Xproto.gravity_int_of_enum buf v);
    (match backing_store with
    | None -> ()
    | Some v ->
        encode_enum encode_int32 identity Xproto.backing_store_int_of_enum buf v);
    (match backing_planes with None -> () | Some v -> encode_int32 buf v);
    (match backing_pixel with None -> () | Some v -> encode_int32 buf v);
    (match override_redirect with
    | None -> ()
    | Some v -> Xproto.encode_bool32 buf v);
    (match save_under with None -> () | Some v -> Xproto.encode_bool32 buf v);
    (match event_mask with
    | None -> ()
    | Some v ->
        encode_mask encode_int32 identity Xproto.event_mask_int_of_mask buf v);
    (match do_not_propogate_mask with
    | None -> ()
    | Some v ->
        encode_mask encode_int32 identity Xproto.event_mask_int_of_mask buf v);
    (match colormap with
    | None -> ()
    | Some v ->
        encode_alt_enum Xproto.encode_colormap identity
          Xproto.colormap_int_of_enum buf v);
    (match cursor with
    | None -> ()
    | Some v ->
        encode_alt_enum Xproto.encode_cursor identity Xproto.cursor_int_of_enum
          buf v);
    (* write request length *)
    encode_request_length buf

  let encode_unset_attributes ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_suspend ~(suspend : int) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_int32 buf suspend;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type notify_event = {
    state : state_enum;
    time : Xproto.timestamp;
    root : Xproto.window;
    window : Xproto.window;
    kind : kind_enum;
    forced : bool;
  }
  [@@deriving sexp]

  let decode_notify_event buf ~at : (notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* state, at =
      decode_enum decode_char Char.code state_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* root, at = Xproto.decode_window buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* kind, at =
      decode_enum decode_char Char.code kind_enum_of_int buf ~at
    in
    let* forced, at = decode_bool buf ~at in
    let at = at + 14 in
    ignore orig;
    Some ({ state; time; root; window; kind; forced }, at)
end

module Shm = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type seg = xid [@@deriving sexp]

  let decode_seg = decode_xid
  let encode_seg = encode_xid

  type completion_event = {
    drawable : Xproto.drawable;
    minor_event : int;
    major_event : char;
    shmseg : seg;
    offset : int;
  }
  [@@deriving sexp]

  let decode_completion_event buf ~at : (completion_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* drawable, at = Xproto.decode_drawable buf ~at in
    let* minor_event, at = decode_uint16 buf ~at in
    let* major_event, at = decode_char buf ~at in
    let at = at + 1 in
    let* shmseg, at = decode_seg buf ~at in
    let* offset, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ drawable; minor_event; major_event; shmseg; offset }, at)

  type bad_seg_error = Xproto.value_error [@@deriving sexp]

  type query_version_reply = {
    shared_pixmaps : bool;
    major_version : int;
    minor_version : int;
    uid : int;
    gid : int;
    pixmap_format : int;
  }
  [@@deriving sexp]

  let encode_query_version buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* shared_pixmaps, at = decode_bool buf ~at in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    let* uid, at = decode_uint16 buf ~at in
    let* gid, at = decode_uint16 buf ~at in
    let* pixmap_format, at = decode_uint8 buf ~at in
    let at = at + 15 in
    ignore orig;
    Some
      ( { shared_pixmaps; major_version; minor_version; uid; gid; pixmap_format },
        at )

  let encode_attach ~(shmseg : seg) ~(shmid : int) ~(read_only : bool) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_seg buf shmseg;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf shmid;
    encode_bool buf read_only;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_detach ~(shmseg : seg) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_seg buf shmseg;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_put_image ~(drawable : Xproto.drawable) ~(gc : Xproto.gcontext)
      ~(total_width : int) ~(total_height : int) ~(src_x : int) ~(src_y : int)
      ~(src_width : int) ~(src_height : int) ~(dst_x : int) ~(dst_y : int)
      ~(depth : int) ~(format : int) ~(send_event : bool) ~(shmseg : seg)
      ~(offset : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_gcontext buf gc;
    encode_uint16 buf total_width;
    encode_uint16 buf total_height;
    encode_uint16 buf src_x;
    encode_uint16 buf src_y;
    encode_uint16 buf src_width;
    encode_uint16 buf src_height;
    encode_int16 buf dst_x;
    encode_int16 buf dst_y;
    encode_uint8 buf depth;
    encode_uint8 buf format;
    encode_bool buf send_event;
    encode_pad buf 1;
    encode_seg buf shmseg;
    encode_int32 buf offset;
    (* write request length *)
    encode_request_length buf

  type get_image_reply = { depth : int; visual : Xproto.visualid; size : int }
  [@@deriving sexp]

  let encode_get_image ~(drawable : Xproto.drawable) ~(x : int) ~(y : int)
      ~(width : int) ~(height : int) ~(plane_mask : int) ~(format : int)
      ~(shmseg : seg) ~(offset : int) buf =
    (* opcode *)
    encode_uint8 buf 4;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int16 buf x;
    encode_int16 buf y;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int32 buf plane_mask;
    encode_uint8 buf format;
    encode_pad buf 3;
    encode_seg buf shmseg;
    encode_int32 buf offset;
    (* write request length *)
    encode_request_length buf

  let decode_get_image_reply length buf ~at : (get_image_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* visual, at = Xproto.decode_visualid buf ~at in
    let* size, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ depth; visual; size }, at)

  let encode_create_pixmap ~(pid : Xproto.pixmap) ~(drawable : Xproto.drawable)
      ~(width : int) ~(height : int) ~(depth : int) ~(shmseg : seg)
      ~(offset : int) buf =
    (* opcode *)
    encode_uint8 buf 5;
    Xproto.encode_pixmap buf pid;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_uint8 buf depth;
    encode_pad buf 3;
    encode_seg buf shmseg;
    encode_int32 buf offset;
    (* write request length *)
    encode_request_length buf

  let encode_attach_fd ~(shmseg : seg) ~(shm_fd : Unix.file_descr)
      ~(read_only : bool) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_seg buf shmseg;
    (* reserve request length *)
    encode_pad buf 2;
    encode_file_descriptor buf shm_fd;
    encode_bool buf read_only;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type create_segment_reply = { nfd : int; shm_fd : Unix.file_descr }
  [@@deriving sexp]

  let encode_create_segment ~(shmseg : seg) ~(size : int) ~(read_only : bool)
      buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_seg buf shmseg;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf size;
    encode_bool buf read_only;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_create_segment_reply length buf ~at :
      (create_segment_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* nfd, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* shm_fd, at = decode_file_descr buf ~at in
    let at = at + 24 in
    ignore orig;
    Some ({ nfd; shm_fd }, at)
end

module Xc_misc = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type get_version_reply = {
    server_major_version : int;
    server_minor_version : int;
  }
  [@@deriving sexp]

  let encode_get_version ~(client_major_version : int)
      ~(client_minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint16 buf client_major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf client_minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_get_version_reply length buf ~at : (get_version_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* server_major_version, at = decode_uint16 buf ~at in
    let* server_minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ server_major_version; server_minor_version }, at)

  type get_xid_range_reply = { start_id : int; count : int } [@@deriving sexp]

  let encode_get_xid_range buf =
    (* opcode *)
    encode_uint8 buf 1;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_xid_range_reply length buf ~at :
      (get_xid_range_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* start_id, at = decode_int32 buf ~at in
    let* count, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ start_id; count }, at)

  type get_xid_list_reply = int list [@@deriving sexp]

  let encode_get_xid_list ~(count : int) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_int32 buf count;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_xid_list_reply length buf ~at :
      (get_xid_list_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* ids_len, at = decode_int32 buf ~at in
    let ids_len = ids_len in
    let at = at + 20 in
    let* ids, at = decode_list decode_int32 ids_len buf ~at in
    ignore orig;
    Some (ids, at)
end

module Xf86dri = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type drm_clip_rect = { x1 : int; y1 : int; x2 : int; x3 : int }
  [@@deriving sexp]

  let decode_drm_clip_rect buf ~at : (drm_clip_rect * int) option =
    let orig = at in
    let* x1, at = decode_int16 buf ~at in
    let* y1, at = decode_int16 buf ~at in
    let* x2, at = decode_int16 buf ~at in
    let* x3, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ x1; y1; x2; x3 }, at)

  let encode_drm_clip_rect buf (v : drm_clip_rect) =
    encode_int16 buf v.x1;
    encode_int16 buf v.y1;
    encode_int16 buf v.x2;
    encode_int16 buf v.x3;
    ()

  type query_version_reply = {
    dri_major_version : int;
    dri_minor_version : int;
    dri_minor_patch : int;
  }
  [@@deriving sexp]

  let encode_query_version buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* dri_major_version, at = decode_uint16 buf ~at in
    let* dri_minor_version, at = decode_uint16 buf ~at in
    let* dri_minor_patch, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ dri_major_version; dri_minor_version; dri_minor_patch }, at)

  type query_direct_rendering_capable_reply = bool [@@deriving sexp]

  let encode_query_direct_rendering_capable ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_direct_rendering_capable_reply length buf ~at :
      (query_direct_rendering_capable_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* is_capable, at = decode_bool buf ~at in
    ignore orig;
    Some (is_capable, at)

  type open_connection_reply = {
    sarea_handle_low : int;
    sarea_handle_high : int;
    bus_id : string;
  }
  [@@deriving sexp]

  let encode_open_connection ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_open_connection_reply length buf ~at :
      (open_connection_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* sarea_handle_low, at = decode_int32 buf ~at in
    let* sarea_handle_high, at = decode_int32 buf ~at in
    let* bus_id_len, at = decode_int32 buf ~at in
    let bus_id_len = bus_id_len in
    let at = at + 12 in
    let* bus_id, at = decode_string bus_id_len buf ~at in
    ignore orig;
    Some ({ sarea_handle_low; sarea_handle_high; bus_id }, at)

  let encode_close_connection ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type get_client_driver_name_reply = {
    client_driver_major_version : int;
    client_driver_minor_version : int;
    client_driver_patch_version : int;
    client_driver_name : string;
  }
  [@@deriving sexp]

  let encode_get_client_driver_name ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_client_driver_name_reply length buf ~at :
      (get_client_driver_name_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* client_driver_major_version, at = decode_int32 buf ~at in
    let* client_driver_minor_version, at = decode_int32 buf ~at in
    let* client_driver_patch_version, at = decode_int32 buf ~at in
    let* client_driver_name_len, at = decode_int32 buf ~at in
    let client_driver_name_len = client_driver_name_len in
    let at = at + 8 in
    let* client_driver_name, at =
      decode_string client_driver_name_len buf ~at
    in
    ignore orig;
    Some
      ( {
          client_driver_major_version;
          client_driver_minor_version;
          client_driver_patch_version;
          client_driver_name;
        },
        at )

  type create_context_reply = int [@@deriving sexp]

  let encode_create_context ~(screen : int) ~(visual : int) ~(context : int) buf
      =
    (* opcode *)
    encode_uint8 buf 5;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf visual;
    encode_int32 buf context;
    (* write request length *)
    encode_request_length buf

  let decode_create_context_reply length buf ~at :
      (create_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* hw_context, at = decode_int32 buf ~at in
    ignore orig;
    Some (hw_context, at)

  let encode_destroy_context ~(screen : int) ~(context : int) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf context;
    (* write request length *)
    encode_request_length buf

  type create_drawable_reply = int [@@deriving sexp]

  let encode_create_drawable ~(screen : int) ~(drawable : int) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf drawable;
    (* write request length *)
    encode_request_length buf

  let decode_create_drawable_reply length buf ~at :
      (create_drawable_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* hw_drawable_handle, at = decode_int32 buf ~at in
    ignore orig;
    Some (hw_drawable_handle, at)

  let encode_destroy_drawable ~(screen : int) ~(drawable : int) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf drawable;
    (* write request length *)
    encode_request_length buf

  type get_drawable_info_reply = {
    drawable_table_index : int;
    drawable_table_stamp : int;
    drawable_origin_x : int;
    drawable_origin_y : int;
    drawable_size_w : int;
    drawable_size_h : int;
    back_x : int;
    back_y : int;
    clip_rects : drm_clip_rect list;
    back_clip_rects : drm_clip_rect list;
  }
  [@@deriving sexp]

  let encode_get_drawable_info ~(screen : int) ~(drawable : int) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf drawable;
    (* write request length *)
    encode_request_length buf

  let decode_get_drawable_info_reply length buf ~at :
      (get_drawable_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* drawable_table_index, at = decode_int32 buf ~at in
    let* drawable_table_stamp, at = decode_int32 buf ~at in
    let* drawable_origin_x, at = decode_int16 buf ~at in
    let* drawable_origin_y, at = decode_int16 buf ~at in
    let* drawable_size_w, at = decode_int16 buf ~at in
    let* drawable_size_h, at = decode_int16 buf ~at in
    let* num_clip_rects, at = decode_int32 buf ~at in
    let num_clip_rects = num_clip_rects in
    let* back_x, at = decode_int16 buf ~at in
    let* back_y, at = decode_int16 buf ~at in
    let* num_back_clip_rects, at = decode_int32 buf ~at in
    let num_back_clip_rects = num_back_clip_rects in
    let* clip_rects, at =
      decode_list decode_drm_clip_rect num_clip_rects buf ~at
    in
    let* back_clip_rects, at =
      decode_list decode_drm_clip_rect num_back_clip_rects buf ~at
    in
    ignore orig;
    Some
      ( {
          drawable_table_index;
          drawable_table_stamp;
          drawable_origin_x;
          drawable_origin_y;
          drawable_size_w;
          drawable_size_h;
          back_x;
          back_y;
          clip_rects;
          back_clip_rects;
        },
        at )

  type get_device_info_reply = {
    framebuffer_handle_low : int;
    framebuffer_handle_high : int;
    framebuffer_origin_offset : int;
    framebuffer_size : int;
    framebuffer_stride : int;
    device_private : int list;
  }
  [@@deriving sexp]

  let encode_get_device_info ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_device_info_reply length buf ~at :
      (get_device_info_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* framebuffer_handle_low, at = decode_int32 buf ~at in
    let* framebuffer_handle_high, at = decode_int32 buf ~at in
    let* framebuffer_origin_offset, at = decode_int32 buf ~at in
    let* framebuffer_size, at = decode_int32 buf ~at in
    let* framebuffer_stride, at = decode_int32 buf ~at in
    let* device_private_size, at = decode_int32 buf ~at in
    let device_private_size = device_private_size in
    let* device_private, at =
      decode_list decode_int32 device_private_size buf ~at
    in
    ignore orig;
    Some
      ( {
          framebuffer_handle_low;
          framebuffer_handle_high;
          framebuffer_origin_offset;
          framebuffer_size;
          framebuffer_stride;
          device_private;
        },
        at )

  type auth_connection_reply = int [@@deriving sexp]

  let encode_auth_connection ~(screen : int) ~(magic : int) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf magic;
    (* write request length *)
    encode_request_length buf

  let decode_auth_connection_reply length buf ~at :
      (auth_connection_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* authenticated, at = decode_int32 buf ~at in
    ignore orig;
    Some (authenticated, at)
end

module Xf86vidmode = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type syncrange = int [@@deriving sexp]

  let decode_syncrange = decode_int32
  let encode_syncrange = encode_int32

  type dotclock = int [@@deriving sexp]

  let decode_dotclock = decode_int32
  let encode_dotclock = encode_int32

  type mode_flag_mask =
    [ `Positive_h_sync
    | `Negative_h_sync
    | `Positive_v_sync
    | `Negative_v_sync
    | `Interlace
    | `Composite_sync
    | `Positive_c_sync
    | `Negative_c_sync
    | `H_skew
    | `Broadcast
    | `Pixmux
    | `Double_clock
    | `Half_clock ]
    list
  [@@deriving sexp]

  let mode_flag_mask_of_int64 mask : mode_flag_mask option =
    let of_int = function
      | 0 -> Some `Positive_h_sync
      | 1 -> Some `Negative_h_sync
      | 2 -> Some `Positive_v_sync
      | 3 -> Some `Negative_v_sync
      | 4 -> Some `Interlace
      | 5 -> Some `Composite_sync
      | 6 -> Some `Positive_c_sync
      | 7 -> Some `Negative_c_sync
      | 8 -> Some `H_skew
      | 9 -> Some `Broadcast
      | 10 -> Some `Pixmux
      | 11 -> Some `Double_clock
      | 12 -> Some `Half_clock
      | _ -> None
    in
    mask_of_int of_int mask

  let mode_flag_int_of_mask : mode_flag_mask -> int =
    let to_bit = function
      | `Positive_h_sync -> 0
      | `Negative_h_sync -> 1
      | `Positive_v_sync -> 2
      | `Negative_v_sync -> 3
      | `Interlace -> 4
      | `Composite_sync -> 5
      | `Positive_c_sync -> 6
      | `Negative_c_sync -> 7
      | `H_skew -> 8
      | `Broadcast -> 9
      | `Pixmux -> 10
      | `Double_clock -> 11
      | `Half_clock -> 12
    in
    int_of_mask to_bit

  type clock_flag_mask = [ `Programable ] list [@@deriving sexp]

  let clock_flag_mask_of_int64 mask : clock_flag_mask option =
    let of_int = function 0 -> Some `Programable | _ -> None in
    mask_of_int of_int mask

  let clock_flag_int_of_mask : clock_flag_mask -> int =
    let to_bit = function `Programable -> 0 in
    int_of_mask to_bit

  type permission_mask = [ `Read | `Write ] list [@@deriving sexp]

  let permission_mask_of_int64 mask : permission_mask option =
    let of_int = function 0 -> Some `Read | 1 -> Some `Write | _ -> None in
    mask_of_int of_int mask

  let permission_int_of_mask : permission_mask -> int =
    let to_bit = function `Read -> 0 | `Write -> 1 in
    int_of_mask to_bit

  type mode_info = {
    dotclock : dotclock;
    hdisplay : int;
    hsyncstart : int;
    hsyncend : int;
    htotal : int;
    hskew : int;
    vdisplay : int;
    vsyncstart : int;
    vsyncend : int;
    vtotal : int;
    flags : mode_flag_mask;
    privsize : int;
  }
  [@@deriving sexp]

  let decode_mode_info buf ~at : (mode_info * int) option =
    let orig = at in
    let* dotclock, at = decode_dotclock buf ~at in
    let* hdisplay, at = decode_uint16 buf ~at in
    let* hsyncstart, at = decode_uint16 buf ~at in
    let* hsyncend, at = decode_uint16 buf ~at in
    let* htotal, at = decode_uint16 buf ~at in
    let* hskew, at = decode_int32 buf ~at in
    let* vdisplay, at = decode_uint16 buf ~at in
    let* vsyncstart, at = decode_uint16 buf ~at in
    let* vsyncend, at = decode_uint16 buf ~at in
    let* vtotal, at = decode_uint16 buf ~at in
    let at = at + 4 in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int mode_flag_mask_of_int64 buf ~at
    in
    let at = at + 12 in
    let* privsize, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( {
          dotclock;
          hdisplay;
          hsyncstart;
          hsyncend;
          htotal;
          hskew;
          vdisplay;
          vsyncstart;
          vsyncend;
          vtotal;
          flags;
          privsize;
        },
        at )

  let encode_mode_info buf (v : mode_info) =
    encode_dotclock buf v.dotclock;
    encode_uint16 buf v.hdisplay;
    encode_uint16 buf v.hsyncstart;
    encode_uint16 buf v.hsyncend;
    encode_uint16 buf v.htotal;
    encode_int32 buf v.hskew;
    encode_uint16 buf v.vdisplay;
    encode_uint16 buf v.vsyncstart;
    encode_uint16 buf v.vsyncend;
    encode_uint16 buf v.vtotal;
    encode_pad buf 4;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf v.flags;
    encode_pad buf 12;
    encode_int32 buf v.privsize;
    ()

  type query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_query_version buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type get_mode_line_reply = {
    dotclock : dotclock;
    hdisplay : int;
    hsyncstart : int;
    hsyncend : int;
    htotal : int;
    hskew : int;
    vdisplay : int;
    vsyncstart : int;
    vsyncend : int;
    vtotal : int;
    flags : mode_flag_mask;
    private_ : int list;
  }
  [@@deriving sexp]

  let encode_get_mode_line ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_mode_line_reply length buf ~at :
      (get_mode_line_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* dotclock, at = decode_dotclock buf ~at in
    let* hdisplay, at = decode_uint16 buf ~at in
    let* hsyncstart, at = decode_uint16 buf ~at in
    let* hsyncend, at = decode_uint16 buf ~at in
    let* htotal, at = decode_uint16 buf ~at in
    let* hskew, at = decode_uint16 buf ~at in
    let* vdisplay, at = decode_uint16 buf ~at in
    let* vsyncstart, at = decode_uint16 buf ~at in
    let* vsyncend, at = decode_uint16 buf ~at in
    let* vtotal, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int mode_flag_mask_of_int64 buf ~at
    in
    let at = at + 12 in
    let* privsize, at = decode_int32 buf ~at in
    let privsize = privsize in
    let* private_, at = decode_list decode_uint8 privsize buf ~at in
    ignore orig;
    Some
      ( {
          dotclock;
          hdisplay;
          hsyncstart;
          hsyncend;
          htotal;
          hskew;
          vdisplay;
          vsyncstart;
          vsyncend;
          vtotal;
          flags;
          private_;
        },
        at )

  let encode_mod_mode_line ~(screen : int) ~(hdisplay : int) ~(hsyncstart : int)
      ~(hsyncend : int) ~(htotal : int) ~(hskew : int) ~(vdisplay : int)
      ~(vsyncstart : int) ~(vsyncend : int) ~(vtotal : int)
      ~(flags : mode_flag_mask) ~(private_ : int list) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf hdisplay;
    encode_uint16 buf hsyncstart;
    encode_uint16 buf hsyncend;
    encode_uint16 buf htotal;
    encode_uint16 buf hskew;
    encode_uint16 buf vdisplay;
    encode_uint16 buf vsyncstart;
    encode_uint16 buf vsyncend;
    encode_uint16 buf vtotal;
    encode_pad buf 2;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf flags;
    encode_pad buf 12;
    encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_));
    encode_list encode_uint8 buf private_;
    (* write request length *)
    encode_request_length buf

  let encode_switch_mode ~(screen : int) ~(zoom : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf zoom;
    (* write request length *)
    encode_request_length buf

  type get_monitor_reply = {
    hsync : syncrange list;
    vsync : syncrange list;
    vendor : string;
    alignment_pad : string;
    model : string;
  }
  [@@deriving sexp]

  let encode_get_monitor ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_monitor_reply length buf ~at : (get_monitor_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* vendor_length, at = decode_uint8 buf ~at in
    let vendor_length = vendor_length in
    let* model_length, at = decode_uint8 buf ~at in
    let model_length = model_length in
    let* num_hsync, at = decode_uint8 buf ~at in
    let num_hsync = num_hsync in
    let* num_vsync, at = decode_uint8 buf ~at in
    let num_vsync = num_vsync in
    let at = at + 20 in
    let* hsync, at = decode_list decode_syncrange num_hsync buf ~at in
    let* vsync, at = decode_list decode_syncrange num_vsync buf ~at in
    let* vendor, at = decode_string vendor_length buf ~at in
    let* alignment_pad, at =
      let length = ((vendor_length + 3) land lnot 3) - vendor_length in
      decode_string length buf ~at
    in
    let* model, at = decode_string model_length buf ~at in
    ignore orig;
    Some ({ hsync; vsync; vendor; alignment_pad; model }, at)

  let encode_lock_mode_switch ~(screen : int) ~(lock : int) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf lock;
    (* write request length *)
    encode_request_length buf

  type get_all_mode_lines_reply = mode_info list [@@deriving sexp]

  let encode_get_all_mode_lines ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_all_mode_lines_reply length buf ~at :
      (get_all_mode_lines_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* modecount, at = decode_int32 buf ~at in
    let modecount = modecount in
    let at = at + 20 in
    let* modeinfo, at = decode_list decode_mode_info modecount buf ~at in
    ignore orig;
    Some (modeinfo, at)

  let encode_add_mode_line ~(screen : int) ~(dotclock : dotclock)
      ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int)
      ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int)
      ~(vtotal : int) ~(flags : mode_flag_mask) ~(after_dotclock : dotclock)
      ~(after_hdisplay : int) ~(after_hsyncstart : int) ~(after_hsyncend : int)
      ~(after_htotal : int) ~(after_hskew : int) ~(after_vdisplay : int)
      ~(after_vsyncstart : int) ~(after_vsyncend : int) ~(after_vtotal : int)
      ~(after_flags : mode_flag_mask) ~(private_ : int list) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_dotclock buf dotclock;
    encode_uint16 buf hdisplay;
    encode_uint16 buf hsyncstart;
    encode_uint16 buf hsyncend;
    encode_uint16 buf htotal;
    encode_uint16 buf hskew;
    encode_uint16 buf vdisplay;
    encode_uint16 buf vsyncstart;
    encode_uint16 buf vsyncend;
    encode_uint16 buf vtotal;
    encode_pad buf 2;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf flags;
    encode_pad buf 12;
    encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_));
    encode_dotclock buf after_dotclock;
    encode_uint16 buf after_hdisplay;
    encode_uint16 buf after_hsyncstart;
    encode_uint16 buf after_hsyncend;
    encode_uint16 buf after_htotal;
    encode_uint16 buf after_hskew;
    encode_uint16 buf after_vdisplay;
    encode_uint16 buf after_vsyncstart;
    encode_uint16 buf after_vsyncend;
    encode_uint16 buf after_vtotal;
    encode_pad buf 2;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf after_flags;
    encode_pad buf 12;
    encode_list encode_uint8 buf private_;
    (* write request length *)
    encode_request_length buf

  let encode_delete_mode_line ~(screen : int) ~(dotclock : dotclock)
      ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int)
      ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int)
      ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_dotclock buf dotclock;
    encode_uint16 buf hdisplay;
    encode_uint16 buf hsyncstart;
    encode_uint16 buf hsyncend;
    encode_uint16 buf htotal;
    encode_uint16 buf hskew;
    encode_uint16 buf vdisplay;
    encode_uint16 buf vsyncstart;
    encode_uint16 buf vsyncend;
    encode_uint16 buf vtotal;
    encode_pad buf 2;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf flags;
    encode_pad buf 12;
    encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_));
    encode_list encode_uint8 buf private_;
    (* write request length *)
    encode_request_length buf

  type validate_mode_line_reply = int [@@deriving sexp]

  let encode_validate_mode_line ~(screen : int) ~(dotclock : dotclock)
      ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int)
      ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int)
      ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_dotclock buf dotclock;
    encode_uint16 buf hdisplay;
    encode_uint16 buf hsyncstart;
    encode_uint16 buf hsyncend;
    encode_uint16 buf htotal;
    encode_uint16 buf hskew;
    encode_uint16 buf vdisplay;
    encode_uint16 buf vsyncstart;
    encode_uint16 buf vsyncend;
    encode_uint16 buf vtotal;
    encode_pad buf 2;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf flags;
    encode_pad buf 12;
    encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_));
    encode_list encode_uint8 buf private_;
    (* write request length *)
    encode_request_length buf

  let decode_validate_mode_line_reply length buf ~at :
      (validate_mode_line_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* status, at = decode_int32 buf ~at in
    let at = at + 20 in
    ignore orig;
    Some (status, at)

  let encode_switch_to_mode ~(screen : int) ~(dotclock : dotclock)
      ~(hdisplay : int) ~(hsyncstart : int) ~(hsyncend : int) ~(htotal : int)
      ~(hskew : int) ~(vdisplay : int) ~(vsyncstart : int) ~(vsyncend : int)
      ~(vtotal : int) ~(flags : mode_flag_mask) ~(private_ : int list) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_int32 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_dotclock buf dotclock;
    encode_uint16 buf hdisplay;
    encode_uint16 buf hsyncstart;
    encode_uint16 buf hsyncend;
    encode_uint16 buf htotal;
    encode_uint16 buf hskew;
    encode_uint16 buf vdisplay;
    encode_uint16 buf vsyncstart;
    encode_uint16 buf vsyncend;
    encode_uint16 buf vtotal;
    encode_pad buf 2;
    encode_mask encode_int32 identity mode_flag_int_of_mask buf flags;
    encode_pad buf 12;
    encode_int32 buf (identity ((* Parsetree.Card8 *) List.length private_));
    encode_list encode_uint8 buf private_;
    (* write request length *)
    encode_request_length buf

  type get_view_port_reply = { x : int; y : int } [@@deriving sexp]

  let encode_get_view_port ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_view_port_reply length buf ~at :
      (get_view_port_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* x, at = decode_int32 buf ~at in
    let* y, at = decode_int32 buf ~at in
    let at = at + 16 in
    ignore orig;
    Some ({ x; y }, at)

  let encode_set_view_port ~(screen : int) ~(x : int) ~(y : int) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    encode_int32 buf x;
    encode_int32 buf y;
    (* write request length *)
    encode_request_length buf

  type get_dot_clocks_reply = {
    flags : clock_flag_mask;
    clocks : int;
    maxclocks : int;
    clock : int list;
  }
  [@@deriving sexp]

  let encode_get_dot_clocks ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_dot_clocks_reply length buf ~at :
      (get_dot_clocks_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int clock_flag_mask_of_int64 buf ~at
    in
    let* clocks, at = decode_int32 buf ~at in
    let* maxclocks, at = decode_int32 buf ~at in
    let at = at + 12 in
    let* clock, at =
      let length = (1 - (flags land 1)) * clocks in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ flags; clocks; maxclocks; clock }, at)

  let encode_set_client_version ~(major : int) ~(minor : int) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_uint16 buf major;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf minor;
    (* write request length *)
    encode_request_length buf

  let encode_set_gamma ~(screen : int) ~(red : int) ~(green : int) ~(blue : int)
      buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    encode_int32 buf red;
    encode_int32 buf green;
    encode_int32 buf blue;
    encode_pad buf 12;
    (* write request length *)
    encode_request_length buf

  type get_gamma_reply = { red : int; green : int; blue : int }
  [@@deriving sexp]

  let encode_get_gamma ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 26;
    (* write request length *)
    encode_request_length buf

  let decode_get_gamma_reply length buf ~at : (get_gamma_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* red, at = decode_int32 buf ~at in
    let* green, at = decode_int32 buf ~at in
    let* blue, at = decode_int32 buf ~at in
    let at = at + 12 in
    ignore orig;
    Some ({ red; green; blue }, at)

  type get_gamma_ramp_reply = {
    size : int;
    red : int list;
    green : int list;
    blue : int list;
  }
  [@@deriving sexp]

  let encode_get_gamma_ramp ~(screen : int) ~(size : int) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf size;
    (* write request length *)
    encode_request_length buf

  let decode_get_gamma_ramp_reply length buf ~at :
      (get_gamma_ramp_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* size, at = decode_uint16 buf ~at in
    let at = at + 22 in
    let* red, at =
      let length = (size + 1) land lnot 1 in
      decode_list decode_uint16 length buf ~at
    in
    let* green, at =
      let length = (size + 1) land lnot 1 in
      decode_list decode_uint16 length buf ~at
    in
    let* blue, at =
      let length = (size + 1) land lnot 1 in
      decode_list decode_uint16 length buf ~at
    in
    ignore orig;
    Some ({ size; red; green; blue }, at)

  let encode_set_gamma_ramp ~(screen : int) ~(size : int) ~(red : int list)
      ~(green : int list) ~(blue : int list) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf size;
    encode_list encode_uint16 buf red;
    encode_list encode_uint16 buf green;
    encode_list encode_uint16 buf blue;
    (* write request length *)
    encode_request_length buf

  type get_gamma_ramp_size_reply = int [@@deriving sexp]

  let encode_get_gamma_ramp_size ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_gamma_ramp_size_reply length buf ~at :
      (get_gamma_ramp_size_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* size, at = decode_uint16 buf ~at in
    let at = at + 22 in
    ignore orig;
    Some (size, at)

  type get_permissions_reply = permission_mask [@@deriving sexp]

  let encode_get_permissions ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 20;
    encode_uint16 buf screen;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_permissions_reply length buf ~at :
      (get_permissions_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* permissions, at =
      decode_mask decode_int32 Int64.of_int permission_mask_of_int64 buf ~at
    in
    let at = at + 20 in
    ignore orig;
    Some (permissions, at)

  type bad_clock_error = unit [@@deriving sexp]
  type bad_h_timings_error = unit [@@deriving sexp]
  type bad_v_timings_error = unit [@@deriving sexp]
  type mode_unsuitable_error = unit [@@deriving sexp]
  type extension_disabled_error = unit [@@deriving sexp]
  type client_not_local_error = unit [@@deriving sexp]
  type zoom_locked_error = unit [@@deriving sexp]
end

module Xinerama = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type screen_info = { x_org : int; y_org : int; width : int; height : int }
  [@@deriving sexp]

  let decode_screen_info buf ~at : (screen_info * int) option =
    let orig = at in
    let* x_org, at = decode_int16 buf ~at in
    let* y_org, at = decode_int16 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ x_org; y_org; width; height }, at)

  let encode_screen_info buf (v : screen_info) =
    encode_int16 buf v.x_org;
    encode_int16 buf v.y_org;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    ()

  type query_version_reply = { major : int; minor : int } [@@deriving sexp]

  let encode_query_version ~(major : int) ~(minor : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint8 buf major;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf minor;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major, at = decode_uint16 buf ~at in
    let* minor, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major; minor }, at)

  type get_state_reply = { state : char; window : Xproto.window }
  [@@deriving sexp]

  let encode_get_state ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_state_reply length buf ~at : (get_state_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* state, at = decode_char buf ~at in
    let at = at + 6 in
    let* window, at = Xproto.decode_window buf ~at in
    ignore orig;
    Some ({ state; window }, at)

  type get_screen_count_reply = { screen_count : char; window : Xproto.window }
  [@@deriving sexp]

  let encode_get_screen_count ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 2;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_screen_count_reply length buf ~at :
      (get_screen_count_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* screen_count, at = decode_char buf ~at in
    let at = at + 6 in
    let* window, at = Xproto.decode_window buf ~at in
    ignore orig;
    Some ({ screen_count; window }, at)

  type get_screen_size_reply = {
    width : int;
    height : int;
    window : Xproto.window;
    screen : int;
  }
  [@@deriving sexp]

  let encode_get_screen_size ~(window : Xproto.window) ~(screen : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf screen;
    (* write request length *)
    encode_request_length buf

  let decode_get_screen_size_reply length buf ~at :
      (get_screen_size_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* screen, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ width; height; window; screen }, at)

  type is_active_reply = int [@@deriving sexp]

  let encode_is_active buf =
    (* opcode *)
    encode_uint8 buf 4;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_is_active_reply length buf ~at : (is_active_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* state, at = decode_int32 buf ~at in
    ignore orig;
    Some (state, at)

  type query_screens_reply = screen_info list [@@deriving sexp]

  let encode_query_screens buf =
    (* opcode *)
    encode_uint8 buf 5;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_screens_reply length buf ~at :
      (query_screens_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* number, at = decode_int32 buf ~at in
    let number = number in
    let at = at + 20 in
    let* screen_info, at = decode_list decode_screen_info number buf ~at in
    ignore orig;
    Some (screen_info, at)
end

module Xinput = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type event_class = int [@@deriving sexp]

  let decode_event_class = decode_int32
  let encode_event_class = encode_int32

  type key_code = int [@@deriving sexp]

  let decode_key_code = decode_uint8
  let encode_key_code = encode_uint8

  type device_id = int [@@deriving sexp]

  let decode_device_id = decode_uint16
  let encode_device_id = encode_uint16

  type fp1616 = int [@@deriving sexp]

  let decode_fp1616 = decode_int32
  let encode_fp1616 = encode_int32

  type fp3232 = { integral : int; frac : int } [@@deriving sexp]

  let decode_fp3232 buf ~at : (fp3232 * int) option =
    let orig = at in
    let* integral, at = decode_int32 buf ~at in
    let* frac, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ integral; frac }, at)

  let encode_fp3232 buf (v : fp3232) =
    encode_int32 buf v.integral;
    encode_int32 buf v.frac;
    ()

  type get_extension_version_reply = {
    xi_reply_type : int;
    server_major : int;
    server_minor : int;
    present : bool;
  }
  [@@deriving sexp]

  let encode_get_extension_version ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_uint16 buf (identity (String.length name));
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_get_extension_version_reply length buf ~at :
      (get_extension_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* server_major, at = decode_uint16 buf ~at in
    let* server_minor, at = decode_uint16 buf ~at in
    let* present, at = decode_bool buf ~at in
    let at = at + 19 in
    ignore orig;
    Some ({ xi_reply_type; server_major; server_minor; present }, at)

  type device_use_enum =
    [ `Is_x_pointer
    | `Is_x_keyboard
    | `Is_x_extension_device
    | `Is_x_extension_keyboard
    | `Is_x_extension_pointer ]
  [@@deriving sexp]

  let device_use_enum_of_int : int -> [> device_use_enum ] option = function
    | 0 -> Some `Is_x_pointer
    | 1 -> Some `Is_x_keyboard
    | 2 -> Some `Is_x_extension_device
    | 3 -> Some `Is_x_extension_keyboard
    | 4 -> Some `Is_x_extension_pointer
    | n ->
        Printf.printf "unknown device_use_enum: %d\n" n;
        None

  let device_use_int_of_enum : device_use_enum -> int = function
    | `Is_x_pointer -> 0
    | `Is_x_keyboard -> 1
    | `Is_x_extension_device -> 2
    | `Is_x_extension_keyboard -> 3
    | `Is_x_extension_pointer -> 4

  type input_class_enum =
    [ `Key | `Button | `Valuator | `Feedback | `Proximity | `Focus | `Other ]
  [@@deriving sexp]

  let input_class_enum_of_int : int -> [> input_class_enum ] option = function
    | 0 -> Some `Key
    | 1 -> Some `Button
    | 2 -> Some `Valuator
    | 3 -> Some `Feedback
    | 4 -> Some `Proximity
    | 5 -> Some `Focus
    | 6 -> Some `Other
    | n ->
        Printf.printf "unknown input_class_enum: %d\n" n;
        None

  let input_class_int_of_enum : input_class_enum -> int = function
    | `Key -> 0
    | `Button -> 1
    | `Valuator -> 2
    | `Feedback -> 3
    | `Proximity -> 4
    | `Focus -> 5
    | `Other -> 6

  type valuator_mode_enum = [ `Relative | `Absolute ] [@@deriving sexp]

  let valuator_mode_enum_of_int : int -> [> valuator_mode_enum ] option =
    function
    | 0 -> Some `Relative
    | 1 -> Some `Absolute
    | n ->
        Printf.printf "unknown valuator_mode_enum: %d\n" n;
        None

  let valuator_mode_int_of_enum : valuator_mode_enum -> int = function
    | `Relative -> 0
    | `Absolute -> 1

  type device_info = {
    device_type : Xproto.atom;
    device_id : int;
    num_class_info : int;
    device_use : device_use_enum;
  }
  [@@deriving sexp]

  let decode_device_info buf ~at : (device_info * int) option =
    let orig = at in
    let* device_type, at = Xproto.decode_atom buf ~at in
    let* device_id, at = decode_uint8 buf ~at in
    let* num_class_info, at = decode_uint8 buf ~at in
    let* device_use, at =
      decode_enum decode_uint8 identity device_use_enum_of_int buf ~at
    in
    let at = at + 1 in
    ignore orig;
    Some ({ device_type; device_id; num_class_info; device_use }, at)

  let encode_device_info buf (v : device_info) =
    Xproto.encode_atom buf v.device_type;
    encode_uint8 buf v.device_id;
    encode_uint8 buf v.num_class_info;
    encode_enum encode_uint8 identity device_use_int_of_enum buf v.device_use;
    encode_pad buf 1;
    ()

  type key_info = {
    class_id : input_class_enum;
    len : int;
    min_keycode : key_code;
    max_keycode : key_code;
    num_keys : int;
  }
  [@@deriving sexp]

  let decode_key_info buf ~at : (key_info * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* len, at = decode_uint8 buf ~at in
    let* min_keycode, at = decode_key_code buf ~at in
    let* max_keycode, at = decode_key_code buf ~at in
    let* num_keys, at = decode_uint16 buf ~at in
    let at = at + 2 in
    ignore orig;
    Some ({ class_id; len; min_keycode; max_keycode; num_keys }, at)

  let encode_key_info buf (v : key_info) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.len;
    encode_key_code buf v.min_keycode;
    encode_key_code buf v.max_keycode;
    encode_uint16 buf v.num_keys;
    encode_pad buf 2;
    ()

  type button_info = {
    class_id : input_class_enum;
    len : int;
    num_buttons : int;
  }
  [@@deriving sexp]

  let decode_button_info buf ~at : (button_info * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* len, at = decode_uint8 buf ~at in
    let* num_buttons, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ class_id; len; num_buttons }, at)

  let encode_button_info buf (v : button_info) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.len;
    encode_uint16 buf v.num_buttons;
    ()

  type axis_info = { resolution : int; minimum : int; maximum : int }
  [@@deriving sexp]

  let decode_axis_info buf ~at : (axis_info * int) option =
    let orig = at in
    let* resolution, at = decode_int32 buf ~at in
    let* minimum, at = decode_int32 buf ~at in
    let* maximum, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ resolution; minimum; maximum }, at)

  let encode_axis_info buf (v : axis_info) =
    encode_int32 buf v.resolution;
    encode_int32 buf v.minimum;
    encode_int32 buf v.maximum;
    ()

  type valuator_info = {
    class_id : input_class_enum;
    len : int;
    mode : valuator_mode_enum;
    motion_size : int;
    axes : axis_info list;
  }
  [@@deriving sexp]

  let decode_valuator_info buf ~at : (valuator_info * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* len, at = decode_uint8 buf ~at in
    let* axes_len, at = decode_uint8 buf ~at in
    let axes_len = axes_len in
    let* mode, at =
      decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at
    in
    let* motion_size, at = decode_int32 buf ~at in
    let* axes, at = decode_list decode_axis_info axes_len buf ~at in
    ignore orig;
    Some ({ class_id; len; mode; motion_size; axes }, at)

  let encode_valuator_info buf (v : valuator_info) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.len;
    encode_uint8 buf (identity ((* invalid_argument *) List.length v.axes));
    encode_enum encode_uint8 identity valuator_mode_int_of_enum buf v.mode;
    encode_int32 buf v.motion_size;
    encode_list encode_axis_info buf v.axes;
    ()

  type input_class_variant =
    | Key of { min_keycode : key_code; max_keycode : key_code; num_keys : int }
    | Button of { num_buttons : int }
    | Valuator of {
        mode : valuator_mode_enum;
        motion_size : int;
        axes : axis_info list;
      }
  [@@deriving sexp]

  let decode_input_class_variant tag buf ~at :
      (input_class_variant * int) option =
    match tag with
    | 0 ->
        let* min_keycode, at = decode_key_code buf ~at in
        let* max_keycode, at = decode_key_code buf ~at in
        let* num_keys, at = decode_uint16 buf ~at in
        let at = at + 2 in
        Some (Key { min_keycode; max_keycode; num_keys }, at)
    | 1 ->
        let* num_buttons, at = decode_uint16 buf ~at in
        Some (Button { num_buttons }, at)
    | 2 ->
        let* axes_len, at = decode_uint8 buf ~at in
        let axes_len = axes_len in
        let* mode, at =
          decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at
        in
        let* motion_size, at = decode_int32 buf ~at in
        let* axes, at = decode_list decode_axis_info axes_len buf ~at in
        Some (Valuator { mode; motion_size; axes }, at)
    | _ -> None

  type input_info = { len : int; info : input_class_variant } [@@deriving sexp]

  let decode_input_info buf ~at : (input_info * int) option =
    let orig = at in
    let* info_tag, at = decode_uint8 buf ~at in
    let* len, at = decode_uint8 buf ~at in
    let* info, at = decode_input_class_variant info_tag buf ~at in
    ignore orig;
    Some ({ len; info }, at)

  let encode_input_info buf (v : input_info) =
    (* field_variant_tag *)
    encode_uint8 buf v.len;
    (* field_variant *) ()

  type device_name = string [@@deriving sexp]

  let decode_device_name buf ~at : (device_name * int) option =
    let orig = at in
    let* len, at = decode_uint8 buf ~at in
    let len = len in
    let* string, at = decode_string len buf ~at in
    ignore orig;
    Some (string, at)

  let encode_device_name buf (v : device_name) =
    encode_string buf v;
    ()

  type list_input_devices_reply = {
    xi_reply_type : int;
    devices : device_info list;
    infos : input_info list;
    names : Xproto.str list;
  }
  [@@deriving sexp]

  let encode_list_input_devices buf =
    (* opcode *)
    encode_uint8 buf 2;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_list_input_devices_reply length buf ~at :
      (list_input_devices_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* devices_len, at = decode_uint8 buf ~at in
    let devices_len = devices_len in
    let at = at + 23 in
    let* devices, at = decode_list decode_device_info devices_len buf ~at in
    let* infos, at =
      let length =
        sum_of_expr
          (fun list_element_ref -> list_element_ref.num_class_info)
          devices
      in
      decode_list decode_input_info length buf ~at
    in
    let* names, at = decode_list Xproto.decode_str devices_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ xi_reply_type; devices; infos; names }, at)

  type event_type_base = int [@@deriving sexp]

  let decode_event_type_base = decode_uint8
  let encode_event_type_base = encode_uint8

  type input_class_info = {
    class_id : input_class_enum;
    event_type_base : event_type_base;
  }
  [@@deriving sexp]

  let decode_input_class_info buf ~at : (input_class_info * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* event_type_base, at = decode_event_type_base buf ~at in
    ignore orig;
    Some ({ class_id; event_type_base }, at)

  let encode_input_class_info buf (v : input_class_info) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_event_type_base buf v.event_type_base;
    ()

  type open_device_reply = {
    xi_reply_type : int;
    class_info : input_class_info list;
  }
  [@@deriving sexp]

  let encode_open_device ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_open_device_reply length buf ~at : (open_device_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_classes, at = decode_uint8 buf ~at in
    let num_classes = num_classes in
    let at = at + 23 in
    let* class_info, at =
      decode_list decode_input_class_info num_classes buf ~at
    in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ xi_reply_type; class_info }, at)

  let encode_close_device ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type set_device_mode_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum;
  }
  [@@deriving sexp]

  let encode_set_device_mode ~(device_id : int) ~(mode : valuator_mode_enum) buf
      =
    (* opcode *)
    encode_uint8 buf 5;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity valuator_mode_int_of_enum buf mode;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_set_device_mode_reply length buf ~at :
      (set_device_mode_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  let encode_select_extension_event ~(window : Xproto.window)
      ~(classes : event_class list) buf =
    (* opcode *)
    encode_uint8 buf 6;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes));
    encode_pad buf 2;
    encode_list encode_event_class buf classes;
    (* write request length *)
    encode_request_length buf

  type get_selected_extension_events_reply = {
    xi_reply_type : int;
    this_classes : event_class list;
    all_classes : event_class list;
  }
  [@@deriving sexp]

  let encode_get_selected_extension_events ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_selected_extension_events_reply length buf ~at :
      (get_selected_extension_events_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_this_classes, at = decode_uint16 buf ~at in
    let num_this_classes = num_this_classes in
    let* num_all_classes, at = decode_uint16 buf ~at in
    let num_all_classes = num_all_classes in
    let at = at + 20 in
    let* this_classes, at =
      decode_list decode_event_class num_this_classes buf ~at
    in
    let* all_classes, at =
      decode_list decode_event_class num_all_classes buf ~at
    in
    ignore orig;
    Some ({ xi_reply_type; this_classes; all_classes }, at)

  type propagate_mode_enum = [ `Add_to_list | `Delete_from_list ]
  [@@deriving sexp]

  let propagate_mode_enum_of_int : int -> [> propagate_mode_enum ] option =
    function
    | 0 -> Some `Add_to_list
    | 1 -> Some `Delete_from_list
    | n ->
        Printf.printf "unknown propagate_mode_enum: %d\n" n;
        None

  let propagate_mode_int_of_enum : propagate_mode_enum -> int = function
    | `Add_to_list -> 0
    | `Delete_from_list -> 1

  let encode_change_device_dont_propagate_list ~(window : Xproto.window)
      ~(mode : propagate_mode_enum) ~(classes : event_class list) buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes));
    encode_enum encode_uint8 identity propagate_mode_int_of_enum buf mode;
    encode_pad buf 1;
    encode_list encode_event_class buf classes;
    (* write request length *)
    encode_request_length buf

  type get_device_dont_propagate_list_reply = {
    xi_reply_type : int;
    classes : event_class list;
  }
  [@@deriving sexp]

  let encode_get_device_dont_propagate_list ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 9;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_device_dont_propagate_list_reply length buf ~at :
      (get_device_dont_propagate_list_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_classes, at = decode_uint16 buf ~at in
    let num_classes = num_classes in
    let at = at + 22 in
    let* classes, at = decode_list decode_event_class num_classes buf ~at in
    ignore orig;
    Some ({ xi_reply_type; classes }, at)

  type device_time_coord = { time : Xproto.timestamp; axisvalues : int list }
  [@@deriving sexp]

  let decode_device_time_coord buf ~at : (device_time_coord * int) option =
    let orig = at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* axisvalues, at =
      let length = num_axes in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ time; axisvalues }, at)

  let encode_device_time_coord buf (v : device_time_coord) =
    Xproto.encode_timestamp buf v.time;
    encode_list encode_int32 buf v.axisvalues;
    ()

  type get_device_motion_events_reply = {
    xi_reply_type : int;
    num_axes : int;
    device_mode : valuator_mode_enum;
    events : device_time_coord list;
  }
  [@@deriving sexp]

  let encode_get_device_motion_events ~(start : Xproto.timestamp)
      ~(stop : Xproto.time_enum alt_enum) ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 10;
    Xproto.encode_timestamp buf start;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      stop;
    encode_uint8 buf device_id;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_motion_events_reply length buf ~at :
      (get_device_motion_events_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_events, at = decode_int32 buf ~at in
    let num_events = num_events in
    let* num_axes, at = decode_uint8 buf ~at in
    let* device_mode, at =
      decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at
    in
    let at = at + 18 in
    let* events, at = decode_list decode_device_time_coord num_events buf ~at in
    ignore orig;
    Some ({ xi_reply_type; num_axes; device_mode; events }, at)

  type change_keyboard_device_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum;
  }
  [@@deriving sexp]

  let encode_change_keyboard_device ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_change_keyboard_device_reply length buf ~at :
      (change_keyboard_device_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  type change_pointer_device_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum;
  }
  [@@deriving sexp]

  let encode_change_pointer_device ~(x_axis : int) ~(y_axis : int)
      ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_uint8 buf x_axis;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf y_axis;
    encode_uint8 buf device_id;
    encode_pad buf 1;
    (* write request length *)
    encode_request_length buf

  let decode_change_pointer_device_reply length buf ~at :
      (change_pointer_device_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  type grab_device_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum;
  }
  [@@deriving sexp]

  let encode_grab_device ~(grab_window : Xproto.window)
      ~(time : Xproto.time_enum alt_enum)
      ~(this_device_mode : Xproto.grab_mode_enum)
      ~(other_device_mode : Xproto.grab_mode_enum) ~(owner_events : bool)
      ~(device_id : int) ~(classes : event_class list) buf =
    (* opcode *)
    encode_uint8 buf 13;
    Xproto.encode_window buf grab_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes));
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      this_device_mode;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      other_device_mode;
    encode_bool buf owner_events;
    encode_uint8 buf device_id;
    encode_pad buf 2;
    encode_list encode_event_class buf classes;
    (* write request length *)
    encode_request_length buf

  let decode_grab_device_reply length buf ~at : (grab_device_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  let encode_ungrab_device ~(time : Xproto.time_enum alt_enum)
      ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf device_id;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type modifier_device_enum = [ `Use_x_keyboard ] [@@deriving sexp]

  let modifier_device_enum_of_int : int -> [> modifier_device_enum ] option =
    function
    | 255 -> Some `Use_x_keyboard
    | n ->
        Printf.printf "unknown modifier_device_enum: %d\n" n;
        None

  let modifier_device_int_of_enum : modifier_device_enum -> int = function
    | `Use_x_keyboard -> 255

  let encode_grab_device_key ~(grab_window : Xproto.window)
      ~(modifiers : Xproto.mod_mask)
      ~(modifier_device : modifier_device_enum alt_enum) ~(grabbed_device : int)
      ~(key : Xproto.grab_enum alt_enum)
      ~(this_device_mode : Xproto.grab_mode_enum)
      ~(other_device_mode : Xproto.grab_mode_enum) ~(owner_events : bool)
      ~(classes : event_class list) buf =
    (* opcode *)
    encode_uint8 buf 15;
    Xproto.encode_window buf grab_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes));
    encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers;
    encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf
      modifier_device;
    encode_uint8 buf grabbed_device;
    encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf key;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      this_device_mode;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      other_device_mode;
    encode_bool buf owner_events;
    encode_pad buf 2;
    encode_list encode_event_class buf classes;
    (* write request length *)
    encode_request_length buf

  let encode_ungrab_device_key ~(grab_window : Xproto.window)
      ~(modifiers : Xproto.mod_mask)
      ~(modifier_device : modifier_device_enum alt_enum)
      ~(key : Xproto.grab_enum alt_enum) ~(grabbed_device : int) buf =
    (* opcode *)
    encode_uint8 buf 16;
    Xproto.encode_window buf grab_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers;
    encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf
      modifier_device;
    encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf key;
    encode_uint8 buf grabbed_device;
    (* write request length *)
    encode_request_length buf

  let encode_grab_device_button ~(grab_window : Xproto.window)
      ~(grabbed_device : int) ~(modifier_device : modifier_device_enum alt_enum)
      ~(modifiers : Xproto.mod_mask) ~(this_device_mode : Xproto.grab_mode_enum)
      ~(other_device_mode : Xproto.grab_mode_enum)
      ~(button : Xproto.grab_enum alt_enum) ~(owner_events : bool)
      ~(classes : event_class list) buf =
    (* opcode *)
    encode_uint8 buf 17;
    Xproto.encode_window buf grab_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf grabbed_device;
    encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf
      modifier_device;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes));
    encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      this_device_mode;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      other_device_mode;
    encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf button;
    encode_bool buf owner_events;
    encode_pad buf 2;
    encode_list encode_event_class buf classes;
    (* write request length *)
    encode_request_length buf

  let encode_ungrab_device_button ~(grab_window : Xproto.window)
      ~(modifiers : Xproto.mod_mask)
      ~(modifier_device : modifier_device_enum alt_enum)
      ~(button : Xproto.grab_enum alt_enum) ~(grabbed_device : int) buf =
    (* opcode *)
    encode_uint8 buf 18;
    Xproto.encode_window buf grab_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_mask encode_uint16 identity Xproto.mod_mask_int_of_mask buf modifiers;
    encode_alt_enum encode_uint8 identity modifier_device_int_of_enum buf
      modifier_device;
    encode_alt_enum encode_uint8 identity Xproto.grab_int_of_enum buf button;
    encode_uint8 buf grabbed_device;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type device_input_mode_enum =
    [ `Async_this_device
    | `Sync_this_device
    | `Replay_this_device
    | `Async_other_devices
    | `Async_all
    | `Sync_all ]
  [@@deriving sexp]

  let device_input_mode_enum_of_int : int -> [> device_input_mode_enum ] option
      = function
    | 0 -> Some `Async_this_device
    | 1 -> Some `Sync_this_device
    | 2 -> Some `Replay_this_device
    | 3 -> Some `Async_other_devices
    | 4 -> Some `Async_all
    | 5 -> Some `Sync_all
    | n ->
        Printf.printf "unknown device_input_mode_enum: %d\n" n;
        None

  let device_input_mode_int_of_enum : device_input_mode_enum -> int = function
    | `Async_this_device -> 0
    | `Sync_this_device -> 1
    | `Replay_this_device -> 2
    | `Async_other_devices -> 3
    | `Async_all -> 4
    | `Sync_all -> 5

  let encode_allow_device_events ~(time : Xproto.time_enum alt_enum)
      ~(mode : device_input_mode_enum) ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity device_input_mode_int_of_enum buf mode;
    encode_uint8 buf device_id;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type get_device_focus_reply = {
    xi_reply_type : int;
    focus : Xproto.input_focus_enum alt_enum;
    time : Xproto.timestamp;
    revert_to : Xproto.input_focus_enum;
  }
  [@@deriving sexp]

  let encode_get_device_focus ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 20;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_focus_reply length buf ~at :
      (get_device_focus_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* focus, at =
      decode_alt_enum Xproto.decode_window identity
        Xproto.input_focus_enum_of_int buf ~at
    in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* revert_to, at =
      decode_enum decode_uint8 identity Xproto.input_focus_enum_of_int buf ~at
    in
    let at = at + 15 in
    ignore orig;
    Some ({ xi_reply_type; focus; time; revert_to }, at)

  let encode_set_device_focus ~(focus : Xproto.input_focus_enum alt_enum)
      ~(time : Xproto.time_enum alt_enum) ~(revert_to : Xproto.input_focus_enum)
      ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 21;
    encode_alt_enum Xproto.encode_window identity Xproto.input_focus_int_of_enum
      buf focus;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    encode_enum encode_uint8 identity Xproto.input_focus_int_of_enum buf
      revert_to;
    encode_uint8 buf device_id;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type feedback_class_enum =
    [ `Keyboard | `Pointer | `String | `Integer | `Led | `Bell ]
  [@@deriving sexp]

  let feedback_class_enum_of_int : int -> [> feedback_class_enum ] option =
    function
    | 0 -> Some `Keyboard
    | 1 -> Some `Pointer
    | 2 -> Some `String
    | 3 -> Some `Integer
    | 4 -> Some `Led
    | 5 -> Some `Bell
    | n ->
        Printf.printf "unknown feedback_class_enum: %d\n" n;
        None

  let feedback_class_int_of_enum : feedback_class_enum -> int = function
    | `Keyboard -> 0
    | `Pointer -> 1
    | `String -> 2
    | `Integer -> 3
    | `Led -> 4
    | `Bell -> 5

  type kbd_feedback_state = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    pitch : int;
    duration : int;
    led_mask : int;
    led_values : int;
    global_auto_repeat : bool;
    click : int;
    percent : int;
    auto_repeats : int list;
  }
  [@@deriving sexp]

  let decode_kbd_feedback_state buf ~at : (kbd_feedback_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* pitch, at = decode_uint16 buf ~at in
    let* duration, at = decode_uint16 buf ~at in
    let* led_mask, at = decode_int32 buf ~at in
    let* led_values, at = decode_int32 buf ~at in
    let* global_auto_repeat, at = decode_bool buf ~at in
    let* click, at = decode_uint8 buf ~at in
    let* percent, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* auto_repeats, at =
      let length = 32 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some
      ( {
          class_id;
          feedback_id;
          len;
          pitch;
          duration;
          led_mask;
          led_values;
          global_auto_repeat;
          click;
          percent;
          auto_repeats;
        },
        at )

  let encode_kbd_feedback_state buf (v : kbd_feedback_state) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_uint16 buf v.pitch;
    encode_uint16 buf v.duration;
    encode_int32 buf v.led_mask;
    encode_int32 buf v.led_values;
    encode_bool buf v.global_auto_repeat;
    encode_uint8 buf v.click;
    encode_uint8 buf v.percent;
    encode_pad buf 1;
    encode_list encode_uint8 buf v.auto_repeats;
    ()

  type ptr_feedback_state = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    accel_num : int;
    accel_denom : int;
    threshold : int;
  }
  [@@deriving sexp]

  let decode_ptr_feedback_state buf ~at : (ptr_feedback_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* accel_num, at = decode_uint16 buf ~at in
    let* accel_denom, at = decode_uint16 buf ~at in
    let* threshold, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; accel_num; accel_denom; threshold }, at)

  let encode_ptr_feedback_state buf (v : ptr_feedback_state) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_pad buf 2;
    encode_uint16 buf v.accel_num;
    encode_uint16 buf v.accel_denom;
    encode_uint16 buf v.threshold;
    ()

  type integer_feedback_state = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    resolution : int;
    min_value : int;
    max_value : int;
  }
  [@@deriving sexp]

  let decode_integer_feedback_state buf ~at :
      (integer_feedback_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* resolution, at = decode_int32 buf ~at in
    let* min_value, at = decode_int32 buf ~at in
    let* max_value, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; resolution; min_value; max_value }, at)

  let encode_integer_feedback_state buf (v : integer_feedback_state) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.resolution;
    encode_int32 buf v.min_value;
    encode_int32 buf v.max_value;
    ()

  type string_feedback_state = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    max_symbols : int;
    keysyms : Xproto.keysym list;
  }
  [@@deriving sexp]

  let decode_string_feedback_state buf ~at :
      (string_feedback_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* max_symbols, at = decode_uint16 buf ~at in
    let* num_keysyms, at = decode_uint16 buf ~at in
    let num_keysyms = num_keysyms in
    let* keysyms, at = decode_list Xproto.decode_keysym num_keysyms buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; max_symbols; keysyms }, at)

  let encode_string_feedback_state buf (v : string_feedback_state) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_uint16 buf v.max_symbols;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.keysyms));
    encode_list Xproto.encode_keysym buf v.keysyms;
    ()

  type bell_feedback_state = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    percent : int;
    pitch : int;
    duration : int;
  }
  [@@deriving sexp]

  let decode_bell_feedback_state buf ~at : (bell_feedback_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* percent, at = decode_uint8 buf ~at in
    let at = at + 3 in
    let* pitch, at = decode_uint16 buf ~at in
    let* duration, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; percent; pitch; duration }, at)

  let encode_bell_feedback_state buf (v : bell_feedback_state) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_uint8 buf v.percent;
    encode_pad buf 3;
    encode_uint16 buf v.pitch;
    encode_uint16 buf v.duration;
    ()

  type led_feedback_state = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    led_mask : int;
    led_values : int;
  }
  [@@deriving sexp]

  let decode_led_feedback_state buf ~at : (led_feedback_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* led_mask, at = decode_int32 buf ~at in
    let* led_values, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; led_mask; led_values }, at)

  let encode_led_feedback_state buf (v : led_feedback_state) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.led_mask;
    encode_int32 buf v.led_values;
    ()

  type feedback_class_variant =
    | Keyboard of {
        pitch : int;
        duration : int;
        led_mask : int;
        led_values : int;
        global_auto_repeat : bool;
        click : int;
        percent : int;
        auto_repeats : int list;
      }
    | Pointer of { accel_num : int; accel_denom : int; threshold : int }
    | String of { max_symbols : int; keysyms : Xproto.keysym list }
    | Integer of { resolution : int; min_value : int; max_value : int }
    | Led of { led_mask : int; led_values : int }
    | Bell of { percent : int; pitch : int; duration : int }
  [@@deriving sexp]

  let decode_feedback_class_variant tag buf ~at :
      (feedback_class_variant * int) option =
    match tag with
    | 0 ->
        let* pitch, at = decode_uint16 buf ~at in
        let* duration, at = decode_uint16 buf ~at in
        let* led_mask, at = decode_int32 buf ~at in
        let* led_values, at = decode_int32 buf ~at in
        let* global_auto_repeat, at = decode_bool buf ~at in
        let* click, at = decode_uint8 buf ~at in
        let* percent, at = decode_uint8 buf ~at in
        let at = at + 1 in
        let* auto_repeats, at =
          let length = 32 in
          decode_list decode_uint8 length buf ~at
        in
        Some
          ( Keyboard
              {
                pitch;
                duration;
                led_mask;
                led_values;
                global_auto_repeat;
                click;
                percent;
                auto_repeats;
              },
            at )
    | 1 ->
        let at = at + 2 in
        let* accel_num, at = decode_uint16 buf ~at in
        let* accel_denom, at = decode_uint16 buf ~at in
        let* threshold, at = decode_uint16 buf ~at in
        Some (Pointer { accel_num; accel_denom; threshold }, at)
    | 2 ->
        let* max_symbols, at = decode_uint16 buf ~at in
        let* num_keysyms, at = decode_uint16 buf ~at in
        let num_keysyms = num_keysyms in
        let* keysyms, at =
          decode_list Xproto.decode_keysym num_keysyms buf ~at
        in
        Some (String { max_symbols; keysyms }, at)
    | 3 ->
        let* resolution, at = decode_int32 buf ~at in
        let* min_value, at = decode_int32 buf ~at in
        let* max_value, at = decode_int32 buf ~at in
        Some (Integer { resolution; min_value; max_value }, at)
    | 4 ->
        let* led_mask, at = decode_int32 buf ~at in
        let* led_values, at = decode_int32 buf ~at in
        Some (Led { led_mask; led_values }, at)
    | 5 ->
        let* percent, at = decode_uint8 buf ~at in
        let at = at + 3 in
        let* pitch, at = decode_uint16 buf ~at in
        let* duration, at = decode_uint16 buf ~at in
        Some (Bell { percent; pitch; duration }, at)
    | _ -> None

  type feedback_state = {
    feedback_id : int;
    len : int;
    data : feedback_class_variant;
  }
  [@@deriving sexp]

  let decode_feedback_state buf ~at : (feedback_state * int) option =
    let orig = at in
    let* data_tag, at = decode_uint8 buf ~at in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* data, at = decode_feedback_class_variant data_tag buf ~at in
    ignore orig;
    Some ({ feedback_id; len; data }, at)

  let encode_feedback_state buf (v : feedback_state) =
    (* field_variant_tag *)
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    (* field_variant *) ()

  type get_feedback_control_reply = {
    xi_reply_type : int;
    feedbacks : feedback_state list;
  }
  [@@deriving sexp]

  let encode_get_feedback_control ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 22;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_feedback_control_reply length buf ~at :
      (get_feedback_control_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_feedbacks, at = decode_uint16 buf ~at in
    let num_feedbacks = num_feedbacks in
    let at = at + 22 in
    let* feedbacks, at =
      decode_list decode_feedback_state num_feedbacks buf ~at
    in
    ignore orig;
    Some ({ xi_reply_type; feedbacks }, at)

  type kbd_feedback_ctl = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    key : key_code;
    auto_repeat_mode : int;
    key_click_percent : int;
    bell_percent : int;
    bell_pitch : int;
    bell_duration : int;
    led_mask : int;
    led_values : int;
  }
  [@@deriving sexp]

  let decode_kbd_feedback_ctl buf ~at : (kbd_feedback_ctl * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* key, at = decode_key_code buf ~at in
    let* auto_repeat_mode, at = decode_uint8 buf ~at in
    let* key_click_percent, at = decode_int8 buf ~at in
    let* bell_percent, at = decode_int8 buf ~at in
    let* bell_pitch, at = decode_int16 buf ~at in
    let* bell_duration, at = decode_int16 buf ~at in
    let* led_mask, at = decode_int32 buf ~at in
    let* led_values, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( {
          class_id;
          feedback_id;
          len;
          key;
          auto_repeat_mode;
          key_click_percent;
          bell_percent;
          bell_pitch;
          bell_duration;
          led_mask;
          led_values;
        },
        at )

  let encode_kbd_feedback_ctl buf (v : kbd_feedback_ctl) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_key_code buf v.key;
    encode_uint8 buf v.auto_repeat_mode;
    encode_int8 buf v.key_click_percent;
    encode_int8 buf v.bell_percent;
    encode_int16 buf v.bell_pitch;
    encode_int16 buf v.bell_duration;
    encode_int32 buf v.led_mask;
    encode_int32 buf v.led_values;
    ()

  type ptr_feedback_ctl = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    num : int;
    denom : int;
    threshold : int;
  }
  [@@deriving sexp]

  let decode_ptr_feedback_ctl buf ~at : (ptr_feedback_ctl * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* num, at = decode_int16 buf ~at in
    let* denom, at = decode_int16 buf ~at in
    let* threshold, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; num; denom; threshold }, at)

  let encode_ptr_feedback_ctl buf (v : ptr_feedback_ctl) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_pad buf 2;
    encode_int16 buf v.num;
    encode_int16 buf v.denom;
    encode_int16 buf v.threshold;
    ()

  type integer_feedback_ctl = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    int_to_display : int;
  }
  [@@deriving sexp]

  let decode_integer_feedback_ctl buf ~at : (integer_feedback_ctl * int) option
      =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* int_to_display, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; int_to_display }, at)

  let encode_integer_feedback_ctl buf (v : integer_feedback_ctl) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.int_to_display;
    ()

  type string_feedback_ctl = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    keysyms : Xproto.keysym list;
  }
  [@@deriving sexp]

  let decode_string_feedback_ctl buf ~at : (string_feedback_ctl * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* num_keysyms, at = decode_uint16 buf ~at in
    let num_keysyms = num_keysyms in
    let* keysyms, at = decode_list Xproto.decode_keysym num_keysyms buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; keysyms }, at)

  let encode_string_feedback_ctl buf (v : string_feedback_ctl) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_pad buf 2;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.keysyms));
    encode_list Xproto.encode_keysym buf v.keysyms;
    ()

  type bell_feedback_ctl = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    percent : int;
    pitch : int;
    duration : int;
  }
  [@@deriving sexp]

  let decode_bell_feedback_ctl buf ~at : (bell_feedback_ctl * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* percent, at = decode_int8 buf ~at in
    let at = at + 3 in
    let* pitch, at = decode_int16 buf ~at in
    let* duration, at = decode_int16 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; percent; pitch; duration }, at)

  let encode_bell_feedback_ctl buf (v : bell_feedback_ctl) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_int8 buf v.percent;
    encode_pad buf 3;
    encode_int16 buf v.pitch;
    encode_int16 buf v.duration;
    ()

  type led_feedback_ctl = {
    class_id : feedback_class_enum;
    feedback_id : int;
    len : int;
    led_mask : int;
    led_values : int;
  }
  [@@deriving sexp]

  let decode_led_feedback_ctl buf ~at : (led_feedback_ctl * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity feedback_class_enum_of_int buf ~at
    in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* led_mask, at = decode_int32 buf ~at in
    let* led_values, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ class_id; feedback_id; len; led_mask; led_values }, at)

  let encode_led_feedback_ctl buf (v : led_feedback_ctl) =
    encode_enum encode_uint8 identity feedback_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.led_mask;
    encode_int32 buf v.led_values;
    ()

  type feedback_ctl = {
    feedback_id : int;
    len : int;
    data : feedback_class_variant;
  }
  [@@deriving sexp]

  let decode_feedback_ctl buf ~at : (feedback_ctl * int) option =
    let orig = at in
    let* data_tag, at = decode_uint8 buf ~at in
    let* feedback_id, at = decode_uint8 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* data, at = decode_feedback_class_variant data_tag buf ~at in
    ignore orig;
    Some ({ feedback_id; len; data }, at)

  let encode_feedback_ctl buf (v : feedback_ctl) =
    (* field_variant_tag *)
    encode_uint8 buf v.feedback_id;
    encode_uint16 buf v.len;
    (* field_variant *) ()

  type change_feedback_control_mask =
    [ `Key_click_percent
    | `Percent
    | `Pitch
    | `Duration
    | `Led
    | `Led_mode
    | `Key
    | `Auto_repeat_mode
    | `String
    | `Integer
    | `Accel_num
    | `Accel_denom
    | `Threshold ]
    list
  [@@deriving sexp]

  let change_feedback_control_mask_mask_of_int64 mask :
      change_feedback_control_mask option =
    let of_int = function
      | 0 -> Some `Key_click_percent
      | 1 -> Some `Percent
      | 2 -> Some `Pitch
      | 3 -> Some `Duration
      | 4 -> Some `Led
      | 5 -> Some `Led_mode
      | 6 -> Some `Key
      | 7 -> Some `Auto_repeat_mode
      | 0 -> Some `String
      | 0 -> Some `Integer
      | 0 -> Some `Accel_num
      | 1 -> Some `Accel_denom
      | 2 -> Some `Threshold
      | _ -> None
    in
    mask_of_int of_int mask

  let change_feedback_control_mask_int_of_mask :
      change_feedback_control_mask -> int =
    let to_bit = function
      | `Key_click_percent -> 0
      | `Percent -> 1
      | `Pitch -> 2
      | `Duration -> 3
      | `Led -> 4
      | `Led_mode -> 5
      | `Key -> 6
      | `Auto_repeat_mode -> 7
      | `String -> 0
      | `Integer -> 0
      | `Accel_num -> 0
      | `Accel_denom -> 1
      | `Threshold -> 2
    in
    int_of_mask to_bit

  let encode_change_feedback_control ~(mask : change_feedback_control_mask)
      ~(device_id : int) ~(feedback_id : int) ~(feedback : feedback_ctl) buf =
    (* opcode *)
    encode_uint8 buf 23;
    encode_mask encode_int32 identity change_feedback_control_mask_int_of_mask
      buf mask;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf device_id;
    encode_uint8 buf feedback_id;
    encode_pad buf 2;
    encode_feedback_ctl buf feedback;
    (* write request length *)
    encode_request_length buf

  type get_device_key_mapping_reply = {
    xi_reply_type : int;
    keysyms_per_keycode : int;
    keysyms : Xproto.keysym list;
  }
  [@@deriving sexp]

  let encode_get_device_key_mapping ~(device_id : int)
      ~(first_keycode : key_code) ~(count : int) buf =
    (* opcode *)
    encode_uint8 buf 24;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_key_code buf first_keycode;
    encode_uint8 buf count;
    encode_pad buf 1;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_key_mapping_reply length buf ~at :
      (get_device_key_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* keysyms_per_keycode, at = decode_uint8 buf ~at in
    let at = at + 23 in
    let* keysyms, at =
      let length = length in
      decode_list Xproto.decode_keysym length buf ~at
    in
    ignore orig;
    Some ({ xi_reply_type; keysyms_per_keycode; keysyms }, at)

  let encode_change_device_key_mapping ~(device_id : int)
      ~(first_keycode : key_code) ~(keysyms_per_keycode : int)
      ~(keycode_count : int) ~(keysyms : Xproto.keysym list) buf =
    (* opcode *)
    encode_uint8 buf 25;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_key_code buf first_keycode;
    encode_uint8 buf keysyms_per_keycode;
    encode_uint8 buf keycode_count;
    encode_list Xproto.encode_keysym buf keysyms;
    (* write request length *)
    encode_request_length buf

  type get_device_modifier_mapping_reply = {
    xi_reply_type : int;
    keymaps : int list;
  }
  [@@deriving sexp]

  let encode_get_device_modifier_mapping ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 26;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_modifier_mapping_reply length buf ~at :
      (get_device_modifier_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* keycodes_per_modifier, at = decode_uint8 buf ~at in
    let keycodes_per_modifier = keycodes_per_modifier / 8 in
    let at = at + 23 in
    let* keymaps, at = decode_list decode_uint8 keycodes_per_modifier buf ~at in
    ignore orig;
    Some ({ xi_reply_type; keymaps }, at)

  type set_device_modifier_mapping_reply = {
    xi_reply_type : int;
    status : Xproto.mapping_status_enum;
  }
  [@@deriving sexp]

  let encode_set_device_modifier_mapping ~(device_id : int)
      ~(keymaps : int list) buf =
    (* opcode *)
    encode_uint8 buf 27;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length keymaps));
    encode_pad buf 2;
    encode_list encode_uint8 buf keymaps;
    (* write request length *)
    encode_request_length buf

  let decode_set_device_modifier_mapping_reply length buf ~at :
      (set_device_modifier_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.mapping_status_enum_of_int buf
        ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  type get_device_button_mapping_reply = { xi_reply_type : int; map : int list }
  [@@deriving sexp]

  let encode_get_device_button_mapping ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 28;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_button_mapping_reply length buf ~at :
      (get_device_button_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* map_size, at = decode_uint8 buf ~at in
    let map_size = map_size in
    let at = at + 23 in
    let* map, at = decode_list decode_uint8 map_size buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ xi_reply_type; map }, at)

  type set_device_button_mapping_reply = {
    xi_reply_type : int;
    status : Xproto.mapping_status_enum;
  }
  [@@deriving sexp]

  let encode_set_device_button_mapping ~(device_id : int) ~(map : int list) buf
      =
    (* opcode *)
    encode_uint8 buf 29;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf (identity ((* Parsetree.Card8 *) List.length map));
    encode_pad buf 2;
    encode_list encode_uint8 buf map;
    (* write request length *)
    encode_request_length buf

  let decode_set_device_button_mapping_reply length buf ~at :
      (set_device_button_mapping_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.mapping_status_enum_of_int buf
        ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  type key_state = {
    class_id : input_class_enum;
    len : int;
    num_keys : int;
    keys : int list;
  }
  [@@deriving sexp]

  let decode_key_state buf ~at : (key_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* len, at = decode_uint8 buf ~at in
    let* num_keys, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* keys, at =
      let length = 32 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some ({ class_id; len; num_keys; keys }, at)

  let encode_key_state buf (v : key_state) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.len;
    encode_uint8 buf v.num_keys;
    encode_pad buf 1;
    encode_list encode_uint8 buf v.keys;
    ()

  type button_state = {
    class_id : input_class_enum;
    len : int;
    num_buttons : int;
    buttons : int list;
  }
  [@@deriving sexp]

  let decode_button_state buf ~at : (button_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* len, at = decode_uint8 buf ~at in
    let* num_buttons, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* buttons, at =
      let length = 32 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some ({ class_id; len; num_buttons; buttons }, at)

  let encode_button_state buf (v : button_state) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.len;
    encode_uint8 buf v.num_buttons;
    encode_pad buf 1;
    encode_list encode_uint8 buf v.buttons;
    ()

  type valuator_state_mode_mask =
    [ `Device_mode_absolute | `Out_of_proximity ] list
  [@@deriving sexp]

  let valuator_state_mode_mask_mask_of_int64 mask :
      valuator_state_mode_mask option =
    let of_int = function
      | 0 -> Some `Device_mode_absolute
      | 1 -> Some `Out_of_proximity
      | _ -> None
    in
    mask_of_int of_int mask

  let valuator_state_mode_mask_int_of_mask : valuator_state_mode_mask -> int =
    let to_bit = function
      | `Device_mode_absolute -> 0
      | `Out_of_proximity -> 1
    in
    int_of_mask to_bit

  type valuator_state = {
    class_id : input_class_enum;
    len : int;
    mode : valuator_state_mode_mask;
    valuators : int list;
  }
  [@@deriving sexp]

  let decode_valuator_state buf ~at : (valuator_state * int) option =
    let orig = at in
    let* class_id, at =
      decode_enum decode_uint8 identity input_class_enum_of_int buf ~at
    in
    let* len, at = decode_uint8 buf ~at in
    let* num_valuators, at = decode_uint8 buf ~at in
    let num_valuators = num_valuators in
    let* mode, at =
      decode_mask decode_uint8 Int64.of_int
        valuator_state_mode_mask_mask_of_int64 buf ~at
    in
    let* valuators, at = decode_list decode_int32 num_valuators buf ~at in
    ignore orig;
    Some ({ class_id; len; mode; valuators }, at)

  let encode_valuator_state buf (v : valuator_state) =
    encode_enum encode_uint8 identity input_class_int_of_enum buf v.class_id;
    encode_uint8 buf v.len;
    encode_uint8 buf (identity ((* Parsetree.Int32 *) List.length v.valuators));
    encode_mask encode_uint8 identity valuator_state_mode_mask_int_of_mask buf
      v.mode;
    encode_list encode_int32 buf v.valuators;
    ()

  type input_state = { len : int; data : input_class_variant } [@@deriving sexp]

  let decode_input_state buf ~at : (input_state * int) option =
    let orig = at in
    let* data_tag, at = decode_uint8 buf ~at in
    let* len, at = decode_uint8 buf ~at in
    let* data, at = decode_input_class_variant data_tag buf ~at in
    ignore orig;
    Some ({ len; data }, at)

  let encode_input_state buf (v : input_state) =
    (* field_variant_tag *)
    encode_uint8 buf v.len;
    (* field_variant *) ()

  type query_device_state_reply = {
    xi_reply_type : int;
    classes : input_state list;
  }
  [@@deriving sexp]

  let encode_query_device_state ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 30;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_device_state_reply length buf ~at :
      (query_device_state_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_classes, at = decode_uint8 buf ~at in
    let num_classes = num_classes in
    let at = at + 23 in
    let* classes, at = decode_list decode_input_state num_classes buf ~at in
    ignore orig;
    Some ({ xi_reply_type; classes }, at)

  let encode_device_bell ~(device_id : int) ~(feedback_id : int)
      ~(feedback_class : int) ~(percent : int) buf =
    (* opcode *)
    encode_uint8 buf 32;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf feedback_id;
    encode_uint8 buf feedback_class;
    encode_int8 buf percent;
    (* write request length *)
    encode_request_length buf

  type set_device_valuators_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum;
  }
  [@@deriving sexp]

  let encode_set_device_valuators ~(device_id : int) ~(first_valuator : int)
      ~(valuators : int list) buf =
    (* opcode *)
    encode_uint8 buf 33;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf first_valuator;
    encode_uint8 buf (identity ((* Parsetree.Int32 *) List.length valuators));
    encode_pad buf 1;
    encode_list encode_int32 buf valuators;
    (* write request length *)
    encode_request_length buf

  let decode_set_device_valuators_reply length buf ~at :
      (set_device_valuators_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  type device_control_enum =
    [ `Resolution | `Abs_calib | `Core | `Enable | `Abs_area ]
  [@@deriving sexp]

  let device_control_enum_of_int : int -> [> device_control_enum ] option =
    function
    | 1 -> Some `Resolution
    | 2 -> Some `Abs_calib
    | 3 -> Some `Core
    | 4 -> Some `Enable
    | 5 -> Some `Abs_area
    | n ->
        Printf.printf "unknown device_control_enum: %d\n" n;
        None

  let device_control_int_of_enum : device_control_enum -> int = function
    | `Resolution -> 1
    | `Abs_calib -> 2
    | `Core -> 3
    | `Enable -> 4
    | `Abs_area -> 5

  type device_resolution_state = {
    control_id : device_control_enum;
    len : int;
    resolution_values : int list;
    resolution_min : int list;
    resolution_max : int list;
  }
  [@@deriving sexp]

  let decode_device_resolution_state buf ~at :
      (device_resolution_state * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* num_valuators, at = decode_int32 buf ~at in
    let num_valuators = num_valuators in
    let* resolution_values, at =
      decode_list decode_int32 num_valuators buf ~at
    in
    let* resolution_min, at = decode_list decode_int32 num_valuators buf ~at in
    let* resolution_max, at = decode_list decode_int32 num_valuators buf ~at in
    ignore orig;
    Some
      ( { control_id; len; resolution_values; resolution_min; resolution_max },
        at )

  let encode_device_resolution_state buf (v : device_resolution_state) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_int32 buf
      (identity ((* Parsetree.Card32 *) List.length v.resolution_values));
    encode_list encode_int32 buf v.resolution_values;
    encode_list encode_int32 buf v.resolution_min;
    encode_list encode_int32 buf v.resolution_max;
    ()

  type device_abs_calib_state = {
    control_id : device_control_enum;
    len : int;
    min_x : int;
    max_x : int;
    min_y : int;
    max_y : int;
    flip_x : int;
    flip_y : int;
    rotation : int;
    button_threshold : int;
  }
  [@@deriving sexp]

  let decode_device_abs_calib_state buf ~at :
      (device_abs_calib_state * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* min_x, at = decode_int32 buf ~at in
    let* max_x, at = decode_int32 buf ~at in
    let* min_y, at = decode_int32 buf ~at in
    let* max_y, at = decode_int32 buf ~at in
    let* flip_x, at = decode_int32 buf ~at in
    let* flip_y, at = decode_int32 buf ~at in
    let* rotation, at = decode_int32 buf ~at in
    let* button_threshold, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( {
          control_id;
          len;
          min_x;
          max_x;
          min_y;
          max_y;
          flip_x;
          flip_y;
          rotation;
          button_threshold;
        },
        at )

  let encode_device_abs_calib_state buf (v : device_abs_calib_state) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.min_x;
    encode_int32 buf v.max_x;
    encode_int32 buf v.min_y;
    encode_int32 buf v.max_y;
    encode_int32 buf v.flip_x;
    encode_int32 buf v.flip_y;
    encode_int32 buf v.rotation;
    encode_int32 buf v.button_threshold;
    ()

  type device_abs_area_state = {
    control_id : device_control_enum;
    len : int;
    offset_x : int;
    offset_y : int;
    width : int;
    height : int;
    screen : int;
    following : int;
  }
  [@@deriving sexp]

  let decode_device_abs_area_state buf ~at :
      (device_abs_area_state * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* offset_x, at = decode_int32 buf ~at in
    let* offset_y, at = decode_int32 buf ~at in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let* screen, at = decode_int32 buf ~at in
    let* following, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( { control_id; len; offset_x; offset_y; width; height; screen; following },
        at )

  let encode_device_abs_area_state buf (v : device_abs_area_state) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.offset_x;
    encode_int32 buf v.offset_y;
    encode_int32 buf v.width;
    encode_int32 buf v.height;
    encode_int32 buf v.screen;
    encode_int32 buf v.following;
    ()

  type device_core_state = {
    control_id : device_control_enum;
    len : int;
    status : int;
    iscore : int;
  }
  [@@deriving sexp]

  let decode_device_core_state buf ~at : (device_core_state * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* status, at = decode_uint8 buf ~at in
    let* iscore, at = decode_uint8 buf ~at in
    let at = at + 2 in
    ignore orig;
    Some ({ control_id; len; status; iscore }, at)

  let encode_device_core_state buf (v : device_core_state) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_uint8 buf v.status;
    encode_uint8 buf v.iscore;
    encode_pad buf 2;
    ()

  type device_enable_state = {
    control_id : device_control_enum;
    len : int;
    enable : int;
  }
  [@@deriving sexp]

  let decode_device_enable_state buf ~at : (device_enable_state * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* enable, at = decode_uint8 buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ control_id; len; enable }, at)

  let encode_device_enable_state buf (v : device_enable_state) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_uint8 buf v.enable;
    encode_pad buf 3;
    ()

  type device_control_variant =
    | Resolution of {
        resolution_values : int list;
        resolution_min : int list;
        resolution_max : int list;
      }
    | Abs_calib of {
        min_x : int;
        max_x : int;
        min_y : int;
        max_y : int;
        flip_x : int;
        flip_y : int;
        rotation : int;
        button_threshold : int;
      }
    | Core of { status : int; iscore : int }
    | Enable of { enable : int }
    | Abs_area of {
        offset_x : int;
        offset_y : int;
        width : int;
        height : int;
        screen : int;
        following : int;
      }
  [@@deriving sexp]

  let decode_device_control_variant tag buf ~at :
      (device_control_variant * int) option =
    match tag with
    | 1 ->
        let* num_valuators, at = decode_int32 buf ~at in
        let num_valuators = num_valuators in
        let* resolution_values, at =
          decode_list decode_int32 num_valuators buf ~at
        in
        let* resolution_min, at =
          decode_list decode_int32 num_valuators buf ~at
        in
        let* resolution_max, at =
          decode_list decode_int32 num_valuators buf ~at
        in
        Some
          (Resolution { resolution_values; resolution_min; resolution_max }, at)
    | 2 ->
        let* min_x, at = decode_int32 buf ~at in
        let* max_x, at = decode_int32 buf ~at in
        let* min_y, at = decode_int32 buf ~at in
        let* max_y, at = decode_int32 buf ~at in
        let* flip_x, at = decode_int32 buf ~at in
        let* flip_y, at = decode_int32 buf ~at in
        let* rotation, at = decode_int32 buf ~at in
        let* button_threshold, at = decode_int32 buf ~at in
        Some
          ( Abs_calib
              {
                min_x;
                max_x;
                min_y;
                max_y;
                flip_x;
                flip_y;
                rotation;
                button_threshold;
              },
            at )
    | 3 ->
        let* status, at = decode_uint8 buf ~at in
        let* iscore, at = decode_uint8 buf ~at in
        let at = at + 2 in
        Some (Core { status; iscore }, at)
    | 4 ->
        let* enable, at = decode_uint8 buf ~at in
        let at = at + 3 in
        Some (Enable { enable }, at)
    | 5 ->
        let* offset_x, at = decode_int32 buf ~at in
        let* offset_y, at = decode_int32 buf ~at in
        let* width, at = decode_int32 buf ~at in
        let* height, at = decode_int32 buf ~at in
        let* screen, at = decode_int32 buf ~at in
        let* following, at = decode_int32 buf ~at in
        Some
          (Abs_area { offset_x; offset_y; width; height; screen; following }, at)
    | _ -> None

  type device_state = { len : int; data : device_control_variant }
  [@@deriving sexp]

  let decode_device_state buf ~at : (device_state * int) option =
    let orig = at in
    let* data_tag, at = decode_uint16 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* data, at = decode_device_control_variant data_tag buf ~at in
    ignore orig;
    Some ({ len; data }, at)

  let encode_device_state buf (v : device_state) =
    (* field_variant_tag *)
    encode_uint16 buf v.len;
    (* field_variant *) ()

  type get_device_control_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum alt_enum;
    control : device_state;
  }
  [@@deriving sexp]

  let encode_get_device_control ~(control_id : device_control_enum)
      ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 34;
    encode_enum encode_uint16 identity device_control_int_of_enum buf control_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf device_id;
    encode_pad buf 1;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_control_reply length buf ~at :
      (get_device_control_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_alt_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf
        ~at
    in
    let at = at + 23 in
    let* control, at = decode_device_state buf ~at in
    ignore orig;
    Some ({ xi_reply_type; status; control }, at)

  type device_resolution_ctl = {
    control_id : device_control_enum;
    len : int;
    first_valuator : int;
    resolution_values : int list;
  }
  [@@deriving sexp]

  let decode_device_resolution_ctl buf ~at :
      (device_resolution_ctl * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* first_valuator, at = decode_uint8 buf ~at in
    let* num_valuators, at = decode_uint8 buf ~at in
    let num_valuators = num_valuators in
    let at = at + 2 in
    let* resolution_values, at =
      decode_list decode_int32 num_valuators buf ~at
    in
    ignore orig;
    Some ({ control_id; len; first_valuator; resolution_values }, at)

  let encode_device_resolution_ctl buf (v : device_resolution_ctl) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_uint8 buf v.first_valuator;
    encode_uint8 buf
      (identity ((* Parsetree.Card32 *) List.length v.resolution_values));
    encode_pad buf 2;
    encode_list encode_int32 buf v.resolution_values;
    ()

  type device_abs_calib_ctl = {
    control_id : device_control_enum;
    len : int;
    min_x : int;
    max_x : int;
    min_y : int;
    max_y : int;
    flip_x : int;
    flip_y : int;
    rotation : int;
    button_threshold : int;
  }
  [@@deriving sexp]

  let decode_device_abs_calib_ctl buf ~at : (device_abs_calib_ctl * int) option
      =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* min_x, at = decode_int32 buf ~at in
    let* max_x, at = decode_int32 buf ~at in
    let* min_y, at = decode_int32 buf ~at in
    let* max_y, at = decode_int32 buf ~at in
    let* flip_x, at = decode_int32 buf ~at in
    let* flip_y, at = decode_int32 buf ~at in
    let* rotation, at = decode_int32 buf ~at in
    let* button_threshold, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( {
          control_id;
          len;
          min_x;
          max_x;
          min_y;
          max_y;
          flip_x;
          flip_y;
          rotation;
          button_threshold;
        },
        at )

  let encode_device_abs_calib_ctl buf (v : device_abs_calib_ctl) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.min_x;
    encode_int32 buf v.max_x;
    encode_int32 buf v.min_y;
    encode_int32 buf v.max_y;
    encode_int32 buf v.flip_x;
    encode_int32 buf v.flip_y;
    encode_int32 buf v.rotation;
    encode_int32 buf v.button_threshold;
    ()

  type device_abs_area_ctrl = {
    control_id : device_control_enum;
    len : int;
    offset_x : int;
    offset_y : int;
    width : int;
    height : int;
    screen : int;
    following : int;
  }
  [@@deriving sexp]

  let decode_device_abs_area_ctrl buf ~at : (device_abs_area_ctrl * int) option
      =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* offset_x, at = decode_int32 buf ~at in
    let* offset_y, at = decode_int32 buf ~at in
    let* width, at = decode_int32 buf ~at in
    let* height, at = decode_int32 buf ~at in
    let* screen, at = decode_int32 buf ~at in
    let* following, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( { control_id; len; offset_x; offset_y; width; height; screen; following },
        at )

  let encode_device_abs_area_ctrl buf (v : device_abs_area_ctrl) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_int32 buf v.offset_x;
    encode_int32 buf v.offset_y;
    encode_int32 buf v.width;
    encode_int32 buf v.height;
    encode_int32 buf v.screen;
    encode_int32 buf v.following;
    ()

  type device_core_ctrl = {
    control_id : device_control_enum;
    len : int;
    status : int;
  }
  [@@deriving sexp]

  let decode_device_core_ctrl buf ~at : (device_core_ctrl * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* status, at = decode_uint8 buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ control_id; len; status }, at)

  let encode_device_core_ctrl buf (v : device_core_ctrl) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_uint8 buf v.status;
    encode_pad buf 3;
    ()

  type device_enable_ctrl = {
    control_id : device_control_enum;
    len : int;
    enable : int;
  }
  [@@deriving sexp]

  let decode_device_enable_ctrl buf ~at : (device_enable_ctrl * int) option =
    let orig = at in
    let* control_id, at =
      decode_enum decode_uint16 identity device_control_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* enable, at = decode_uint8 buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ control_id; len; enable }, at)

  let encode_device_enable_ctrl buf (v : device_enable_ctrl) =
    encode_enum encode_uint16 identity device_control_int_of_enum buf
      v.control_id;
    encode_uint16 buf v.len;
    encode_uint8 buf v.enable;
    encode_pad buf 3;
    ()

  type device_ctl = { len : int; data : device_control_variant }
  [@@deriving sexp]

  let decode_device_ctl buf ~at : (device_ctl * int) option =
    let orig = at in
    let* data_tag, at = decode_uint16 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* data, at = decode_device_control_variant data_tag buf ~at in
    ignore orig;
    Some ({ len; data }, at)

  let encode_device_ctl buf (v : device_ctl) =
    (* field_variant_tag *)
    encode_uint16 buf v.len;
    (* field_variant *) ()

  type change_device_control_reply = {
    xi_reply_type : int;
    status : Xproto.grab_status_enum alt_enum;
  }
  [@@deriving sexp]

  let encode_change_device_control ~(control_id : device_control_enum)
      ~(device_id : int) ~(control : device_ctl) buf =
    (* opcode *)
    encode_uint8 buf 35;
    encode_enum encode_uint16 identity device_control_int_of_enum buf control_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf device_id;
    encode_pad buf 1;
    encode_device_ctl buf control;
    (* write request length *)
    encode_request_length buf

  let decode_change_device_control_reply length buf ~at :
      (change_device_control_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* status, at =
      decode_alt_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf
        ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ xi_reply_type; status }, at)

  type list_device_properties_reply = {
    xi_reply_type : int;
    atoms : Xproto.atom list;
  }
  [@@deriving sexp]

  let encode_list_device_properties ~(device_id : int) buf =
    (* opcode *)
    encode_uint8 buf 36;
    encode_uint8 buf device_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_list_device_properties_reply length buf ~at :
      (list_device_properties_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* num_atoms, at = decode_uint16 buf ~at in
    let num_atoms = num_atoms in
    let at = at + 22 in
    let* atoms, at = decode_list Xproto.decode_atom num_atoms buf ~at in
    ignore orig;
    Some ({ xi_reply_type; atoms }, at)

  type property_format_enum = [ `D8_bits | `D16_bits | `D32_bits ]
  [@@deriving sexp]

  let property_format_enum_of_int : int -> [> property_format_enum ] option =
    function
    | 8 -> Some `D8_bits
    | 16 -> Some `D16_bits
    | 32 -> Some `D32_bits
    | n ->
        Printf.printf "unknown property_format_enum: %d\n" n;
        None

  let property_format_int_of_enum : property_format_enum -> int = function
    | `D8_bits -> 8
    | `D16_bits -> 16
    | `D32_bits -> 32

  type property_format_variant =
    | D8_bits of { data8 : int list }
    | D16_bits of { data16 : int list }
    | D32_bits of { data32 : int list }
  [@@deriving sexp]

  let decode_property_format_variant tag buf ~at :
      (property_format_variant * int) option =
    match tag with
    | 8 ->
        let* data8, at =
          let length = num_items in
          decode_list decode_uint8 length buf ~at
        in
        let at = at + ((at - orig) mod 4) in
        Some (D8_bits { data8 }, at)
    | 16 ->
        let* data16, at =
          let length = num_items in
          decode_list decode_uint16 length buf ~at
        in
        let at = at + ((at - orig) mod 4) in
        Some (D16_bits { data16 }, at)
    | 32 ->
        let* data32, at =
          let length = num_items in
          decode_list decode_int32 length buf ~at
        in
        Some (D32_bits { data32 }, at)
    | _ -> None

  let encode_change_device_property ~(property : Xproto.atom)
      ~(type_ : Xproto.atom) ~(device_id : int) ~(mode : Xproto.prop_mode_enum)
      ~(num_items : int) ~(items : property_format_variant) buf =
    (* opcode *)
    encode_uint8 buf 37;
    Xproto.encode_atom buf property;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf type_;
    encode_uint8 buf device_id;
    (* field_variant_tag *)
    encode_enum encode_uint8 identity Xproto.prop_mode_int_of_enum buf mode;
    encode_pad buf 1;
    encode_int32 buf num_items;
    (* field_variant *)
    (* write request length *)
    encode_request_length buf

  let encode_delete_device_property ~(property : Xproto.atom) ~(device_id : int)
      buf =
    (* opcode *)
    encode_uint8 buf 38;
    Xproto.encode_atom buf property;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf device_id;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type get_device_property_reply = {
    xi_reply_type : int;
    type_ : Xproto.atom;
    bytes_after : int;
    num_items : int;
    device_id : int;
    items : property_format_variant;
  }
  [@@deriving sexp]

  let encode_get_device_property ~(property : Xproto.atom)
      ~(type_ : Xproto.atom) ~(offset : int) ~(len : int) ~(device_id : int)
      ~(delete : bool) buf =
    (* opcode *)
    encode_uint8 buf 39;
    Xproto.encode_atom buf property;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf type_;
    encode_int32 buf offset;
    encode_int32 buf len;
    encode_uint8 buf device_id;
    encode_bool buf delete;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_property_reply length buf ~at :
      (get_device_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* xi_reply_type, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* type_, at = Xproto.decode_atom buf ~at in
    let* bytes_after, at = decode_int32 buf ~at in
    let* num_items, at = decode_int32 buf ~at in
    let* items_tag, at = decode_uint8 buf ~at in
    let* device_id, at = decode_uint8 buf ~at in
    let at = at + 10 in
    let* items, at = decode_property_format_variant items_tag buf ~at in
    ignore orig;
    Some ({ xi_reply_type; type_; bytes_after; num_items; device_id; items }, at)

  type device_enum = [ `All | `All_master ] [@@deriving sexp]

  let device_enum_of_int : int -> [> device_enum ] option = function
    | 0 -> Some `All
    | 1 -> Some `All_master
    | n ->
        Printf.printf "unknown device_enum: %d\n" n;
        None

  let device_int_of_enum : device_enum -> int = function
    | `All -> 0
    | `All_master -> 1

  type group_info = { base : int; latched : int; locked : int; effective : int }
  [@@deriving sexp]

  let decode_group_info buf ~at : (group_info * int) option =
    let orig = at in
    let* base, at = decode_uint8 buf ~at in
    let* latched, at = decode_uint8 buf ~at in
    let* locked, at = decode_uint8 buf ~at in
    let* effective, at = decode_uint8 buf ~at in
    ignore orig;
    Some ({ base; latched; locked; effective }, at)

  let encode_group_info buf (v : group_info) =
    encode_uint8 buf v.base;
    encode_uint8 buf v.latched;
    encode_uint8 buf v.locked;
    encode_uint8 buf v.effective;
    ()

  type modifier_info = {
    base : int;
    latched : int;
    locked : int;
    effective : int;
  }
  [@@deriving sexp]

  let decode_modifier_info buf ~at : (modifier_info * int) option =
    let orig = at in
    let* base, at = decode_int32 buf ~at in
    let* latched, at = decode_int32 buf ~at in
    let* locked, at = decode_int32 buf ~at in
    let* effective, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ base; latched; locked; effective }, at)

  let encode_modifier_info buf (v : modifier_info) =
    encode_int32 buf v.base;
    encode_int32 buf v.latched;
    encode_int32 buf v.locked;
    encode_int32 buf v.effective;
    ()

  type xi_query_pointer_reply = {
    root : Xproto.window;
    child : Xproto.window;
    root_x : fp1616;
    root_y : fp1616;
    win_x : fp1616;
    win_y : fp1616;
    same_screen : bool;
    mods : modifier_info;
    group : group_info;
    buttons : int list;
  }
  [@@deriving sexp]

  let encode_xi_query_pointer ~(window : Xproto.window)
      ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 40;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_xi_query_pointer_reply length buf ~at :
      (xi_query_pointer_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* root, at = Xproto.decode_window buf ~at in
    let* child, at = Xproto.decode_window buf ~at in
    let* root_x, at = decode_fp1616 buf ~at in
    let* root_y, at = decode_fp1616 buf ~at in
    let* win_x, at = decode_fp1616 buf ~at in
    let* win_y, at = decode_fp1616 buf ~at in
    let* same_screen, at = decode_bool buf ~at in
    let at = at + 1 in
    let* buttons_len, at = decode_uint16 buf ~at in
    let buttons_len = buttons_len in
    let* mods, at = decode_modifier_info buf ~at in
    let* group, at = decode_group_info buf ~at in
    let* buttons, at = decode_list decode_int32 buttons_len buf ~at in
    ignore orig;
    Some
      ( {
          root;
          child;
          root_x;
          root_y;
          win_x;
          win_y;
          same_screen;
          mods;
          group;
          buttons;
        },
        at )

  let encode_xi_warp_pointer ~(src_win : Xproto.window)
      ~(dst_win : Xproto.window) ~(src_x : fp1616) ~(src_y : fp1616)
      ~(src_width : int) ~(src_height : int) ~(dst_x : fp1616) ~(dst_y : fp1616)
      ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 41;
    Xproto.encode_window buf src_win;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf dst_win;
    encode_fp1616 buf src_x;
    encode_fp1616 buf src_y;
    encode_uint16 buf src_width;
    encode_uint16 buf src_height;
    encode_fp1616 buf dst_x;
    encode_fp1616 buf dst_y;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let encode_xi_change_cursor ~(window : Xproto.window)
      ~(cursor : Xproto.cursor) ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 42;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_cursor buf cursor;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type hierarchy_change_type_enum =
    [ `Add_master | `Remove_master | `Attach_slave | `Detach_slave ]
  [@@deriving sexp]

  let hierarchy_change_type_enum_of_int :
      int -> [> hierarchy_change_type_enum ] option = function
    | 1 -> Some `Add_master
    | 2 -> Some `Remove_master
    | 3 -> Some `Attach_slave
    | 4 -> Some `Detach_slave
    | n ->
        Printf.printf "unknown hierarchy_change_type_enum: %d\n" n;
        None

  let hierarchy_change_type_int_of_enum : hierarchy_change_type_enum -> int =
    function
    | `Add_master -> 1
    | `Remove_master -> 2
    | `Attach_slave -> 3
    | `Detach_slave -> 4

  type change_mode_enum = [ `Attach | `Float ] [@@deriving sexp]

  let change_mode_enum_of_int : int -> [> change_mode_enum ] option = function
    | 1 -> Some `Attach
    | 2 -> Some `Float
    | n ->
        Printf.printf "unknown change_mode_enum: %d\n" n;
        None

  let change_mode_int_of_enum : change_mode_enum -> int = function
    | `Attach -> 1
    | `Float -> 2

  type add_master = {
    type_ : hierarchy_change_type_enum;
    len : int;
    send_core : bool;
    enable : bool;
    name : string;
  }
  [@@deriving sexp]

  let decode_add_master buf ~at : (add_master * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf
        ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* name_len, at = decode_uint16 buf ~at in
    let name_len = name_len in
    let* send_core, at = decode_bool buf ~at in
    let* enable, at = decode_bool buf ~at in
    let* name, at = decode_string name_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ type_; len; send_core; enable; name }, at)

  let encode_add_master buf (v : add_master) =
    encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf
      v.type_;
    encode_uint16 buf v.len;
    encode_uint16 buf (identity (String.length v.name));
    encode_bool buf v.send_core;
    encode_bool buf v.enable;
    encode_string buf v.name;
    encode_align buf 4;
    ()

  type remove_master = {
    type_ : hierarchy_change_type_enum;
    len : int;
    deviceid : device_enum alt_enum;
    return_mode : change_mode_enum;
    return_pointer : device_enum alt_enum;
    return_keyboard : device_enum alt_enum;
  }
  [@@deriving sexp]

  let decode_remove_master buf ~at : (remove_master * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf
        ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* return_mode, at =
      decode_enum decode_uint8 identity change_mode_enum_of_int buf ~at
    in
    let at = at + 1 in
    let* return_pointer, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* return_keyboard, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    ignore orig;
    Some
      ( { type_; len; deviceid; return_mode; return_pointer; return_keyboard },
        at )

  let encode_remove_master buf (v : remove_master) =
    encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf
      v.type_;
    encode_uint16 buf v.len;
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid;
    encode_enum encode_uint8 identity change_mode_int_of_enum buf v.return_mode;
    encode_pad buf 1;
    encode_alt_enum encode_device_id identity device_int_of_enum buf
      v.return_pointer;
    encode_alt_enum encode_device_id identity device_int_of_enum buf
      v.return_keyboard;
    ()

  type attach_slave = {
    type_ : hierarchy_change_type_enum;
    len : int;
    deviceid : device_enum alt_enum;
    master : device_enum alt_enum;
  }
  [@@deriving sexp]

  let decode_attach_slave buf ~at : (attach_slave * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf
        ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* master, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    ignore orig;
    Some ({ type_; len; deviceid; master }, at)

  let encode_attach_slave buf (v : attach_slave) =
    encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf
      v.type_;
    encode_uint16 buf v.len;
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid;
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.master;
    ()

  type detach_slave = {
    type_ : hierarchy_change_type_enum;
    len : int;
    deviceid : device_enum alt_enum;
  }
  [@@deriving sexp]

  let decode_detach_slave buf ~at : (detach_slave * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity hierarchy_change_type_enum_of_int buf
        ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let at = at + 2 in
    ignore orig;
    Some ({ type_; len; deviceid }, at)

  let encode_detach_slave buf (v : detach_slave) =
    encode_enum encode_uint16 identity hierarchy_change_type_int_of_enum buf
      v.type_;
    encode_uint16 buf v.len;
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid;
    encode_pad buf 2;
    ()

  type hierarchy_change_type_variant =
    | Add_master of { send_core : bool; enable : bool; name : string }
    | Remove_master of {
        deviceid : device_enum alt_enum;
        return_mode : change_mode_enum;
        return_pointer : device_enum alt_enum;
        return_keyboard : device_enum alt_enum;
      }
    | Attach_slave of {
        deviceid : device_enum alt_enum;
        master : device_enum alt_enum;
      }
    | Detach_slave of { deviceid : device_enum alt_enum }
  [@@deriving sexp]

  let decode_hierarchy_change_type_variant tag buf ~at :
      (hierarchy_change_type_variant * int) option =
    match tag with
    | 1 ->
        let* name_len, at = decode_uint16 buf ~at in
        let name_len = name_len in
        let* send_core, at = decode_bool buf ~at in
        let* enable, at = decode_bool buf ~at in
        let* name, at = decode_string name_len buf ~at in
        let at = at + ((at - orig) mod 4) in
        Some (Add_master { send_core; enable; name }, at)
    | 2 ->
        let* deviceid, at =
          decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
        in
        let* return_mode, at =
          decode_enum decode_uint8 identity change_mode_enum_of_int buf ~at
        in
        let at = at + 1 in
        let* return_pointer, at =
          decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
        in
        let* return_keyboard, at =
          decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
        in
        Some
          ( Remove_master
              { deviceid; return_mode; return_pointer; return_keyboard },
            at )
    | 3 ->
        let* deviceid, at =
          decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
        in
        let* master, at =
          decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
        in
        Some (Attach_slave { deviceid; master }, at)
    | 4 ->
        let* deviceid, at =
          decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
        in
        let at = at + 2 in
        Some (Detach_slave { deviceid }, at)
    | _ -> None

  type hierarchy_change = { len : int; data : hierarchy_change_type_variant }
  [@@deriving sexp]

  let decode_hierarchy_change buf ~at : (hierarchy_change * int) option =
    let orig = at in
    let* data_tag, at = decode_uint16 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* data, at = decode_hierarchy_change_type_variant data_tag buf ~at in
    ignore orig;
    Some ({ len; data }, at)

  let encode_hierarchy_change buf (v : hierarchy_change) =
    (* field_variant_tag *)
    encode_uint16 buf v.len;
    (* field_variant *) ()

  let encode_xi_change_hierarchy ~(changes : hierarchy_change list) buf =
    (* opcode *)
    encode_uint8 buf 43;
    encode_uint8 buf (identity ((* invalid_argument *) List.length changes));
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    encode_list encode_hierarchy_change buf changes;
    (* write request length *)
    encode_request_length buf

  let encode_xi_set_client_pointer ~(window : Xproto.window)
      ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 44;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type xi_get_client_pointer_reply = {
    set : bool;
    deviceid : device_enum alt_enum;
  }
  [@@deriving sexp]

  let encode_xi_get_client_pointer ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 45;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_xi_get_client_pointer_reply length buf ~at :
      (xi_get_client_pointer_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* set, at = decode_bool buf ~at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let at = at + 20 in
    ignore orig;
    Some ({ set; deviceid }, at)

  type xi_event_mask =
    [ `Device_changed
    | `Key_press
    | `Key_release
    | `Button_press
    | `Button_release
    | `Motion
    | `Enter
    | `Leave
    | `Focus_in
    | `Focus_out
    | `Hierarchy
    | `Property
    | `Raw_key_press
    | `Raw_key_release
    | `Raw_button_press
    | `Raw_button_release
    | `Raw_motion
    | `Touch_begin
    | `Touch_update
    | `Touch_end
    | `Touch_ownership
    | `Raw_touch_begin
    | `Raw_touch_update
    | `Raw_touch_end
    | `Barrier_hit
    | `Barrier_leave ]
    list
  [@@deriving sexp]

  let xi_event_mask_mask_of_int64 mask : xi_event_mask option =
    let of_int = function
      | 1 -> Some `Device_changed
      | 2 -> Some `Key_press
      | 3 -> Some `Key_release
      | 4 -> Some `Button_press
      | 5 -> Some `Button_release
      | 6 -> Some `Motion
      | 7 -> Some `Enter
      | 8 -> Some `Leave
      | 9 -> Some `Focus_in
      | 10 -> Some `Focus_out
      | 11 -> Some `Hierarchy
      | 12 -> Some `Property
      | 13 -> Some `Raw_key_press
      | 14 -> Some `Raw_key_release
      | 15 -> Some `Raw_button_press
      | 16 -> Some `Raw_button_release
      | 17 -> Some `Raw_motion
      | 18 -> Some `Touch_begin
      | 19 -> Some `Touch_update
      | 20 -> Some `Touch_end
      | 21 -> Some `Touch_ownership
      | 22 -> Some `Raw_touch_begin
      | 23 -> Some `Raw_touch_update
      | 24 -> Some `Raw_touch_end
      | 25 -> Some `Barrier_hit
      | 26 -> Some `Barrier_leave
      | _ -> None
    in
    mask_of_int of_int mask

  let xi_event_mask_int_of_mask : xi_event_mask -> int =
    let to_bit = function
      | `Device_changed -> 1
      | `Key_press -> 2
      | `Key_release -> 3
      | `Button_press -> 4
      | `Button_release -> 5
      | `Motion -> 6
      | `Enter -> 7
      | `Leave -> 8
      | `Focus_in -> 9
      | `Focus_out -> 10
      | `Hierarchy -> 11
      | `Property -> 12
      | `Raw_key_press -> 13
      | `Raw_key_release -> 14
      | `Raw_button_press -> 15
      | `Raw_button_release -> 16
      | `Raw_motion -> 17
      | `Touch_begin -> 18
      | `Touch_update -> 19
      | `Touch_end -> 20
      | `Touch_ownership -> 21
      | `Raw_touch_begin -> 22
      | `Raw_touch_update -> 23
      | `Raw_touch_end -> 24
      | `Barrier_hit -> 25
      | `Barrier_leave -> 26
    in
    int_of_mask to_bit

  type event_mask = {
    deviceid : device_enum alt_enum;
    mask : xi_event_mask list;
  }
  [@@deriving sexp]

  let decode_event_mask buf ~at : (event_mask * int) option =
    let orig = at in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* mask_len, at = decode_uint16 buf ~at in
    let mask_len = mask_len in
    let* mask, at =
      decode_list
        (decode_mask decode_int32 Int64.of_int xi_event_mask_mask_of_int64)
        mask_len buf ~at
    in
    ignore orig;
    Some ({ deviceid; mask }, at)

  let encode_event_mask buf (v : event_mask) =
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.mask));
    encode_list encode_mask encode_int32 identity xi_event_mask_int_of_mask buf
      v.mask;
    ()

  let encode_xi_select_events ~(window : Xproto.window)
      ~(masks : event_mask list) buf =
    (* opcode *)
    encode_uint8 buf 46;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf (identity ((* invalid_argument *) List.length masks));
    encode_pad buf 2;
    encode_list encode_event_mask buf masks;
    (* write request length *)
    encode_request_length buf

  type xi_query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_xi_query_version ~(major_version : int) ~(minor_version : int) buf
      =
    (* opcode *)
    encode_uint8 buf 47;
    encode_uint16 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_xi_query_version_reply length buf ~at :
      (xi_query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type device_class_type_enum = [ `Key | `Button | `Valuator | `Scroll | `Touch ]
  [@@deriving sexp]

  let device_class_type_enum_of_int : int -> [> device_class_type_enum ] option
      = function
    | 0 -> Some `Key
    | 1 -> Some `Button
    | 2 -> Some `Valuator
    | 3 -> Some `Scroll
    | 8 -> Some `Touch
    | n ->
        Printf.printf "unknown device_class_type_enum: %d\n" n;
        None

  let device_class_type_int_of_enum : device_class_type_enum -> int = function
    | `Key -> 0
    | `Button -> 1
    | `Valuator -> 2
    | `Scroll -> 3
    | `Touch -> 8

  type device_type_enum =
    [ `Master_pointer
    | `Master_keyboard
    | `Slave_pointer
    | `Slave_keyboard
    | `Floating_slave ]
  [@@deriving sexp]

  let device_type_enum_of_int : int -> [> device_type_enum ] option = function
    | 1 -> Some `Master_pointer
    | 2 -> Some `Master_keyboard
    | 3 -> Some `Slave_pointer
    | 4 -> Some `Slave_keyboard
    | 5 -> Some `Floating_slave
    | n ->
        Printf.printf "unknown device_type_enum: %d\n" n;
        None

  let device_type_int_of_enum : device_type_enum -> int = function
    | `Master_pointer -> 1
    | `Master_keyboard -> 2
    | `Slave_pointer -> 3
    | `Slave_keyboard -> 4
    | `Floating_slave -> 5

  type scroll_flags_mask = [ `No_emulation | `Preferred ] list [@@deriving sexp]

  let scroll_flags_mask_of_int64 mask : scroll_flags_mask option =
    let of_int = function
      | 0 -> Some `No_emulation
      | 1 -> Some `Preferred
      | _ -> None
    in
    mask_of_int of_int mask

  let scroll_flags_int_of_mask : scroll_flags_mask -> int =
    let to_bit = function `No_emulation -> 0 | `Preferred -> 1 in
    int_of_mask to_bit

  type scroll_type_enum = [ `Vertical | `Horizontal ] [@@deriving sexp]

  let scroll_type_enum_of_int : int -> [> scroll_type_enum ] option = function
    | 1 -> Some `Vertical
    | 2 -> Some `Horizontal
    | n ->
        Printf.printf "unknown scroll_type_enum: %d\n" n;
        None

  let scroll_type_int_of_enum : scroll_type_enum -> int = function
    | `Vertical -> 1
    | `Horizontal -> 2

  type touch_mode_enum = [ `Direct | `Dependent ] [@@deriving sexp]

  let touch_mode_enum_of_int : int -> [> touch_mode_enum ] option = function
    | 1 -> Some `Direct
    | 2 -> Some `Dependent
    | n ->
        Printf.printf "unknown touch_mode_enum: %d\n" n;
        None

  let touch_mode_int_of_enum : touch_mode_enum -> int = function
    | `Direct -> 1
    | `Dependent -> 2

  type button_class = {
    type_ : device_class_type_enum;
    len : int;
    sourceid : device_id;
    state : int list;
    labels : Xproto.atom list;
  }
  [@@deriving sexp]

  let decode_button_class buf ~at : (button_class * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* sourceid, at = decode_device_id buf ~at in
    let* num_buttons, at = decode_uint16 buf ~at in
    let num_buttons = num_buttons in
    let* state, at =
      let length = (num_buttons + 31) / 32 in
      decode_list decode_int32 length buf ~at
    in
    let* labels, at = decode_list Xproto.decode_atom num_buttons buf ~at in
    ignore orig;
    Some ({ type_; len; sourceid; state; labels }, at)

  let encode_button_class buf (v : button_class) =
    encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_;
    encode_uint16 buf v.len;
    encode_device_id buf v.sourceid;
    encode_uint16 buf (identity ((* Parsetree.Xid *) List.length v.labels));
    encode_list encode_int32 buf v.state;
    encode_list Xproto.encode_atom buf v.labels;
    ()

  type key_class = {
    type_ : device_class_type_enum;
    len : int;
    sourceid : device_id;
    keys : int list;
  }
  [@@deriving sexp]

  let decode_key_class buf ~at : (key_class * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* sourceid, at = decode_device_id buf ~at in
    let* num_keys, at = decode_uint16 buf ~at in
    let num_keys = num_keys in
    let* keys, at = decode_list decode_int32 num_keys buf ~at in
    ignore orig;
    Some ({ type_; len; sourceid; keys }, at)

  let encode_key_class buf (v : key_class) =
    encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_;
    encode_uint16 buf v.len;
    encode_device_id buf v.sourceid;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length v.keys));
    encode_list encode_int32 buf v.keys;
    ()

  type scroll_class = {
    type_ : device_class_type_enum;
    len : int;
    sourceid : device_id;
    number : int;
    scroll_type : scroll_type_enum;
    flags : scroll_flags_mask;
    increment : fp3232;
  }
  [@@deriving sexp]

  let decode_scroll_class buf ~at : (scroll_class * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* sourceid, at = decode_device_id buf ~at in
    let* number, at = decode_uint16 buf ~at in
    let* scroll_type, at =
      decode_enum decode_uint16 identity scroll_type_enum_of_int buf ~at
    in
    let at = at + 2 in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int scroll_flags_mask_of_int64 buf ~at
    in
    let* increment, at = decode_fp3232 buf ~at in
    ignore orig;
    Some ({ type_; len; sourceid; number; scroll_type; flags; increment }, at)

  let encode_scroll_class buf (v : scroll_class) =
    encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_;
    encode_uint16 buf v.len;
    encode_device_id buf v.sourceid;
    encode_uint16 buf v.number;
    encode_enum encode_uint16 identity scroll_type_int_of_enum buf v.scroll_type;
    encode_pad buf 2;
    encode_mask encode_int32 identity scroll_flags_int_of_mask buf v.flags;
    encode_fp3232 buf v.increment;
    ()

  type touch_class = {
    type_ : device_class_type_enum;
    len : int;
    sourceid : device_id;
    mode : touch_mode_enum;
    num_touches : int;
  }
  [@@deriving sexp]

  let decode_touch_class buf ~at : (touch_class * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* sourceid, at = decode_device_id buf ~at in
    let* mode, at =
      decode_enum decode_uint8 identity touch_mode_enum_of_int buf ~at
    in
    let* num_touches, at = decode_uint8 buf ~at in
    ignore orig;
    Some ({ type_; len; sourceid; mode; num_touches }, at)

  let encode_touch_class buf (v : touch_class) =
    encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_;
    encode_uint16 buf v.len;
    encode_device_id buf v.sourceid;
    encode_enum encode_uint8 identity touch_mode_int_of_enum buf v.mode;
    encode_uint8 buf v.num_touches;
    ()

  type valuator_class = {
    type_ : device_class_type_enum;
    len : int;
    sourceid : device_id;
    number : int;
    label : Xproto.atom;
    min : fp3232;
    max : fp3232;
    value : fp3232;
    resolution : int;
    mode : valuator_mode_enum;
  }
  [@@deriving sexp]

  let decode_valuator_class buf ~at : (valuator_class * int) option =
    let orig = at in
    let* type_, at =
      decode_enum decode_uint16 identity device_class_type_enum_of_int buf ~at
    in
    let* len, at = decode_uint16 buf ~at in
    let* sourceid, at = decode_device_id buf ~at in
    let* number, at = decode_uint16 buf ~at in
    let* label, at = Xproto.decode_atom buf ~at in
    let* min, at = decode_fp3232 buf ~at in
    let* max, at = decode_fp3232 buf ~at in
    let* value, at = decode_fp3232 buf ~at in
    let* resolution, at = decode_int32 buf ~at in
    let* mode, at =
      decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some
      ( {
          type_;
          len;
          sourceid;
          number;
          label;
          min;
          max;
          value;
          resolution;
          mode;
        },
        at )

  let encode_valuator_class buf (v : valuator_class) =
    encode_enum encode_uint16 identity device_class_type_int_of_enum buf v.type_;
    encode_uint16 buf v.len;
    encode_device_id buf v.sourceid;
    encode_uint16 buf v.number;
    Xproto.encode_atom buf v.label;
    encode_fp3232 buf v.min;
    encode_fp3232 buf v.max;
    encode_fp3232 buf v.value;
    encode_int32 buf v.resolution;
    encode_enum encode_uint8 identity valuator_mode_int_of_enum buf v.mode;
    encode_pad buf 3;
    ()

  type device_class_type_variant =
    | Key of { keys : int list }
    | Button of { state : int list; labels : Xproto.atom list }
    | Valuator of {
        number : int;
        label : Xproto.atom;
        min : fp3232;
        max : fp3232;
        value : fp3232;
        resolution : int;
        mode : valuator_mode_enum;
      }
    | Scroll of {
        number : int;
        scroll_type : scroll_type_enum;
        flags : scroll_flags_mask;
        increment : fp3232;
      }
    | Touch of { mode : touch_mode_enum; num_touches : int }
  [@@deriving sexp]

  let decode_device_class_type_variant tag buf ~at :
      (device_class_type_variant * int) option =
    match tag with
    | 0 ->
        let* num_keys, at = decode_uint16 buf ~at in
        let num_keys = num_keys in
        let* keys, at = decode_list decode_int32 num_keys buf ~at in
        Some (Key { keys }, at)
    | 1 ->
        let* num_buttons, at = decode_uint16 buf ~at in
        let num_buttons = num_buttons in
        let* state, at =
          let length = (num_buttons + 31) / 32 in
          decode_list decode_int32 length buf ~at
        in
        let* labels, at = decode_list Xproto.decode_atom num_buttons buf ~at in
        Some (Button { state; labels }, at)
    | 2 ->
        let* number, at = decode_uint16 buf ~at in
        let* label, at = Xproto.decode_atom buf ~at in
        let* min, at = decode_fp3232 buf ~at in
        let* max, at = decode_fp3232 buf ~at in
        let* value, at = decode_fp3232 buf ~at in
        let* resolution, at = decode_int32 buf ~at in
        let* mode, at =
          decode_enum decode_uint8 identity valuator_mode_enum_of_int buf ~at
        in
        let at = at + 3 in
        Some (Valuator { number; label; min; max; value; resolution; mode }, at)
    | 3 ->
        let* number, at = decode_uint16 buf ~at in
        let* scroll_type, at =
          decode_enum decode_uint16 identity scroll_type_enum_of_int buf ~at
        in
        let at = at + 2 in
        let* flags, at =
          decode_mask decode_int32 Int64.of_int scroll_flags_mask_of_int64 buf
            ~at
        in
        let* increment, at = decode_fp3232 buf ~at in
        Some (Scroll { number; scroll_type; flags; increment }, at)
    | 8 ->
        let* mode, at =
          decode_enum decode_uint8 identity touch_mode_enum_of_int buf ~at
        in
        let* num_touches, at = decode_uint8 buf ~at in
        Some (Touch { mode; num_touches }, at)
    | _ -> None

  type device_class = {
    len : int;
    sourceid : device_id;
    data : device_class_type_variant;
  }
  [@@deriving sexp]

  let decode_device_class buf ~at : (device_class * int) option =
    let orig = at in
    let* data_tag, at = decode_uint16 buf ~at in
    let* len, at = decode_uint16 buf ~at in
    let* sourceid, at = decode_device_id buf ~at in
    let* data, at = decode_device_class_type_variant data_tag buf ~at in
    ignore orig;
    Some ({ len; sourceid; data }, at)

  let encode_device_class buf (v : device_class) =
    (* field_variant_tag *)
    encode_uint16 buf v.len;
    encode_device_id buf v.sourceid;
    (* field_variant *) ()

  type xi_device_info = {
    deviceid : device_enum alt_enum;
    type_ : device_type_enum;
    attachment : device_enum alt_enum;
    enabled : bool;
    name : string;
    classes : device_class list;
  }
  [@@deriving sexp]

  let decode_xi_device_info buf ~at : (xi_device_info * int) option =
    let orig = at in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* type_, at =
      decode_enum decode_uint16 identity device_type_enum_of_int buf ~at
    in
    let* attachment, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* num_classes, at = decode_uint16 buf ~at in
    let num_classes = num_classes in
    let* name_len, at = decode_uint16 buf ~at in
    let name_len = name_len in
    let* enabled, at = decode_bool buf ~at in
    let at = at + 1 in
    let* name, at = decode_string name_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* classes, at = decode_list decode_device_class num_classes buf ~at in
    ignore orig;
    Some ({ deviceid; type_; attachment; enabled; name; classes }, at)

  let encode_xi_device_info buf (v : xi_device_info) =
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid;
    encode_enum encode_uint16 identity device_type_int_of_enum buf v.type_;
    encode_alt_enum encode_device_id identity device_int_of_enum buf
      v.attachment;
    encode_uint16 buf (identity ((* invalid_argument *) List.length v.classes));
    encode_uint16 buf (identity (String.length v.name));
    encode_bool buf v.enabled;
    encode_pad buf 1;
    encode_string buf v.name;
    encode_align buf 4;
    encode_list encode_device_class buf v.classes;
    ()

  type xi_query_device_reply = xi_device_info list [@@deriving sexp]

  let encode_xi_query_device ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 48;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_xi_query_device_reply length buf ~at :
      (xi_query_device_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_infos, at = decode_uint16 buf ~at in
    let num_infos = num_infos in
    let at = at + 22 in
    let* infos, at = decode_list decode_xi_device_info num_infos buf ~at in
    ignore orig;
    Some (infos, at)

  let encode_xi_set_focus ~(window : Xproto.window)
      ~(time : Xproto.time_enum alt_enum) ~(deviceid : device_enum alt_enum) buf
      =
    (* opcode *)
    encode_uint8 buf 49;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type xi_get_focus_reply = Xproto.window [@@deriving sexp]

  let encode_xi_get_focus ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 50;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_xi_get_focus_reply length buf ~at :
      (xi_get_focus_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* focus, at = Xproto.decode_window buf ~at in
    let at = at + 20 in
    ignore orig;
    Some (focus, at)

  type grab_owner_enum = [ `No_owner | `Owner ] [@@deriving sexp]

  let grab_owner_enum_of_int : int -> [> grab_owner_enum ] option = function
    | 0 -> Some `No_owner
    | 1 -> Some `Owner
    | n ->
        Printf.printf "unknown grab_owner_enum: %d\n" n;
        None

  let grab_owner_int_of_enum : grab_owner_enum -> int = function
    | `No_owner -> 0
    | `Owner -> 1

  type xi_grab_device_reply = Xproto.grab_status_enum [@@deriving sexp]

  let encode_xi_grab_device ~(window : Xproto.window)
      ~(time : Xproto.time_enum alt_enum) ~(cursor : Xproto.cursor)
      ~(deviceid : device_enum alt_enum) ~(mode : Xproto.grab_mode_enum)
      ~(paired_device_mode : Xproto.grab_mode_enum)
      ~(owner_events : grab_owner_enum) ~(mask : int list) buf =
    (* opcode *)
    encode_uint8 buf 51;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    Xproto.encode_cursor buf cursor;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf mode;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      paired_device_mode;
    encode_enum encode_bool bool_of_int grab_owner_int_of_enum buf owner_events;
    encode_pad buf 1;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length mask));
    encode_list encode_int32 buf mask;
    (* write request length *)
    encode_request_length buf

  let decode_xi_grab_device_reply length buf ~at :
      (xi_grab_device_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some (status, at)

  let encode_xi_ungrab_device ~(time : Xproto.time_enum alt_enum)
      ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 52;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  type event_mode_enum =
    [ `Async_device
    | `Sync_device
    | `Replay_device
    | `Async_paired_device
    | `Async_pair
    | `Sync_pair
    | `Accept_touch
    | `Reject_touch ]
  [@@deriving sexp]

  let event_mode_enum_of_int : int -> [> event_mode_enum ] option = function
    | 0 -> Some `Async_device
    | 1 -> Some `Sync_device
    | 2 -> Some `Replay_device
    | 3 -> Some `Async_paired_device
    | 4 -> Some `Async_pair
    | 5 -> Some `Sync_pair
    | 6 -> Some `Accept_touch
    | 7 -> Some `Reject_touch
    | n ->
        Printf.printf "unknown event_mode_enum: %d\n" n;
        None

  let event_mode_int_of_enum : event_mode_enum -> int = function
    | `Async_device -> 0
    | `Sync_device -> 1
    | `Replay_device -> 2
    | `Async_paired_device -> 3
    | `Async_pair -> 4
    | `Sync_pair -> 5
    | `Accept_touch -> 6
    | `Reject_touch -> 7

  let encode_xi_allow_events ~(time : Xproto.time_enum alt_enum)
      ~(deviceid : device_enum alt_enum) ~(event_mode : event_mode_enum)
      ~(touchid : int) ~(grab_window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 53;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_enum encode_uint8 identity event_mode_int_of_enum buf event_mode;
    encode_pad buf 1;
    encode_int32 buf touchid;
    Xproto.encode_window buf grab_window;
    (* write request length *)
    encode_request_length buf

  type grab_mode22_enum = [ `Sync | `Async | `Touch ] [@@deriving sexp]

  let grab_mode22_enum_of_int : int -> [> grab_mode22_enum ] option = function
    | 0 -> Some `Sync
    | 1 -> Some `Async
    | 2 -> Some `Touch
    | n ->
        Printf.printf "unknown grab_mode22_enum: %d\n" n;
        None

  let grab_mode22_int_of_enum : grab_mode22_enum -> int = function
    | `Sync -> 0
    | `Async -> 1
    | `Touch -> 2

  type grab_type_enum =
    [ `Button | `Keycode | `Enter | `Focus_in | `Touch_begin ]
  [@@deriving sexp]

  let grab_type_enum_of_int : int -> [> grab_type_enum ] option = function
    | 0 -> Some `Button
    | 1 -> Some `Keycode
    | 2 -> Some `Enter
    | 3 -> Some `Focus_in
    | 4 -> Some `Touch_begin
    | n ->
        Printf.printf "unknown grab_type_enum: %d\n" n;
        None

  let grab_type_int_of_enum : grab_type_enum -> int = function
    | `Button -> 0
    | `Keycode -> 1
    | `Enter -> 2
    | `Focus_in -> 3
    | `Touch_begin -> 4

  type modifier_mask = [ `Any ] list [@@deriving sexp]

  let modifier_mask_mask_of_int64 mask : modifier_mask option =
    let of_int = function 31 -> Some `Any | _ -> None in
    mask_of_int of_int mask

  let modifier_mask_int_of_mask : modifier_mask -> int =
    let to_bit = function `Any -> 31 in
    int_of_mask to_bit

  type grab_modifier_info = {
    modifiers : (modifier_mask, int) mask;
    status : Xproto.grab_status_enum;
  }
  [@@deriving sexp]

  let decode_grab_modifier_info buf ~at : (grab_modifier_info * int) option =
    let orig = at in
    let* modifiers, at =
      decode_alt_mask decode_int32 Int64.of_int modifier_mask_mask_of_int64 buf
        ~at
    in
    let* status, at =
      decode_enum decode_uint8 identity Xproto.grab_status_enum_of_int buf ~at
    in
    let at = at + 3 in
    ignore orig;
    Some ({ modifiers; status }, at)

  let encode_grab_modifier_info buf (v : grab_modifier_info) =
    encode_int32 buf v.modifiers;
    encode_enum encode_uint8 identity Xproto.grab_status_int_of_enum buf
      v.status;
    encode_pad buf 3;
    ()

  type xi_passive_grab_device_reply = grab_modifier_info list [@@deriving sexp]

  let encode_xi_passive_grab_device ~(time : Xproto.time_enum alt_enum)
      ~(grab_window : Xproto.window) ~(cursor : Xproto.cursor) ~(detail : int)
      ~(deviceid : device_enum alt_enum) ~(grab_type : grab_type_enum)
      ~(grab_mode : grab_mode22_enum)
      ~(paired_device_mode : Xproto.grab_mode_enum)
      ~(owner_events : grab_owner_enum) ~(mask : int list)
      ~(modifiers : int list) buf =
    (* opcode *)
    encode_uint8 buf 54;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_window buf grab_window;
    Xproto.encode_cursor buf cursor;
    encode_int32 buf detail;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length modifiers));
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length mask));
    encode_enum encode_uint8 identity grab_type_int_of_enum buf grab_type;
    encode_enum encode_uint8 identity grab_mode22_int_of_enum buf grab_mode;
    encode_enum encode_uint8 identity Xproto.grab_mode_int_of_enum buf
      paired_device_mode;
    encode_enum encode_bool bool_of_int grab_owner_int_of_enum buf owner_events;
    encode_pad buf 2;
    encode_list encode_int32 buf mask;
    encode_list encode_int32 buf modifiers;
    (* write request length *)
    encode_request_length buf

  let decode_xi_passive_grab_device_reply length buf ~at :
      (xi_passive_grab_device_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_modifiers, at = decode_uint16 buf ~at in
    let num_modifiers = num_modifiers in
    let at = at + 22 in
    let* modifiers, at =
      decode_list decode_grab_modifier_info num_modifiers buf ~at
    in
    ignore orig;
    Some (modifiers, at)

  let encode_xi_passive_ungrab_device ~(grab_window : Xproto.window)
      ~(detail : int) ~(deviceid : device_enum alt_enum)
      ~(grab_type : grab_type_enum) ~(modifiers : int list) buf =
    (* opcode *)
    encode_uint8 buf 55;
    Xproto.encode_window buf grab_window;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf detail;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length modifiers));
    encode_enum encode_uint8 identity grab_type_int_of_enum buf grab_type;
    encode_pad buf 3;
    encode_list encode_int32 buf modifiers;
    (* write request length *)
    encode_request_length buf

  type xi_list_properties_reply = Xproto.atom list [@@deriving sexp]

  let encode_xi_list_properties ~(deviceid : device_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 56;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    (* write request length *)
    encode_request_length buf

  let decode_xi_list_properties_reply length buf ~at :
      (xi_list_properties_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_properties, at = decode_uint16 buf ~at in
    let num_properties = num_properties in
    let at = at + 22 in
    let* properties, at =
      decode_list Xproto.decode_atom num_properties buf ~at
    in
    ignore orig;
    Some (properties, at)

  let encode_xi_change_property ~(deviceid : device_enum alt_enum)
      ~(mode : Xproto.prop_mode_enum) ~(property : Xproto.atom)
      ~(type_ : Xproto.atom) ~(num_items : int)
      ~(items : property_format_variant) buf =
    (* opcode *)
    encode_uint8 buf 57;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_enum encode_uint8 identity Xproto.prop_mode_int_of_enum buf mode;
    (* field_variant_tag *)
    Xproto.encode_atom buf property;
    Xproto.encode_atom buf type_;
    encode_int32 buf num_items;
    (* field_variant *)
    (* write request length *)
    encode_request_length buf

  let encode_xi_delete_property ~(deviceid : device_enum alt_enum)
      ~(property : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 58;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  type xi_get_property_reply = {
    type_ : Xproto.atom;
    bytes_after : int;
    num_items : int;
    items : property_format_variant;
  }
  [@@deriving sexp]

  let encode_xi_get_property ~(deviceid : device_enum alt_enum) ~(delete : bool)
      ~(property : Xproto.atom) ~(type_ : Xproto.atom) ~(offset : int)
      ~(len : int) buf =
    (* opcode *)
    encode_uint8 buf 59;
    encode_alt_enum encode_device_id identity device_int_of_enum buf deviceid;
    (* reserve request length *)
    encode_pad buf 2;
    encode_bool buf delete;
    encode_pad buf 1;
    Xproto.encode_atom buf property;
    Xproto.encode_atom buf type_;
    encode_int32 buf offset;
    encode_int32 buf len;
    (* write request length *)
    encode_request_length buf

  let decode_xi_get_property_reply length buf ~at :
      (xi_get_property_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* type_, at = Xproto.decode_atom buf ~at in
    let* bytes_after, at = decode_int32 buf ~at in
    let* num_items, at = decode_int32 buf ~at in
    let* items_tag, at = decode_uint8 buf ~at in
    let at = at + 11 in
    let* items, at = decode_property_format_variant items_tag buf ~at in
    ignore orig;
    Some ({ type_; bytes_after; num_items; items }, at)

  type xi_get_selected_events_reply = event_mask list [@@deriving sexp]

  let encode_xi_get_selected_events ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 60;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_xi_get_selected_events_reply length buf ~at :
      (xi_get_selected_events_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_masks, at = decode_uint16 buf ~at in
    let num_masks = num_masks in
    let at = at + 22 in
    let* masks, at = decode_list decode_event_mask num_masks buf ~at in
    ignore orig;
    Some (masks, at)

  type barrier_release_pointer_info = {
    deviceid : device_id;
    barrier : Xfixes.barrier;
    eventid : int;
  }
  [@@deriving sexp]

  let decode_barrier_release_pointer_info buf ~at :
      (barrier_release_pointer_info * int) option =
    let orig = at in
    let* deviceid, at = decode_device_id buf ~at in
    let at = at + 2 in
    let* barrier, at = Xfixes.decode_barrier buf ~at in
    let* eventid, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ deviceid; barrier; eventid }, at)

  let encode_barrier_release_pointer_info buf (v : barrier_release_pointer_info)
      =
    encode_device_id buf v.deviceid;
    encode_pad buf 2;
    Xfixes.encode_barrier buf v.barrier;
    encode_int32 buf v.eventid;
    ()

  let encode_xi_barrier_release_pointer
      ~(barriers : barrier_release_pointer_info list) buf =
    (* opcode *)
    encode_uint8 buf 61;
    encode_int32 buf (identity ((* invalid_argument *) List.length barriers));
    (* reserve request length *)
    encode_pad buf 2;
    encode_list encode_barrier_release_pointer_info buf barriers;
    (* write request length *)
    encode_request_length buf

  type device_valuator_event = {
    device_id : int;
    device_state : int;
    num_valuators : int;
    first_valuator : int;
    valuators : int list;
  }
  [@@deriving sexp]

  let decode_device_valuator_event buf ~at :
      (device_valuator_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* device_id, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* device_state, at = decode_uint16 buf ~at in
    let* num_valuators, at = decode_uint8 buf ~at in
    let* first_valuator, at = decode_uint8 buf ~at in
    let* valuators, at =
      let length = 6 in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some
      ({ device_id; device_state; num_valuators; first_valuator; valuators }, at)

  type more_events_mask = [ `More_events ] list [@@deriving sexp]

  let more_events_mask_mask_of_int64 mask : more_events_mask option =
    let of_int = function 7 -> Some `More_events | _ -> None in
    mask_of_int of_int mask

  let more_events_mask_int_of_mask : more_events_mask -> int =
    let to_bit = function `More_events -> 7 in
    int_of_mask to_bit

  type device_key_press_event = {
    detail : char;
    time : Xproto.timestamp;
    root : Xproto.window;
    event : Xproto.window;
    child : Xproto.window_enum alt_enum;
    root_x : int;
    root_y : int;
    event_x : int;
    event_y : int;
    state : Xproto.key_but_mask;
    same_screen : bool;
    device_id : (more_events_mask, int) mask;
  }
  [@@deriving sexp]

  let decode_device_key_press_event buf ~at :
      (device_key_press_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at = decode_char buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* root, at = Xproto.decode_window buf ~at in
    let* event, at = Xproto.decode_window buf ~at in
    let* child, at =
      decode_alt_enum Xproto.decode_window identity Xproto.window_enum_of_int
        buf ~at
    in
    let* root_x, at = decode_int16 buf ~at in
    let* root_y, at = decode_int16 buf ~at in
    let* event_x, at = decode_int16 buf ~at in
    let* event_y, at = decode_int16 buf ~at in
    let* state, at =
      decode_mask decode_uint16 Int64.of_int Xproto.key_but_mask_mask_of_int64
        buf ~at
    in
    let* same_screen, at = decode_bool buf ~at in
    let* device_id, at =
      decode_alt_mask decode_uint8 Int64.of_int more_events_mask_mask_of_int64
        buf ~at
    in
    ignore orig;
    Some
      ( {
          detail;
          time;
          root;
          event;
          child;
          root_x;
          root_y;
          event_x;
          event_y;
          state;
          same_screen;
          device_id;
        },
        at )

  type device_key_release_event = device_key_press_event [@@deriving sexp]
  type device_button_press_event = device_key_press_event [@@deriving sexp]
  type device_button_release_event = device_key_press_event [@@deriving sexp]
  type device_motion_notify_event = device_key_press_event [@@deriving sexp]

  type device_focus_in_event = {
    detail : Xproto.notify_detail_enum;
    time : Xproto.timestamp;
    window : Xproto.window;
    mode : Xproto.notify_mode_enum;
    device_id : int;
  }
  [@@deriving sexp]

  let decode_device_focus_in_event buf ~at :
      (device_focus_in_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at =
      decode_enum decode_char Char.code Xproto.notify_detail_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* window, at = Xproto.decode_window buf ~at in
    let* mode, at =
      decode_enum decode_char Char.code Xproto.notify_mode_enum_of_int buf ~at
    in
    let* device_id, at = decode_uint8 buf ~at in
    let at = at + 18 in
    ignore orig;
    Some ({ detail; time; window; mode; device_id }, at)

  type device_focus_out_event = device_focus_in_event [@@deriving sexp]
  type proximity_in_event = device_key_press_event [@@deriving sexp]
  type proximity_out_event = device_key_press_event [@@deriving sexp]

  type classes_reported_mask =
    [ `Out_of_proximity
    | `Device_mode_absolute
    | `Reporting_valuators
    | `Reporting_buttons
    | `Reporting_keys ]
    list
  [@@deriving sexp]

  let classes_reported_mask_mask_of_int64 mask : classes_reported_mask option =
    let of_int = function
      | 7 -> Some `Out_of_proximity
      | 6 -> Some `Device_mode_absolute
      | 2 -> Some `Reporting_valuators
      | 1 -> Some `Reporting_buttons
      | 0 -> Some `Reporting_keys
      | _ -> None
    in
    mask_of_int of_int mask

  let classes_reported_mask_int_of_mask : classes_reported_mask -> int =
    let to_bit = function
      | `Out_of_proximity -> 7
      | `Device_mode_absolute -> 6
      | `Reporting_valuators -> 2
      | `Reporting_buttons -> 1
      | `Reporting_keys -> 0
    in
    int_of_mask to_bit

  type device_state_notify_event = {
    device_id : (more_events_mask, char) mask;
    time : Xproto.timestamp;
    num_keys : int;
    num_buttons : int;
    num_valuators : int;
    classes_reported : classes_reported_mask;
    buttons : int list;
    keys : int list;
    valuators : int list;
  }
  [@@deriving sexp]

  let decode_device_state_notify_event buf ~at :
      (device_state_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* device_id, at =
      decode_alt_mask decode_char char_to_int64 more_events_mask_mask_of_int64
        buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* num_keys, at = decode_uint8 buf ~at in
    let* num_buttons, at = decode_uint8 buf ~at in
    let* num_valuators, at = decode_uint8 buf ~at in
    let* classes_reported, at =
      decode_mask decode_uint8 Int64.of_int classes_reported_mask_mask_of_int64
        buf ~at
    in
    let* buttons, at =
      let length = 4 in
      decode_list decode_uint8 length buf ~at
    in
    let* keys, at =
      let length = 4 in
      decode_list decode_uint8 length buf ~at
    in
    let* valuators, at =
      let length = 3 in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some
      ( {
          device_id;
          time;
          num_keys;
          num_buttons;
          num_valuators;
          classes_reported;
          buttons;
          keys;
          valuators;
        },
        at )

  type device_mapping_notify_event = {
    device_id : char;
    request : Xproto.mapping_enum;
    first_keycode : key_code;
    count : int;
    time : Xproto.timestamp;
  }
  [@@deriving sexp]

  let decode_device_mapping_notify_event buf ~at :
      (device_mapping_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* device_id, at = decode_char buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* request, at =
      decode_enum decode_uint8 identity Xproto.mapping_enum_of_int buf ~at
    in
    let* first_keycode, at = decode_key_code buf ~at in
    let* count, at = decode_uint8 buf ~at in
    let at = at + 1 in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ device_id; request; first_keycode; count; time }, at)

  type change_device_enum = [ `New_pointer | `New_keyboard ] [@@deriving sexp]

  let change_device_enum_of_int : int -> [> change_device_enum ] option =
    function
    | 0 -> Some `New_pointer
    | 1 -> Some `New_keyboard
    | n ->
        Printf.printf "unknown change_device_enum: %d\n" n;
        None

  let change_device_int_of_enum : change_device_enum -> int = function
    | `New_pointer -> 0
    | `New_keyboard -> 1

  type change_device_notify_event = {
    device_id : char;
    time : Xproto.timestamp;
    request : change_device_enum;
  }
  [@@deriving sexp]

  let decode_change_device_notify_event buf ~at :
      (change_device_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* device_id, at = decode_char buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* request, at =
      decode_enum decode_uint8 identity change_device_enum_of_int buf ~at
    in
    let at = at + 23 in
    ignore orig;
    Some ({ device_id; time; request }, at)

  type device_key_state_notify_event = {
    device_id : (more_events_mask, char) mask;
    keys : int list;
  }
  [@@deriving sexp]

  let decode_device_key_state_notify_event buf ~at :
      (device_key_state_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* device_id, at =
      decode_alt_mask decode_char char_to_int64 more_events_mask_mask_of_int64
        buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* keys, at =
      let length = 28 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some ({ device_id; keys }, at)

  type device_button_state_notify_event = {
    device_id : (more_events_mask, char) mask;
    buttons : int list;
  }
  [@@deriving sexp]

  let decode_device_button_state_notify_event buf ~at :
      (device_button_state_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* device_id, at =
      decode_alt_mask decode_char char_to_int64 more_events_mask_mask_of_int64
        buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* buttons, at =
      let length = 28 in
      decode_list decode_uint8 length buf ~at
    in
    ignore orig;
    Some ({ device_id; buttons }, at)

  type device_change_enum =
    [ `Added
    | `Removed
    | `Enabled
    | `Disabled
    | `Unrecoverable
    | `Control_changed ]
  [@@deriving sexp]

  let device_change_enum_of_int : int -> [> device_change_enum ] option =
    function
    | 0 -> Some `Added
    | 1 -> Some `Removed
    | 2 -> Some `Enabled
    | 3 -> Some `Disabled
    | 4 -> Some `Unrecoverable
    | 5 -> Some `Control_changed
    | n ->
        Printf.printf "unknown device_change_enum: %d\n" n;
        None

  let device_change_int_of_enum : device_change_enum -> int = function
    | `Added -> 0
    | `Removed -> 1
    | `Enabled -> 2
    | `Disabled -> 3
    | `Unrecoverable -> 4
    | `Control_changed -> 5

  type device_presence_notify_event = {
    time : Xproto.timestamp;
    devchange : device_change_enum;
    device_id : char;
    control : int;
  }
  [@@deriving sexp]

  let decode_device_presence_notify_event buf ~at :
      (device_presence_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* devchange, at =
      decode_enum decode_char Char.code device_change_enum_of_int buf ~at
    in
    let* device_id, at = decode_char buf ~at in
    let* control, at = decode_uint16 buf ~at in
    let at = at + 20 in
    ignore orig;
    Some ({ time; devchange; device_id; control }, at)

  type device_property_notify_event = {
    state : Xproto.property_enum;
    time : Xproto.timestamp;
    property : Xproto.atom;
    device_id : int;
  }
  [@@deriving sexp]

  let decode_device_property_notify_event buf ~at :
      (device_property_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* state, at =
      decode_enum decode_char Char.code Xproto.property_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* property, at = Xproto.decode_atom buf ~at in
    let at = at + 19 in
    let* device_id, at = decode_uint8 buf ~at in
    ignore orig;
    Some ({ state; time; property; device_id }, at)

  type change_reason_enum = [ `Slave_switch | `Device_change ] [@@deriving sexp]

  let change_reason_enum_of_int : int -> [> change_reason_enum ] option =
    function
    | 1 -> Some `Slave_switch
    | 2 -> Some `Device_change
    | n ->
        Printf.printf "unknown change_reason_enum: %d\n" n;
        None

  let change_reason_int_of_enum : change_reason_enum -> int = function
    | `Slave_switch -> 1
    | `Device_change -> 2

  type device_changed_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    sourceid : device_enum alt_enum;
    reason : change_reason_enum;
    classes : device_class list;
  }
  [@@deriving sexp]

  let decode_device_changed_event buf ~at : (device_changed_event * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum Xproto.decode_timestamp identity Xproto.time_enum_of_int
        buf ~at
    in
    let* num_classes, at = decode_uint16 buf ~at in
    let num_classes = num_classes in
    let* sourceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* reason, at =
      decode_enum decode_uint8 identity change_reason_enum_of_int buf ~at
    in
    let at = at + 11 in
    let* classes, at = decode_list decode_device_class num_classes buf ~at in
    ignore orig;
    Some ({ deviceid; time; sourceid; reason; classes }, at)

  type key_event_flags_mask = [ `Key_repeat ] list [@@deriving sexp]

  let key_event_flags_mask_of_int64 mask : key_event_flags_mask option =
    let of_int = function 16 -> Some `Key_repeat | _ -> None in
    mask_of_int of_int mask

  let key_event_flags_int_of_mask : key_event_flags_mask -> int =
    let to_bit = function `Key_repeat -> 16 in
    int_of_mask to_bit

  type key_press_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    detail : int;
    root : Xproto.window;
    event : Xproto.window;
    child : Xproto.window;
    root_x : fp1616;
    root_y : fp1616;
    event_x : fp1616;
    event_y : fp1616;
    sourceid : device_enum alt_enum;
    flags : key_event_flags_mask;
    mods : modifier_info;
    group : group_info;
    button_mask : int list;
    valuator_mask : int list;
    axisvalues : fp3232 list;
  }
  [@@deriving sexp]

  type key_release_event = key_press_event [@@deriving sexp]
  type pointer_event_flags_mask = [ `Pointer_emulated ] list [@@deriving sexp]

  let pointer_event_flags_mask_of_int64 mask : pointer_event_flags_mask option =
    let of_int = function 16 -> Some `Pointer_emulated | _ -> None in
    mask_of_int of_int mask

  let pointer_event_flags_int_of_mask : pointer_event_flags_mask -> int =
    let to_bit = function `Pointer_emulated -> 16 in
    int_of_mask to_bit

  type button_press_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    detail : int;
    root : Xproto.window;
    event : Xproto.window;
    child : Xproto.window;
    root_x : fp1616;
    root_y : fp1616;
    event_x : fp1616;
    event_y : fp1616;
    sourceid : device_enum alt_enum;
    flags : pointer_event_flags_mask;
    mods : modifier_info;
    group : group_info;
    button_mask : int list;
    valuator_mask : int list;
    axisvalues : fp3232 list;
  }
  [@@deriving sexp]

  type button_release_event = button_press_event [@@deriving sexp]
  type motion_event = button_press_event [@@deriving sexp]

  type notify_mode_enum =
    [ `Normal
    | `Grab
    | `Ungrab
    | `While_grabbed
    | `Passive_grab
    | `Passive_ungrab ]
  [@@deriving sexp]

  let notify_mode_enum_of_int : int -> [> notify_mode_enum ] option = function
    | 0 -> Some `Normal
    | 1 -> Some `Grab
    | 2 -> Some `Ungrab
    | 3 -> Some `While_grabbed
    | 4 -> Some `Passive_grab
    | 5 -> Some `Passive_ungrab
    | n ->
        Printf.printf "unknown notify_mode_enum: %d\n" n;
        None

  let notify_mode_int_of_enum : notify_mode_enum -> int = function
    | `Normal -> 0
    | `Grab -> 1
    | `Ungrab -> 2
    | `While_grabbed -> 3
    | `Passive_grab -> 4
    | `Passive_ungrab -> 5

  type notify_detail_enum =
    [ `Ancestor
    | `Virtual
    | `Inferior
    | `Nonlinear
    | `Nonlinear_virtual
    | `Pointer
    | `Pointer_root
    | `None ]
  [@@deriving sexp]

  let notify_detail_enum_of_int : int -> [> notify_detail_enum ] option =
    function
    | 0 -> Some `Ancestor
    | 1 -> Some `Virtual
    | 2 -> Some `Inferior
    | 3 -> Some `Nonlinear
    | 4 -> Some `Nonlinear_virtual
    | 5 -> Some `Pointer
    | 6 -> Some `Pointer_root
    | 7 -> Some `None
    | n ->
        Printf.printf "unknown notify_detail_enum: %d\n" n;
        None

  let notify_detail_int_of_enum : notify_detail_enum -> int = function
    | `Ancestor -> 0
    | `Virtual -> 1
    | `Inferior -> 2
    | `Nonlinear -> 3
    | `Nonlinear_virtual -> 4
    | `Pointer -> 5
    | `Pointer_root -> 6
    | `None -> 7

  type enter_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    sourceid : device_enum alt_enum;
    mode : notify_mode_enum;
    detail : notify_detail_enum;
    root : Xproto.window;
    event : Xproto.window;
    child : Xproto.window;
    root_x : fp1616;
    root_y : fp1616;
    event_x : fp1616;
    event_y : fp1616;
    same_screen : bool;
    focus : bool;
    mods : modifier_info;
    group : group_info;
    buttons : int list;
  }
  [@@deriving sexp]

  let decode_enter_event buf ~at : (enter_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum Xproto.decode_timestamp identity Xproto.time_enum_of_int
        buf ~at
    in
    let* sourceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* mode, at =
      decode_enum decode_uint8 identity notify_mode_enum_of_int buf ~at
    in
    let* detail, at =
      decode_enum decode_uint8 identity notify_detail_enum_of_int buf ~at
    in
    let* root, at = Xproto.decode_window buf ~at in
    let* event, at = Xproto.decode_window buf ~at in
    let* child, at = Xproto.decode_window buf ~at in
    let* root_x, at = decode_fp1616 buf ~at in
    let* root_y, at = decode_fp1616 buf ~at in
    let* event_x, at = decode_fp1616 buf ~at in
    let* event_y, at = decode_fp1616 buf ~at in
    let* same_screen, at = decode_bool buf ~at in
    let* focus, at = decode_bool buf ~at in
    let* buttons_len, at = decode_uint16 buf ~at in
    let buttons_len = buttons_len in
    let* mods, at = decode_modifier_info buf ~at in
    let* group, at = decode_group_info buf ~at in
    let* buttons, at = decode_list decode_int32 buttons_len buf ~at in
    ignore orig;
    Some
      ( {
          deviceid;
          time;
          sourceid;
          mode;
          detail;
          root;
          event;
          child;
          root_x;
          root_y;
          event_x;
          event_y;
          same_screen;
          focus;
          mods;
          group;
          buttons;
        },
        at )

  type leave_event = enter_event [@@deriving sexp]
  type focus_in_event = enter_event [@@deriving sexp]
  type focus_out_event = enter_event [@@deriving sexp]

  type hierarchy_mask =
    [ `Master_added
    | `Master_removed
    | `Slave_added
    | `Slave_removed
    | `Slave_attached
    | `Slave_detached
    | `Device_enabled
    | `Device_disabled ]
    list
  [@@deriving sexp]

  let hierarchy_mask_mask_of_int64 mask : hierarchy_mask option =
    let of_int = function
      | 0 -> Some `Master_added
      | 1 -> Some `Master_removed
      | 2 -> Some `Slave_added
      | 3 -> Some `Slave_removed
      | 4 -> Some `Slave_attached
      | 5 -> Some `Slave_detached
      | 6 -> Some `Device_enabled
      | 7 -> Some `Device_disabled
      | _ -> None
    in
    mask_of_int of_int mask

  let hierarchy_mask_int_of_mask : hierarchy_mask -> int =
    let to_bit = function
      | `Master_added -> 0
      | `Master_removed -> 1
      | `Slave_added -> 2
      | `Slave_removed -> 3
      | `Slave_attached -> 4
      | `Slave_detached -> 5
      | `Device_enabled -> 6
      | `Device_disabled -> 7
    in
    int_of_mask to_bit

  type hierarchy_info = {
    deviceid : device_enum alt_enum;
    attachment : device_enum alt_enum;
    type_ : device_type_enum;
    enabled : bool;
    flags : hierarchy_mask;
  }
  [@@deriving sexp]

  let decode_hierarchy_info buf ~at : (hierarchy_info * int) option =
    let orig = at in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* attachment, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* type_, at =
      decode_enum decode_uint8 identity device_type_enum_of_int buf ~at
    in
    let* enabled, at = decode_bool buf ~at in
    let at = at + 2 in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int hierarchy_mask_mask_of_int64 buf ~at
    in
    ignore orig;
    Some ({ deviceid; attachment; type_; enabled; flags }, at)

  let encode_hierarchy_info buf (v : hierarchy_info) =
    encode_alt_enum encode_device_id identity device_int_of_enum buf v.deviceid;
    encode_alt_enum encode_device_id identity device_int_of_enum buf
      v.attachment;
    encode_enum encode_uint8 identity device_type_int_of_enum buf v.type_;
    encode_bool buf v.enabled;
    encode_pad buf 2;
    encode_mask encode_int32 identity hierarchy_mask_int_of_mask buf v.flags;
    ()

  type hierarchy_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    flags : hierarchy_mask;
    infos : hierarchy_info list;
  }
  [@@deriving sexp]

  let decode_hierarchy_event buf ~at : (hierarchy_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum Xproto.decode_timestamp identity Xproto.time_enum_of_int
        buf ~at
    in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int hierarchy_mask_mask_of_int64 buf ~at
    in
    let* num_infos, at = decode_uint16 buf ~at in
    let num_infos = num_infos in
    let at = at + 10 in
    let* infos, at = decode_list decode_hierarchy_info num_infos buf ~at in
    ignore orig;
    Some ({ deviceid; time; flags; infos }, at)

  type property_flag_enum = [ `Deleted | `Created | `Modified ]
  [@@deriving sexp]

  let property_flag_enum_of_int : int -> [> property_flag_enum ] option =
    function
    | 0 -> Some `Deleted
    | 1 -> Some `Created
    | 2 -> Some `Modified
    | n ->
        Printf.printf "unknown property_flag_enum: %d\n" n;
        None

  let property_flag_int_of_enum : property_flag_enum -> int = function
    | `Deleted -> 0
    | `Created -> 1
    | `Modified -> 2

  type property_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    property : Xproto.atom;
    what : property_flag_enum;
  }
  [@@deriving sexp]

  let decode_property_event buf ~at : (property_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum Xproto.decode_timestamp identity Xproto.time_enum_of_int
        buf ~at
    in
    let* property, at = Xproto.decode_atom buf ~at in
    let* what, at =
      decode_enum decode_uint8 identity property_flag_enum_of_int buf ~at
    in
    let at = at + 11 in
    ignore orig;
    Some ({ deviceid; time; property; what }, at)

  type raw_key_press_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    detail : int;
    sourceid : device_id;
    flags : key_event_flags_mask;
    valuator_mask : int list;
    axisvalues : fp3232 list;
    axisvalues_raw : fp3232 list;
  }
  [@@deriving sexp]

  type raw_key_release_event = raw_key_press_event [@@deriving sexp]

  type raw_button_press_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    detail : int;
    sourceid : device_id;
    flags : pointer_event_flags_mask;
    valuator_mask : int list;
    axisvalues : fp3232 list;
    axisvalues_raw : fp3232 list;
  }
  [@@deriving sexp]

  type raw_button_release_event = raw_button_press_event [@@deriving sexp]
  type raw_motion_event = raw_button_press_event [@@deriving sexp]

  type touch_event_flags_mask =
    [ `Touch_pending_end | `Touch_emulating_pointer ] list
  [@@deriving sexp]

  let touch_event_flags_mask_of_int64 mask : touch_event_flags_mask option =
    let of_int = function
      | 16 -> Some `Touch_pending_end
      | 17 -> Some `Touch_emulating_pointer
      | _ -> None
    in
    mask_of_int of_int mask

  let touch_event_flags_int_of_mask : touch_event_flags_mask -> int =
    let to_bit = function
      | `Touch_pending_end -> 16
      | `Touch_emulating_pointer -> 17
    in
    int_of_mask to_bit

  type touch_begin_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    detail : int;
    root : Xproto.window;
    event : Xproto.window;
    child : Xproto.window;
    root_x : fp1616;
    root_y : fp1616;
    event_x : fp1616;
    event_y : fp1616;
    sourceid : device_enum alt_enum;
    flags : touch_event_flags_mask;
    mods : modifier_info;
    group : group_info;
    button_mask : int list;
    valuator_mask : int list;
    axisvalues : fp3232 list;
  }
  [@@deriving sexp]

  type touch_update_event = touch_begin_event [@@deriving sexp]
  type touch_end_event = touch_begin_event [@@deriving sexp]
  type touch_ownership_flags_enum = [ `None ] [@@deriving sexp]

  let touch_ownership_flags_enum_of_int :
      int -> [> touch_ownership_flags_enum ] option = function
    | 0 -> Some `None
    | n ->
        Printf.printf "unknown touch_ownership_flags_enum: %d\n" n;
        None

  let touch_ownership_flags_int_of_enum : touch_ownership_flags_enum -> int =
    function
    | `None -> 0

  type touch_ownership_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    touchid : int;
    root : Xproto.window;
    event : Xproto.window;
    child : Xproto.window;
    sourceid : device_enum alt_enum;
    flags : touch_ownership_flags_enum;
  }
  [@@deriving sexp]

  let decode_touch_ownership_event buf ~at :
      (touch_ownership_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum Xproto.decode_timestamp identity Xproto.time_enum_of_int
        buf ~at
    in
    let* touchid, at = decode_int32 buf ~at in
    let* root, at = Xproto.decode_window buf ~at in
    let* event, at = Xproto.decode_window buf ~at in
    let* child, at = Xproto.decode_window buf ~at in
    let* sourceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let at = at + 2 in
    let* flags, at =
      decode_enum decode_int32 identity touch_ownership_flags_enum_of_int buf
        ~at
    in
    let at = at + 8 in
    ignore orig;
    Some ({ deviceid; time; touchid; root; event; child; sourceid; flags }, at)

  type raw_touch_begin_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    detail : int;
    sourceid : device_id;
    flags : touch_event_flags_mask;
    valuator_mask : int list;
    axisvalues : fp3232 list;
    axisvalues_raw : fp3232 list;
  }
  [@@deriving sexp]

  type raw_touch_update_event = raw_touch_begin_event [@@deriving sexp]
  type raw_touch_end_event = raw_touch_begin_event [@@deriving sexp]

  type barrier_flags_mask = [ `Pointer_released | `Device_is_grabbed ] list
  [@@deriving sexp]

  let barrier_flags_mask_of_int64 mask : barrier_flags_mask option =
    let of_int = function
      | 0 -> Some `Pointer_released
      | 1 -> Some `Device_is_grabbed
      | _ -> None
    in
    mask_of_int of_int mask

  let barrier_flags_int_of_mask : barrier_flags_mask -> int =
    let to_bit = function `Pointer_released -> 0 | `Device_is_grabbed -> 1 in
    int_of_mask to_bit

  type barrier_hit_event = {
    deviceid : device_enum alt_enum;
    time : Xproto.time_enum alt_enum;
    eventid : int;
    root : Xproto.window;
    event : Xproto.window;
    barrier : Xfixes.barrier;
    dtime : int;
    flags : barrier_flags_mask;
    sourceid : device_enum alt_enum;
    root_x : fp1616;
    root_y : fp1616;
    dx : fp3232;
    dy : fp3232;
  }
  [@@deriving sexp]

  let decode_barrier_hit_event buf ~at : (barrier_hit_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* deviceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at =
      decode_alt_enum Xproto.decode_timestamp identity Xproto.time_enum_of_int
        buf ~at
    in
    let* eventid, at = decode_int32 buf ~at in
    let* root, at = Xproto.decode_window buf ~at in
    let* event, at = Xproto.decode_window buf ~at in
    let* barrier, at = Xfixes.decode_barrier buf ~at in
    let* dtime, at = decode_int32 buf ~at in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int barrier_flags_mask_of_int64 buf ~at
    in
    let* sourceid, at =
      decode_alt_enum decode_device_id identity device_enum_of_int buf ~at
    in
    let at = at + 2 in
    let* root_x, at = decode_fp1616 buf ~at in
    let* root_y, at = decode_fp1616 buf ~at in
    let* dx, at = decode_fp3232 buf ~at in
    let* dy, at = decode_fp3232 buf ~at in
    ignore orig;
    Some
      ( {
          deviceid;
          time;
          eventid;
          root;
          event;
          barrier;
          dtime;
          flags;
          sourceid;
          root_x;
          root_y;
          dx;
          dy;
        },
        at )

  type barrier_leave_event = barrier_hit_event [@@deriving sexp]

  type event_for_send =
    | Device_valuator of device_valuator_event
    | Device_key_press of device_key_press_event
    | Device_key_release of device_key_release_event
    | Device_button_press of device_button_press_event
    | Device_button_release of device_button_release_event
    | Device_motion_notify of device_motion_notify_event
    | Device_focus_in of device_focus_in_event
    | Device_focus_out of device_focus_out_event
    | Proximity_in of proximity_in_event
    | Proximity_out of proximity_out_event
    | Device_state_notify of device_state_notify_event
    | Device_mapping_notify of device_mapping_notify_event
    | Change_device_notify of change_device_notify_event
    | Device_key_state_notify of device_key_state_notify_event
    | Device_button_state_notify of device_button_state_notify_event
    | Device_presence_notify of device_presence_notify_event
    | Device_property_notify of device_property_notify_event
  [@@deriving sexp]

  let encode_send_extension_event ~(destination : Xproto.window)
      ~(device_id : int) ~(propagate : bool) ~(events : event_for_send list)
      ~(classes : event_class list) buf =
    (* opcode *)
    encode_uint8 buf 31;
    Xproto.encode_window buf destination;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf device_id;
    encode_bool buf propagate;
    encode_uint16 buf (identity ((* Parsetree.Card32 *) List.length classes));
    encode_uint8 buf (identity ((* invalid_argument *) List.length events));
    encode_pad buf 3;
    encode_list encode_event_for_send buf events;
    encode_list encode_event_class buf classes;
    (* write request length *)
    encode_request_length buf

  type device_error = unit [@@deriving sexp]
  type event_error = unit [@@deriving sexp]
  type mode_error = unit [@@deriving sexp]
  type device_busy_error = unit [@@deriving sexp]
  type class_error = unit [@@deriving sexp]
end

module Xprint = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type string8 = char [@@deriving sexp]

  let decode_string8 = decode_char
  let encode_string8 = encode_char

  type printer = { name : string; description : string } [@@deriving sexp]

  let decode_printer buf ~at : (printer * int) option =
    let orig = at in
    let* name_len, at = decode_int32 buf ~at in
    let name_len = name_len in
    let* name, at = decode_string name_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* desc_len, at = decode_int32 buf ~at in
    let desc_len = desc_len in
    let* description, at = decode_string desc_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ name; description }, at)

  let encode_printer buf (v : printer) =
    encode_int32 buf (identity (String.length v.name));
    encode_string buf v.name;
    encode_align buf 4;
    encode_int32 buf (identity (String.length v.description));
    encode_string buf v.description;
    encode_align buf 4;
    ()

  type pcontext = xid [@@deriving sexp]

  let decode_pcontext = decode_xid
  let encode_pcontext = encode_xid

  type get_doc_enum = [ `Finished | `Second_consumer ] [@@deriving sexp]

  let get_doc_enum_of_int : int -> [> get_doc_enum ] option = function
    | 0 -> Some `Finished
    | 1 -> Some `Second_consumer
    | n ->
        Printf.printf "unknown get_doc_enum: %d\n" n;
        None

  let get_doc_int_of_enum : get_doc_enum -> int = function
    | `Finished -> 0
    | `Second_consumer -> 1

  type ev_mask = [ `Print_mask | `Attribute_mask ] list option [@@deriving sexp]

  let ev_mask_mask_of_int64 mask : ev_mask option =
    let of_mask = function
      | 0 -> Some `Print_mask
      | 1 -> Some `Attribute_mask
      | _ -> None
    in
    if mask = 0L then Some None
    else mask_of_int of_mask mask |> Option.map (fun m -> Some m)

  let ev_mask_int_of_mask (mask : ev_mask) : int =
    let to_mask = function `Print_mask -> 0 | `Attribute_mask -> 1 in
    match mask with None -> 0 | Some mask -> int_of_mask to_mask mask

  type detail_enum =
    [ `Start_job_notify
    | `End_job_notify
    | `Start_doc_notify
    | `End_doc_notify
    | `Start_page_notify
    | `End_page_notify ]
  [@@deriving sexp]

  let detail_enum_of_int : int -> [> detail_enum ] option = function
    | 1 -> Some `Start_job_notify
    | 2 -> Some `End_job_notify
    | 3 -> Some `Start_doc_notify
    | 4 -> Some `End_doc_notify
    | 5 -> Some `Start_page_notify
    | 6 -> Some `End_page_notify
    | n ->
        Printf.printf "unknown detail_enum: %d\n" n;
        None

  let detail_int_of_enum : detail_enum -> int = function
    | `Start_job_notify -> 1
    | `End_job_notify -> 2
    | `Start_doc_notify -> 3
    | `End_doc_notify -> 4
    | `Start_page_notify -> 5
    | `End_page_notify -> 6

  type attr_enum =
    [ `Job_attr
    | `Doc_attr
    | `Page_attr
    | `Printer_attr
    | `Server_attr
    | `Medium_attr
    | `Spooler_attr ]
  [@@deriving sexp]

  let attr_enum_of_int : int -> [> attr_enum ] option = function
    | 1 -> Some `Job_attr
    | 2 -> Some `Doc_attr
    | 3 -> Some `Page_attr
    | 4 -> Some `Printer_attr
    | 5 -> Some `Server_attr
    | 6 -> Some `Medium_attr
    | 7 -> Some `Spooler_attr
    | n ->
        Printf.printf "unknown attr_enum: %d\n" n;
        None

  let attr_int_of_enum : attr_enum -> int = function
    | `Job_attr -> 1
    | `Doc_attr -> 2
    | `Page_attr -> 3
    | `Printer_attr -> 4
    | `Server_attr -> 5
    | `Medium_attr -> 6
    | `Spooler_attr -> 7

  type print_query_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_print_query_version buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_print_query_version_reply length buf ~at :
      (print_query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major_version, at = decode_uint16 buf ~at in
    let* minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type print_get_printer_list_reply = printer list [@@deriving sexp]

  let encode_print_get_printer_list ~(printer_name : string) ~(locale : string)
      buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_int32 buf (identity (String.length printer_name));
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity (String.length locale));
    encode_string buf printer_name;
    encode_string buf locale;
    (* write request length *)
    encode_request_length buf

  let decode_print_get_printer_list_reply length buf ~at :
      (print_get_printer_list_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* list_count, at = decode_int32 buf ~at in
    let list_count = list_count in
    let at = at + 20 in
    let* printers, at = decode_list decode_printer list_count buf ~at in
    ignore orig;
    Some (printers, at)

  let encode_print_rehash_printer_list buf =
    (* opcode *)
    encode_uint8 buf 20;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_create_context ~(context_id : int) ~(printer_name : string)
      ~(locale : string) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_int32 buf context_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity (String.length printer_name));
    encode_int32 buf (identity (String.length locale));
    encode_string buf printer_name;
    encode_string buf locale;
    (* write request length *)
    encode_request_length buf

  let encode_print_set_context ~(context : int) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_int32 buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type print_get_context_reply = int [@@deriving sexp]

  let encode_print_get_context buf =
    (* opcode *)
    encode_uint8 buf 4;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_print_get_context_reply length buf ~at :
      (print_get_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context, at = decode_int32 buf ~at in
    ignore orig;
    Some (context, at)

  let encode_print_destroy_context ~(context : int) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_int32 buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type print_get_screen_of_context_reply = Xproto.window [@@deriving sexp]

  let encode_print_get_screen_of_context buf =
    (* opcode *)
    encode_uint8 buf 6;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_print_get_screen_of_context_reply length buf ~at :
      (print_get_screen_of_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* root, at = Xproto.decode_window buf ~at in
    ignore orig;
    Some (root, at)

  let encode_print_start_job ~(output_mode : int) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_uint8 buf output_mode;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_print_end_job ~(cancel : bool) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_bool buf cancel;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_print_start_doc ~(driver_mode : int) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_uint8 buf driver_mode;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_print_end_doc ~(cancel : bool) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_bool buf cancel;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_print_put_document_data ~(drawable : Xproto.drawable)
      ~(data : char list) ~(doc_format : string) ~(options : string) buf =
    (* opcode *)
    encode_uint8 buf 11;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity ((* Parsetree.Byte *) List.length data));
    encode_uint16 buf (identity (String.length doc_format));
    encode_uint16 buf (identity (String.length options));
    encode_list encode_char buf data;
    encode_string buf doc_format;
    encode_string buf options;
    (* write request length *)
    encode_request_length buf

  type print_get_document_data_reply = {
    status_code : int;
    finished_flag : int;
    data : char list;
  }
  [@@deriving sexp]

  let encode_print_get_document_data ~(context : pcontext) ~(max_bytes : int)
      buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf max_bytes;
    (* write request length *)
    encode_request_length buf

  let decode_print_get_document_data_reply length buf ~at :
      (print_get_document_data_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* status_code, at = decode_int32 buf ~at in
    let* finished_flag, at = decode_int32 buf ~at in
    let* data_len, at = decode_int32 buf ~at in
    let data_len = data_len in
    let at = at + 12 in
    let* data, at = decode_list decode_char data_len buf ~at in
    ignore orig;
    Some ({ status_code; finished_flag; data }, at)

  let encode_print_start_page ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 13;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let encode_print_end_page ~(cancel : bool) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_bool buf cancel;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_print_select_input ~(context : pcontext) ~(event_mask : int) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf event_mask;
    (* write request length *)
    encode_request_length buf

  type print_input_selected_reply = { event_mask : int; all_events_mask : int }
  [@@deriving sexp]

  let encode_print_input_selected ~(context : pcontext) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_print_input_selected_reply length buf ~at :
      (print_input_selected_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* event_mask, at = decode_int32 buf ~at in
    let* all_events_mask, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ event_mask; all_events_mask }, at)

  type print_get_attributes_reply = string [@@deriving sexp]

  let encode_print_get_attributes ~(context : pcontext) ~(pool : int) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf pool;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_print_get_attributes_reply length buf ~at :
      (print_get_attributes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* string_len, at = decode_int32 buf ~at in
    let string_len = string_len in
    let at = at + 20 in
    let* attributes, at = decode_string string_len buf ~at in
    ignore orig;
    Some (attributes, at)

  type print_get_one_attributes_reply = string [@@deriving sexp]

  let encode_print_get_one_attributes ~(context : pcontext) ~(pool : int)
      ~(name : string) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity (String.length name));
    encode_uint8 buf pool;
    encode_pad buf 3;
    encode_string buf name;
    (* write request length *)
    encode_request_length buf

  let decode_print_get_one_attributes_reply length buf ~at :
      (print_get_one_attributes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* value_len, at = decode_int32 buf ~at in
    let value_len = value_len in
    let at = at + 20 in
    let* value, at = decode_string value_len buf ~at in
    ignore orig;
    Some (value, at)

  let encode_print_set_attributes ~(context : pcontext) ~(string_len : int)
      ~(pool : int) ~(rule : int) ~(attributes : string) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf string_len;
    encode_uint8 buf pool;
    encode_uint8 buf rule;
    encode_pad buf 2;
    encode_string buf attributes;
    (* write request length *)
    encode_request_length buf

  type print_get_page_dimensions_reply = {
    width : int;
    height : int;
    offset_x : int;
    offset_y : int;
    reproducible_width : int;
    reproducible_height : int;
  }
  [@@deriving sexp]

  let encode_print_get_page_dimensions ~(context : pcontext) buf =
    (* opcode *)
    encode_uint8 buf 21;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_print_get_page_dimensions_reply length buf ~at :
      (print_get_page_dimensions_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* offset_x, at = decode_uint16 buf ~at in
    let* offset_y, at = decode_uint16 buf ~at in
    let* reproducible_width, at = decode_uint16 buf ~at in
    let* reproducible_height, at = decode_uint16 buf ~at in
    ignore orig;
    Some
      ( {
          width;
          height;
          offset_x;
          offset_y;
          reproducible_width;
          reproducible_height;
        },
        at )

  type print_query_screens_reply = Xproto.window list [@@deriving sexp]

  let encode_print_query_screens buf =
    (* opcode *)
    encode_uint8 buf 22;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_print_query_screens_reply length buf ~at :
      (print_query_screens_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* list_count, at = decode_int32 buf ~at in
    let list_count = list_count in
    let at = at + 20 in
    let* roots, at = decode_list Xproto.decode_window list_count buf ~at in
    ignore orig;
    Some (roots, at)

  type print_set_image_resolution_reply = {
    status : bool;
    previous_resolutions : int;
  }
  [@@deriving sexp]

  let encode_print_set_image_resolution ~(context : pcontext)
      ~(image_resolution : int) buf =
    (* opcode *)
    encode_uint8 buf 23;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf image_resolution;
    (* write request length *)
    encode_request_length buf

  let decode_print_set_image_resolution_reply length buf ~at :
      (print_set_image_resolution_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* status, at = decode_bool buf ~at in
    let at = at + 6 in
    let* previous_resolutions, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ status; previous_resolutions }, at)

  type print_get_image_resolution_reply = int [@@deriving sexp]

  let encode_print_get_image_resolution ~(context : pcontext) buf =
    (* opcode *)
    encode_uint8 buf 24;
    encode_pcontext buf context;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_print_get_image_resolution_reply length buf ~at :
      (print_get_image_resolution_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* image_resolution, at = decode_uint16 buf ~at in
    ignore orig;
    Some (image_resolution, at)

  type notify_event = { detail : int; context : pcontext; cancel : bool }
  [@@deriving sexp]

  let decode_notify_event buf ~at : (notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* context, at = decode_pcontext buf ~at in
    let* cancel, at = decode_bool buf ~at in
    ignore orig;
    Some ({ detail; context; cancel }, at)

  type attribut_notify_event = { detail : int; context : pcontext }
  [@@deriving sexp]

  let decode_attribut_notify_event buf ~at :
      (attribut_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* detail, at = decode_uint8 buf ~at in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* context, at = decode_pcontext buf ~at in
    ignore orig;
    Some ({ detail; context }, at)

  type bad_context_error = unit [@@deriving sexp]
  type bad_sequence_error = unit [@@deriving sexp]
end

module Xselinux = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type query_version_reply = { server_major : int; server_minor : int }
  [@@deriving sexp]

  let encode_query_version ~(client_major : int) ~(client_minor : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint8 buf client_major;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint8 buf client_minor;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* server_major, at = decode_uint16 buf ~at in
    let* server_minor, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ server_major; server_minor }, at)

  let encode_set_device_create_context ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 1;
    encode_int32 buf (identity (String.length context));
    (* reserve request length *)
    encode_pad buf 2;
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_device_create_context_reply = string [@@deriving sexp]

  let encode_get_device_create_context buf =
    (* opcode *)
    encode_uint8 buf 2;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_device_create_context_reply length buf ~at :
      (get_device_create_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  let encode_set_device_context ~(device : int) ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_int32 buf device;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf (identity (String.length context));
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_device_context_reply = string [@@deriving sexp]

  let encode_get_device_context ~(device : int) buf =
    (* opcode *)
    encode_uint8 buf 4;
    encode_int32 buf device;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_device_context_reply length buf ~at :
      (get_device_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  let encode_set_window_create_context ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_int32 buf (identity (String.length context));
    (* reserve request length *)
    encode_pad buf 2;
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_window_create_context_reply = string [@@deriving sexp]

  let encode_get_window_create_context buf =
    (* opcode *)
    encode_uint8 buf 6;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_window_create_context_reply length buf ~at :
      (get_window_create_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type get_window_context_reply = string [@@deriving sexp]

  let encode_get_window_context ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 7;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_window_context_reply length buf ~at :
      (get_window_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type list_item = {
    name : Xproto.atom;
    object_context : string;
    data_context : string;
  }
  [@@deriving sexp]

  let decode_list_item buf ~at : (list_item * int) option =
    let orig = at in
    let* name, at = Xproto.decode_atom buf ~at in
    let* object_context_len, at = decode_int32 buf ~at in
    let object_context_len = object_context_len in
    let* data_context_len, at = decode_int32 buf ~at in
    let data_context_len = data_context_len in
    let* object_context, at = decode_string object_context_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* data_context, at = decode_string data_context_len buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ name; object_context; data_context }, at)

  let encode_list_item buf (v : list_item) =
    Xproto.encode_atom buf v.name;
    encode_int32 buf (identity (String.length v.object_context));
    encode_int32 buf (identity (String.length v.data_context));
    encode_string buf v.object_context;
    encode_align buf 4;
    encode_string buf v.data_context;
    encode_align buf 4;
    ()

  let encode_set_property_create_context ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_int32 buf (identity (String.length context));
    (* reserve request length *)
    encode_pad buf 2;
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_property_create_context_reply = string [@@deriving sexp]

  let encode_get_property_create_context buf =
    (* opcode *)
    encode_uint8 buf 9;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_property_create_context_reply length buf ~at :
      (get_property_create_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  let encode_set_property_use_context ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 10;
    encode_int32 buf (identity (String.length context));
    (* reserve request length *)
    encode_pad buf 2;
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_property_use_context_reply = string [@@deriving sexp]

  let encode_get_property_use_context buf =
    (* opcode *)
    encode_uint8 buf 11;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_property_use_context_reply length buf ~at :
      (get_property_use_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type get_property_context_reply = string [@@deriving sexp]

  let encode_get_property_context ~(window : Xproto.window)
      ~(property : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 12;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  let decode_get_property_context_reply length buf ~at :
      (get_property_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type get_property_data_context_reply = string [@@deriving sexp]

  let encode_get_property_data_context ~(window : Xproto.window)
      ~(property : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 13;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf property;
    (* write request length *)
    encode_request_length buf

  let decode_get_property_data_context_reply length buf ~at :
      (get_property_data_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type list_properties_reply = list_item list [@@deriving sexp]

  let encode_list_properties ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 14;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_list_properties_reply length buf ~at :
      (list_properties_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* properties_len, at = decode_int32 buf ~at in
    let properties_len = properties_len in
    let at = at + 20 in
    let* properties, at = decode_list decode_list_item properties_len buf ~at in
    ignore orig;
    Some (properties, at)

  let encode_set_selection_create_context ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_int32 buf (identity (String.length context));
    (* reserve request length *)
    encode_pad buf 2;
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_selection_create_context_reply = string [@@deriving sexp]

  let encode_get_selection_create_context buf =
    (* opcode *)
    encode_uint8 buf 16;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_selection_create_context_reply length buf ~at :
      (get_selection_create_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  let encode_set_selection_use_context ~(context : string) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_int32 buf (identity (String.length context));
    (* reserve request length *)
    encode_pad buf 2;
    encode_string buf context;
    (* write request length *)
    encode_request_length buf

  type get_selection_use_context_reply = string [@@deriving sexp]

  let encode_get_selection_use_context buf =
    (* opcode *)
    encode_uint8 buf 18;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_get_selection_use_context_reply length buf ~at :
      (get_selection_use_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type get_selection_context_reply = string [@@deriving sexp]

  let encode_get_selection_context ~(selection : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 19;
    Xproto.encode_atom buf selection;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_selection_context_reply length buf ~at :
      (get_selection_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type get_selection_data_context_reply = string [@@deriving sexp]

  let encode_get_selection_data_context ~(selection : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 20;
    Xproto.encode_atom buf selection;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_selection_data_context_reply length buf ~at :
      (get_selection_data_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)

  type list_selections_reply = list_item list [@@deriving sexp]

  let encode_list_selections buf =
    (* opcode *)
    encode_uint8 buf 21;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_list_selections_reply length buf ~at :
      (list_selections_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* selections_len, at = decode_int32 buf ~at in
    let selections_len = selections_len in
    let at = at + 20 in
    let* selections, at = decode_list decode_list_item selections_len buf ~at in
    ignore orig;
    Some (selections, at)

  type get_client_context_reply = string [@@deriving sexp]

  let encode_get_client_context ~(resource : int) buf =
    (* opcode *)
    encode_uint8 buf 22;
    encode_int32 buf resource;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_get_client_context_reply length buf ~at :
      (get_client_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* context_len, at = decode_int32 buf ~at in
    let context_len = context_len in
    let at = at + 20 in
    let* context, at = decode_string context_len buf ~at in
    ignore orig;
    Some (context, at)
end

module Xtest = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type get_version_reply = { major_version : int; minor_version : int }
  [@@deriving sexp]

  let encode_get_version ~(major_version : int) ~(minor_version : int) buf =
    (* opcode *)
    encode_uint8 buf 0;
    encode_uint8 buf major_version;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 1;
    encode_uint16 buf minor_version;
    (* write request length *)
    encode_request_length buf

  let decode_get_version_reply length buf ~at : (get_version_reply * int) option
      =
    let orig = at in
    let at = at + 1 in
    let* major_version, at = decode_uint8 buf ~at in
    let at = at + 6 in
    let* minor_version, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major_version; minor_version }, at)

  type cursor_enum = [ `None | `Current ] [@@deriving sexp]

  let cursor_enum_of_int : int -> [> cursor_enum ] option = function
    | 0 -> Some `None
    | 1 -> Some `Current
    | n ->
        Printf.printf "unknown cursor_enum: %d\n" n;
        None

  let cursor_int_of_enum : cursor_enum -> int = function
    | `None -> 0
    | `Current -> 1

  type compare_cursor_reply = bool [@@deriving sexp]

  let encode_compare_cursor ~(window : Xproto.window) ~(cursor : Xproto.cursor)
      buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_cursor buf cursor;
    (* write request length *)
    encode_request_length buf

  let decode_compare_cursor_reply length buf ~at :
      (compare_cursor_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* same, at = decode_bool buf ~at in
    let at = at + 6 in
    ignore orig;
    Some (same, at)

  let encode_fake_input ~(type_ : char) ~(detail : char) ~(time : int)
      ~(root : Xproto.window) ~(root_x : int) ~(root_y : int) ~(deviceid : int)
      buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_char buf type_;
    (* reserve request length *)
    encode_pad buf 2;
    encode_char buf detail;
    encode_pad buf 2;
    encode_int32 buf time;
    Xproto.encode_window buf root;
    encode_pad buf 8;
    encode_int16 buf root_x;
    encode_int16 buf root_y;
    encode_pad buf 7;
    encode_uint8 buf deviceid;
    (* write request length *)
    encode_request_length buf

  let encode_grab_control ~(impervious : bool) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_bool buf impervious;
    (* reserve request length *)
    encode_pad buf 2;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf
end

module Xv = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type port = xid [@@deriving sexp]

  let decode_port = decode_xid
  let encode_port = encode_xid

  type encoding = xid [@@deriving sexp]

  let decode_encoding = decode_xid
  let encode_encoding = encode_xid

  type type_mask =
    [ `Input_mask | `Output_mask | `Video_mask | `Still_mask | `Image_mask ]
    list
  [@@deriving sexp]

  let type_mask_of_int64 mask : type_mask option =
    let of_int = function
      | 0 -> Some `Input_mask
      | 1 -> Some `Output_mask
      | 2 -> Some `Video_mask
      | 3 -> Some `Still_mask
      | 4 -> Some `Image_mask
      | _ -> None
    in
    mask_of_int of_int mask

  let type_int_of_mask : type_mask -> int =
    let to_bit = function
      | `Input_mask -> 0
      | `Output_mask -> 1
      | `Video_mask -> 2
      | `Still_mask -> 3
      | `Image_mask -> 4
    in
    int_of_mask to_bit

  type image_format_info_type_enum = [ `Rgb | `Yuv ] [@@deriving sexp]

  let image_format_info_type_enum_of_int :
      int -> [> image_format_info_type_enum ] option = function
    | 0 -> Some `Rgb
    | 1 -> Some `Yuv
    | n ->
        Printf.printf "unknown image_format_info_type_enum: %d\n" n;
        None

  let image_format_info_type_int_of_enum : image_format_info_type_enum -> int =
    function
    | `Rgb -> 0
    | `Yuv -> 1

  type image_format_info_format_enum = [ `Packed | `Planar ] [@@deriving sexp]

  let image_format_info_format_enum_of_int :
      int -> [> image_format_info_format_enum ] option = function
    | 0 -> Some `Packed
    | 1 -> Some `Planar
    | n ->
        Printf.printf "unknown image_format_info_format_enum: %d\n" n;
        None

  let image_format_info_format_int_of_enum :
      image_format_info_format_enum -> int = function
    | `Packed -> 0
    | `Planar -> 1

  type attribute_flag_mask = [ `Gettable | `Settable ] list [@@deriving sexp]

  let attribute_flag_mask_of_int64 mask : attribute_flag_mask option =
    let of_int = function
      | 0 -> Some `Gettable
      | 1 -> Some `Settable
      | _ -> None
    in
    mask_of_int of_int mask

  let attribute_flag_int_of_mask : attribute_flag_mask -> int =
    let to_bit = function `Gettable -> 0 | `Settable -> 1 in
    int_of_mask to_bit

  type video_notify_reason_enum =
    [ `Started | `Stopped | `Busy | `Preempted | `Hard_error ]
  [@@deriving sexp]

  let video_notify_reason_enum_of_int :
      int -> [> video_notify_reason_enum ] option = function
    | 0 -> Some `Started
    | 1 -> Some `Stopped
    | 2 -> Some `Busy
    | 3 -> Some `Preempted
    | 4 -> Some `Hard_error
    | n ->
        Printf.printf "unknown video_notify_reason_enum: %d\n" n;
        None

  let video_notify_reason_int_of_enum : video_notify_reason_enum -> int =
    function
    | `Started -> 0
    | `Stopped -> 1
    | `Busy -> 2
    | `Preempted -> 3
    | `Hard_error -> 4

  type scanline_order_enum = [ `Top_to_bottom | `Bottom_to_top ]
  [@@deriving sexp]

  let scanline_order_enum_of_int : int -> [> scanline_order_enum ] option =
    function
    | 0 -> Some `Top_to_bottom
    | 1 -> Some `Bottom_to_top
    | n ->
        Printf.printf "unknown scanline_order_enum: %d\n" n;
        None

  let scanline_order_int_of_enum : scanline_order_enum -> int = function
    | `Top_to_bottom -> 0
    | `Bottom_to_top -> 1

  type grab_port_status_enum =
    [ `Success
    | `Bad_extension
    | `Already_grabbed
    | `Invalid_time
    | `Bad_reply
    | `Bad_alloc ]
  [@@deriving sexp]

  let grab_port_status_enum_of_int : int -> [> grab_port_status_enum ] option =
    function
    | 0 -> Some `Success
    | 1 -> Some `Bad_extension
    | 2 -> Some `Already_grabbed
    | 3 -> Some `Invalid_time
    | 4 -> Some `Bad_reply
    | 5 -> Some `Bad_alloc
    | n ->
        Printf.printf "unknown grab_port_status_enum: %d\n" n;
        None

  let grab_port_status_int_of_enum : grab_port_status_enum -> int = function
    | `Success -> 0
    | `Bad_extension -> 1
    | `Already_grabbed -> 2
    | `Invalid_time -> 3
    | `Bad_reply -> 4
    | `Bad_alloc -> 5

  type rational = { numerator : int; denominator : int } [@@deriving sexp]

  let decode_rational buf ~at : (rational * int) option =
    let orig = at in
    let* numerator, at = decode_int32 buf ~at in
    let* denominator, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ numerator; denominator }, at)

  let encode_rational buf (v : rational) =
    encode_int32 buf v.numerator;
    encode_int32 buf v.denominator;
    ()

  type format = { visual : Xproto.visualid; depth : int } [@@deriving sexp]

  let decode_format buf ~at : (format * int) option =
    let orig = at in
    let* visual, at = Xproto.decode_visualid buf ~at in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 3 in
    ignore orig;
    Some ({ visual; depth }, at)

  let encode_format buf (v : format) =
    Xproto.encode_visualid buf v.visual;
    encode_uint8 buf v.depth;
    encode_pad buf 3;
    ()

  type adaptor_info = {
    base_id : port;
    num_ports : int;
    type_ : type_mask;
    name : string;
    formats : format list;
  }
  [@@deriving sexp]

  let decode_adaptor_info buf ~at : (adaptor_info * int) option =
    let orig = at in
    let* base_id, at = decode_port buf ~at in
    let* name_size, at = decode_uint16 buf ~at in
    let name_size = name_size in
    let* num_ports, at = decode_uint16 buf ~at in
    let* num_formats, at = decode_uint16 buf ~at in
    let num_formats = num_formats in
    let* type_, at =
      decode_mask decode_uint8 Int64.of_int type_mask_of_int64 buf ~at
    in
    let at = at + 1 in
    let* name, at = decode_string name_size buf ~at in
    let at = at + ((at - orig) mod 4) in
    let* formats, at = decode_list decode_format num_formats buf ~at in
    ignore orig;
    Some ({ base_id; num_ports; type_; name; formats }, at)

  let encode_adaptor_info buf (v : adaptor_info) =
    encode_port buf v.base_id;
    encode_uint16 buf (identity (String.length v.name));
    encode_uint16 buf v.num_ports;
    encode_uint16 buf (identity ((* invalid_argument *) List.length v.formats));
    encode_mask encode_uint8 identity type_int_of_mask buf v.type_;
    encode_pad buf 1;
    encode_string buf v.name;
    encode_align buf 4;
    encode_list encode_format buf v.formats;
    ()

  type encoding_info = {
    encoding : encoding;
    width : int;
    height : int;
    rate : rational;
    name : string;
  }
  [@@deriving sexp]

  let decode_encoding_info buf ~at : (encoding_info * int) option =
    let orig = at in
    let* encoding, at = decode_encoding buf ~at in
    let* name_size, at = decode_uint16 buf ~at in
    let name_size = name_size in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let at = at + 2 in
    let* rate, at = decode_rational buf ~at in
    let* name, at = decode_string name_size buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ encoding; width; height; rate; name }, at)

  let encode_encoding_info buf (v : encoding_info) =
    encode_encoding buf v.encoding;
    encode_uint16 buf (identity (String.length v.name));
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_pad buf 2;
    encode_rational buf v.rate;
    encode_string buf v.name;
    encode_align buf 4;
    ()

  type image = {
    id : int;
    width : int;
    height : int;
    pitches : int list;
    offsets : int list;
    data : int list;
  }
  [@@deriving sexp]

  let decode_image buf ~at : (image * int) option =
    let orig = at in
    let* id, at = decode_int32 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let* data_size, at = decode_int32 buf ~at in
    let data_size = data_size in
    let* num_planes, at = decode_int32 buf ~at in
    let num_planes = num_planes in
    let* pitches, at = decode_list decode_int32 num_planes buf ~at in
    let* offsets, at = decode_list decode_int32 num_planes buf ~at in
    let* data, at = decode_list decode_uint8 data_size buf ~at in
    ignore orig;
    Some ({ id; width; height; pitches; offsets; data }, at)

  let encode_image buf (v : image) =
    encode_int32 buf v.id;
    encode_uint16 buf v.width;
    encode_uint16 buf v.height;
    encode_int32 buf (identity ((* Parsetree.Card8 *) List.length v.data));
    encode_int32 buf (identity ((* Parsetree.Card32 *) List.length v.pitches));
    encode_list encode_int32 buf v.pitches;
    encode_list encode_int32 buf v.offsets;
    encode_list encode_uint8 buf v.data;
    ()

  type attribute_info = {
    flags : attribute_flag_mask;
    min : int;
    max : int;
    name : string;
  }
  [@@deriving sexp]

  let decode_attribute_info buf ~at : (attribute_info * int) option =
    let orig = at in
    let* flags, at =
      decode_mask decode_int32 Int64.of_int attribute_flag_mask_of_int64 buf ~at
    in
    let* min, at = decode_int32 buf ~at in
    let* max, at = decode_int32 buf ~at in
    let* size, at = decode_int32 buf ~at in
    let size = size in
    let* name, at = decode_string size buf ~at in
    let at = at + ((at - orig) mod 4) in
    ignore orig;
    Some ({ flags; min; max; name }, at)

  let encode_attribute_info buf (v : attribute_info) =
    encode_mask encode_int32 identity attribute_flag_int_of_mask buf v.flags;
    encode_int32 buf v.min;
    encode_int32 buf v.max;
    encode_int32 buf (identity (String.length v.name));
    encode_string buf v.name;
    encode_align buf 4;
    ()

  type image_format_info = {
    id : int;
    type_ : image_format_info_type_enum;
    byte_order : Xproto.image_order_enum;
    guid : int list;
    bpp : int;
    num_planes : int;
    depth : int;
    red_mask : int;
    green_mask : int;
    blue_mask : int;
    format : image_format_info_format_enum;
    y_sample_bits : int;
    u_sample_bits : int;
    v_sample_bits : int;
    vhorz_y_period : int;
    vhorz_u_period : int;
    vhorz_v_period : int;
    vvert_y_period : int;
    vvert_u_period : int;
    vvert_v_period : int;
    vcomp_order : int list;
    vscanline_order : scanline_order_enum;
  }
  [@@deriving sexp]

  let decode_image_format_info buf ~at : (image_format_info * int) option =
    let orig = at in
    let* id, at = decode_int32 buf ~at in
    let* type_, at =
      decode_enum decode_uint8 identity image_format_info_type_enum_of_int buf
        ~at
    in
    let* byte_order, at =
      decode_enum decode_uint8 identity Xproto.image_order_enum_of_int buf ~at
    in
    let at = at + 2 in
    let* guid, at =
      let length = 16 in
      decode_list decode_uint8 length buf ~at
    in
    let* bpp, at = decode_uint8 buf ~at in
    let* num_planes, at = decode_uint8 buf ~at in
    let at = at + 2 in
    let* depth, at = decode_uint8 buf ~at in
    let at = at + 3 in
    let* red_mask, at = decode_int32 buf ~at in
    let* green_mask, at = decode_int32 buf ~at in
    let* blue_mask, at = decode_int32 buf ~at in
    let* format, at =
      decode_enum decode_uint8 identity image_format_info_format_enum_of_int buf
        ~at
    in
    let at = at + 3 in
    let* y_sample_bits, at = decode_int32 buf ~at in
    let* u_sample_bits, at = decode_int32 buf ~at in
    let* v_sample_bits, at = decode_int32 buf ~at in
    let* vhorz_y_period, at = decode_int32 buf ~at in
    let* vhorz_u_period, at = decode_int32 buf ~at in
    let* vhorz_v_period, at = decode_int32 buf ~at in
    let* vvert_y_period, at = decode_int32 buf ~at in
    let* vvert_u_period, at = decode_int32 buf ~at in
    let* vvert_v_period, at = decode_int32 buf ~at in
    let* vcomp_order, at =
      let length = 32 in
      decode_list decode_uint8 length buf ~at
    in
    let* vscanline_order, at =
      decode_enum decode_uint8 identity scanline_order_enum_of_int buf ~at
    in
    let at = at + 11 in
    ignore orig;
    Some
      ( {
          id;
          type_;
          byte_order;
          guid;
          bpp;
          num_planes;
          depth;
          red_mask;
          green_mask;
          blue_mask;
          format;
          y_sample_bits;
          u_sample_bits;
          v_sample_bits;
          vhorz_y_period;
          vhorz_u_period;
          vhorz_v_period;
          vvert_y_period;
          vvert_u_period;
          vvert_v_period;
          vcomp_order;
          vscanline_order;
        },
        at )

  let encode_image_format_info buf (v : image_format_info) =
    encode_int32 buf v.id;
    encode_enum encode_uint8 identity image_format_info_type_int_of_enum buf
      v.type_;
    encode_enum encode_uint8 identity Xproto.image_order_int_of_enum buf
      v.byte_order;
    encode_pad buf 2;
    encode_list encode_uint8 buf v.guid;
    encode_uint8 buf v.bpp;
    encode_uint8 buf v.num_planes;
    encode_pad buf 2;
    encode_uint8 buf v.depth;
    encode_pad buf 3;
    encode_int32 buf v.red_mask;
    encode_int32 buf v.green_mask;
    encode_int32 buf v.blue_mask;
    encode_enum encode_uint8 identity image_format_info_format_int_of_enum buf
      v.format;
    encode_pad buf 3;
    encode_int32 buf v.y_sample_bits;
    encode_int32 buf v.u_sample_bits;
    encode_int32 buf v.v_sample_bits;
    encode_int32 buf v.vhorz_y_period;
    encode_int32 buf v.vhorz_u_period;
    encode_int32 buf v.vhorz_v_period;
    encode_int32 buf v.vvert_y_period;
    encode_int32 buf v.vvert_u_period;
    encode_int32 buf v.vvert_v_period;
    encode_list encode_uint8 buf v.vcomp_order;
    encode_enum encode_uint8 identity scanline_order_int_of_enum buf
      v.vscanline_order;
    encode_pad buf 11;
    ()

  type bad_port_error = unit [@@deriving sexp]
  type bad_encoding_error = unit [@@deriving sexp]
  type bad_control_error = unit [@@deriving sexp]

  type video_notify_event = {
    reason : video_notify_reason_enum;
    time : Xproto.timestamp;
    drawable : Xproto.drawable;
    port : port;
  }
  [@@deriving sexp]

  let decode_video_notify_event buf ~at : (video_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let* reason, at =
      decode_enum decode_char Char.code video_notify_reason_enum_of_int buf ~at
    in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* drawable, at = Xproto.decode_drawable buf ~at in
    let* port, at = decode_port buf ~at in
    ignore orig;
    Some ({ reason; time; drawable; port }, at)

  type port_notify_event = {
    time : Xproto.timestamp;
    port : port;
    attribute : Xproto.atom;
    value : int;
  }
  [@@deriving sexp]

  let decode_port_notify_event buf ~at : (port_notify_event * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let* _sequence_number, at = decode_uint16 buf ~at in
    let* time, at = Xproto.decode_timestamp buf ~at in
    let* port, at = decode_port buf ~at in
    let* attribute, at = Xproto.decode_atom buf ~at in
    let* value, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ time; port; attribute; value }, at)

  type query_extension_reply = { major : int; minor : int } [@@deriving sexp]

  let encode_query_extension buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_extension_reply length buf ~at :
      (query_extension_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major, at = decode_uint16 buf ~at in
    let* minor, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ major; minor }, at)

  type query_adaptors_reply = adaptor_info list [@@deriving sexp]

  let encode_query_adaptors ~(window : Xproto.window) buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xproto.encode_window buf window;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_adaptors_reply length buf ~at :
      (query_adaptors_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_adaptors, at = decode_uint16 buf ~at in
    let num_adaptors = num_adaptors in
    let at = at + 22 in
    let* info, at = decode_list decode_adaptor_info num_adaptors buf ~at in
    ignore orig;
    Some (info, at)

  type query_encodings_reply = encoding_info list [@@deriving sexp]

  let encode_query_encodings ~(port : port) buf =
    (* opcode *)
    encode_uint8 buf 2;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_encodings_reply length buf ~at :
      (query_encodings_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_encodings, at = decode_uint16 buf ~at in
    let num_encodings = num_encodings in
    let at = at + 22 in
    let* info, at = decode_list decode_encoding_info num_encodings buf ~at in
    ignore orig;
    Some (info, at)

  type grab_port_reply = grab_port_status_enum [@@deriving sexp]

  let encode_grab_port ~(port : port) ~(time : Xproto.time_enum alt_enum) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* write request length *)
    encode_request_length buf

  let decode_grab_port_reply length buf ~at : (grab_port_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let* result, at =
      decode_enum decode_char Char.code grab_port_status_enum_of_int buf ~at
    in
    let at = at + 6 in
    ignore orig;
    Some (result, at)

  let encode_ungrab_port ~(port : port) ~(time : Xproto.time_enum alt_enum) buf
      =
    (* opcode *)
    encode_uint8 buf 4;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    encode_alt_enum Xproto.encode_timestamp identity Xproto.time_int_of_enum buf
      time;
    (* write request length *)
    encode_request_length buf

  let encode_put_video ~(port : port) ~(drawable : Xproto.drawable)
      ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int)
      ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)
      buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    Xproto.encode_gcontext buf gc;
    encode_int16 buf vid_x;
    encode_int16 buf vid_y;
    encode_uint16 buf vid_w;
    encode_uint16 buf vid_h;
    encode_int16 buf drw_x;
    encode_int16 buf drw_y;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    (* write request length *)
    encode_request_length buf

  let encode_put_still ~(port : port) ~(drawable : Xproto.drawable)
      ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int)
      ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)
      buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    Xproto.encode_gcontext buf gc;
    encode_int16 buf vid_x;
    encode_int16 buf vid_y;
    encode_uint16 buf vid_w;
    encode_uint16 buf vid_h;
    encode_int16 buf drw_x;
    encode_int16 buf drw_y;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    (* write request length *)
    encode_request_length buf

  let encode_get_video ~(port : port) ~(drawable : Xproto.drawable)
      ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int)
      ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)
      buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    Xproto.encode_gcontext buf gc;
    encode_int16 buf vid_x;
    encode_int16 buf vid_y;
    encode_uint16 buf vid_w;
    encode_uint16 buf vid_h;
    encode_int16 buf drw_x;
    encode_int16 buf drw_y;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    (* write request length *)
    encode_request_length buf

  let encode_get_still ~(port : port) ~(drawable : Xproto.drawable)
      ~(gc : Xproto.gcontext) ~(vid_x : int) ~(vid_y : int) ~(vid_w : int)
      ~(vid_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int) ~(drw_h : int)
      buf =
    (* opcode *)
    encode_uint8 buf 8;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    Xproto.encode_gcontext buf gc;
    encode_int16 buf vid_x;
    encode_int16 buf vid_y;
    encode_uint16 buf vid_w;
    encode_uint16 buf vid_h;
    encode_int16 buf drw_x;
    encode_int16 buf drw_y;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    (* write request length *)
    encode_request_length buf

  let encode_stop_video ~(port : port) ~(drawable : Xproto.drawable) buf =
    (* opcode *)
    encode_uint8 buf 9;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    (* write request length *)
    encode_request_length buf

  let encode_select_video_notify ~(drawable : Xproto.drawable) ~(onoff : bool)
      buf =
    (* opcode *)
    encode_uint8 buf 10;
    Xproto.encode_drawable buf drawable;
    (* reserve request length *)
    encode_pad buf 2;
    encode_bool buf onoff;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let encode_select_port_notify ~(port : port) ~(onoff : bool) buf =
    (* opcode *)
    encode_uint8 buf 11;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    encode_bool buf onoff;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  type query_best_size_reply = { actual_width : int; actual_height : int }
  [@@deriving sexp]

  let encode_query_best_size ~(port : port) ~(vid_w : int) ~(vid_h : int)
      ~(drw_w : int) ~(drw_h : int) ~(motion : bool) buf =
    (* opcode *)
    encode_uint8 buf 12;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    encode_uint16 buf vid_w;
    encode_uint16 buf vid_h;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    encode_bool buf motion;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_best_size_reply length buf ~at :
      (query_best_size_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* actual_width, at = decode_uint16 buf ~at in
    let* actual_height, at = decode_uint16 buf ~at in
    ignore orig;
    Some ({ actual_width; actual_height }, at)

  let encode_set_port_attribute ~(port : port) ~(attribute : Xproto.atom)
      ~(value : int) buf =
    (* opcode *)
    encode_uint8 buf 13;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf attribute;
    encode_int32 buf value;
    (* write request length *)
    encode_request_length buf

  type get_port_attribute_reply = int [@@deriving sexp]

  let encode_get_port_attribute ~(port : port) ~(attribute : Xproto.atom) buf =
    (* opcode *)
    encode_uint8 buf 14;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_atom buf attribute;
    (* write request length *)
    encode_request_length buf

  let decode_get_port_attribute_reply length buf ~at :
      (get_port_attribute_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* value, at = decode_int32 buf ~at in
    ignore orig;
    Some (value, at)

  type query_port_attributes_reply = {
    text_size : int;
    attributes : attribute_info list;
  }
  [@@deriving sexp]

  let encode_query_port_attributes ~(port : port) buf =
    (* opcode *)
    encode_uint8 buf 15;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_query_port_attributes_reply length buf ~at :
      (query_port_attributes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_attributes, at = decode_int32 buf ~at in
    let num_attributes = num_attributes in
    let* text_size, at = decode_int32 buf ~at in
    let at = at + 16 in
    let* attributes, at =
      decode_list decode_attribute_info num_attributes buf ~at
    in
    ignore orig;
    Some ({ text_size; attributes }, at)

  type list_image_formats_reply = image_format_info list [@@deriving sexp]

  let encode_list_image_formats ~(port : port) buf =
    (* opcode *)
    encode_uint8 buf 16;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_list_image_formats_reply length buf ~at :
      (list_image_formats_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_formats, at = decode_int32 buf ~at in
    let num_formats = num_formats in
    let at = at + 20 in
    let* format, at =
      decode_list decode_image_format_info num_formats buf ~at
    in
    ignore orig;
    Some (format, at)

  type query_image_attributes_reply = {
    data_size : int;
    width : int;
    height : int;
    pitches : int list;
    offsets : int list;
  }
  [@@deriving sexp]

  let encode_query_image_attributes ~(port : port) ~(id : int) ~(width : int)
      ~(height : int) buf =
    (* opcode *)
    encode_uint8 buf 17;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    encode_int32 buf id;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let decode_query_image_attributes_reply length buf ~at :
      (query_image_attributes_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num_planes, at = decode_int32 buf ~at in
    let num_planes = num_planes in
    let* data_size, at = decode_int32 buf ~at in
    let* width, at = decode_uint16 buf ~at in
    let* height, at = decode_uint16 buf ~at in
    let at = at + 12 in
    let* pitches, at = decode_list decode_int32 num_planes buf ~at in
    let* offsets, at = decode_list decode_int32 num_planes buf ~at in
    ignore orig;
    Some ({ data_size; width; height; pitches; offsets }, at)

  let encode_put_image ~(port : port) ~(drawable : Xproto.drawable)
      ~(gc : Xproto.gcontext) ~(id : int) ~(src_x : int) ~(src_y : int)
      ~(src_w : int) ~(src_h : int) ~(drw_x : int) ~(drw_y : int) ~(drw_w : int)
      ~(drw_h : int) ~(width : int) ~(height : int) ~(data : int list) buf =
    (* opcode *)
    encode_uint8 buf 18;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    Xproto.encode_gcontext buf gc;
    encode_int32 buf id;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_uint16 buf src_w;
    encode_uint16 buf src_h;
    encode_int16 buf drw_x;
    encode_int16 buf drw_y;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_list encode_uint8 buf data;
    (* write request length *)
    encode_request_length buf

  let encode_shm_put_image ~(port : port) ~(drawable : Xproto.drawable)
      ~(gc : Xproto.gcontext) ~(shmseg : Shm.seg) ~(id : int) ~(offset : int)
      ~(src_x : int) ~(src_y : int) ~(src_w : int) ~(src_h : int) ~(drw_x : int)
      ~(drw_y : int) ~(drw_w : int) ~(drw_h : int) ~(width : int)
      ~(height : int) ~(send_event : int) buf =
    (* opcode *)
    encode_uint8 buf 19;
    encode_port buf port;
    (* reserve request length *)
    encode_pad buf 2;
    Xproto.encode_drawable buf drawable;
    Xproto.encode_gcontext buf gc;
    Shm.encode_seg buf shmseg;
    encode_int32 buf id;
    encode_int32 buf offset;
    encode_int16 buf src_x;
    encode_int16 buf src_y;
    encode_uint16 buf src_w;
    encode_uint16 buf src_h;
    encode_int16 buf drw_x;
    encode_int16 buf drw_y;
    encode_uint16 buf drw_w;
    encode_uint16 buf drw_h;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_uint8 buf send_event;
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf
end

module Xvmc = struct
  [@@@warning "-27"]
  [@@@warning "-11"]

  open Codec
  open X11_types
  open Util
  open Sexplib.Conv

  type context = xid [@@deriving sexp]

  let decode_context = decode_xid
  let encode_context = encode_xid

  type surface = xid [@@deriving sexp]

  let decode_surface = decode_xid
  let encode_surface = encode_xid

  type subpicture = xid [@@deriving sexp]

  let decode_subpicture = decode_xid
  let encode_subpicture = encode_xid

  type surface_info = {
    id : surface;
    chroma_format : int;
    pad0 : int;
    max_width : int;
    max_height : int;
    subpicture_max_width : int;
    subpicture_max_height : int;
    mc_type : int;
    flags : int;
  }
  [@@deriving sexp]

  let decode_surface_info buf ~at : (surface_info * int) option =
    let orig = at in
    let* id, at = decode_surface buf ~at in
    let* chroma_format, at = decode_uint16 buf ~at in
    let* pad0, at = decode_uint16 buf ~at in
    let* max_width, at = decode_uint16 buf ~at in
    let* max_height, at = decode_uint16 buf ~at in
    let* subpicture_max_width, at = decode_uint16 buf ~at in
    let* subpicture_max_height, at = decode_uint16 buf ~at in
    let* mc_type, at = decode_int32 buf ~at in
    let* flags, at = decode_int32 buf ~at in
    ignore orig;
    Some
      ( {
          id;
          chroma_format;
          pad0;
          max_width;
          max_height;
          subpicture_max_width;
          subpicture_max_height;
          mc_type;
          flags;
        },
        at )

  let encode_surface_info buf (v : surface_info) =
    encode_surface buf v.id;
    encode_uint16 buf v.chroma_format;
    encode_uint16 buf v.pad0;
    encode_uint16 buf v.max_width;
    encode_uint16 buf v.max_height;
    encode_uint16 buf v.subpicture_max_width;
    encode_uint16 buf v.subpicture_max_height;
    encode_int32 buf v.mc_type;
    encode_int32 buf v.flags;
    ()

  type query_version_reply = { major : int; minor : int } [@@deriving sexp]

  let encode_query_version buf =
    (* opcode *)
    encode_uint8 buf 0;
    (* reserve request length *)
    encode_pad buf 3;
    (* write request length *)
    encode_request_length buf

  let decode_query_version_reply length buf ~at :
      (query_version_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* major, at = decode_int32 buf ~at in
    let* minor, at = decode_int32 buf ~at in
    ignore orig;
    Some ({ major; minor }, at)

  type list_surface_types_reply = surface_info list [@@deriving sexp]

  let encode_list_surface_types ~(port_id : Xv.port) buf =
    (* opcode *)
    encode_uint8 buf 1;
    Xv.encode_port buf port_id;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  let decode_list_surface_types_reply length buf ~at :
      (list_surface_types_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num, at = decode_int32 buf ~at in
    let num = num in
    let at = at + 20 in
    let* surfaces, at = decode_list decode_surface_info num buf ~at in
    ignore orig;
    Some (surfaces, at)

  type create_context_reply = {
    width_actual : int;
    height_actual : int;
    flags_return : int;
    priv_data : int list;
  }
  [@@deriving sexp]

  let encode_create_context ~(context_id : context) ~(port_id : Xv.port)
      ~(surface_id : surface) ~(width : int) ~(height : int) ~(flags : int) buf
      =
    (* opcode *)
    encode_uint8 buf 2;
    encode_context buf context_id;
    (* reserve request length *)
    encode_pad buf 2;
    Xv.encode_port buf port_id;
    encode_surface buf surface_id;
    encode_uint16 buf width;
    encode_uint16 buf height;
    encode_int32 buf flags;
    (* write request length *)
    encode_request_length buf

  let decode_create_context_reply length buf ~at :
      (create_context_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width_actual, at = decode_uint16 buf ~at in
    let* height_actual, at = decode_uint16 buf ~at in
    let* flags_return, at = decode_int32 buf ~at in
    let at = at + 20 in
    let* priv_data, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some ({ width_actual; height_actual; flags_return; priv_data }, at)

  let encode_destroy_context ~(context_id : context) buf =
    (* opcode *)
    encode_uint8 buf 3;
    encode_context buf context_id;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type create_surface_reply = int list [@@deriving sexp]

  let encode_create_surface ~(surface_id : surface) ~(context_id : context) buf
      =
    (* opcode *)
    encode_uint8 buf 4;
    encode_surface buf surface_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_context buf context_id;
    (* write request length *)
    encode_request_length buf

  let decode_create_surface_reply length buf ~at :
      (create_surface_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let at = at + 24 in
    let* priv_data, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some (priv_data, at)

  let encode_destroy_surface ~(surface_id : surface) buf =
    (* opcode *)
    encode_uint8 buf 5;
    encode_surface buf surface_id;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type create_subpicture_reply = {
    width_actual : int;
    height_actual : int;
    num_palette_entries : int;
    entry_bytes : int;
    component_order : int list;
    priv_data : int list;
  }
  [@@deriving sexp]

  let encode_create_subpicture ~(subpicture_id : subpicture)
      ~(context : context) ~(xvimage_id : int) ~(width : int) ~(height : int)
      buf =
    (* opcode *)
    encode_uint8 buf 6;
    encode_subpicture buf subpicture_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_context buf context;
    encode_int32 buf xvimage_id;
    encode_uint16 buf width;
    encode_uint16 buf height;
    (* write request length *)
    encode_request_length buf

  let decode_create_subpicture_reply length buf ~at :
      (create_subpicture_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* width_actual, at = decode_uint16 buf ~at in
    let* height_actual, at = decode_uint16 buf ~at in
    let* num_palette_entries, at = decode_uint16 buf ~at in
    let* entry_bytes, at = decode_uint16 buf ~at in
    let* component_order, at =
      let length = 4 in
      decode_list decode_uint8 length buf ~at
    in
    let at = at + 12 in
    let* priv_data, at =
      let length = length in
      decode_list decode_int32 length buf ~at
    in
    ignore orig;
    Some
      ( {
          width_actual;
          height_actual;
          num_palette_entries;
          entry_bytes;
          component_order;
          priv_data;
        },
        at )

  let encode_destroy_subpicture ~(subpicture_id : subpicture) buf =
    (* opcode *)
    encode_uint8 buf 7;
    encode_subpicture buf subpicture_id;
    (* reserve request length *)
    encode_pad buf 2;

    (* write request length *)
    encode_request_length buf

  type list_subpicture_types_reply = Xv.image_format_info list [@@deriving sexp]

  let encode_list_subpicture_types ~(port_id : Xv.port) ~(surface_id : surface)
      buf =
    (* opcode *)
    encode_uint8 buf 8;
    Xv.encode_port buf port_id;
    (* reserve request length *)
    encode_pad buf 2;
    encode_surface buf surface_id;
    (* write request length *)
    encode_request_length buf

  let decode_list_subpicture_types_reply length buf ~at :
      (list_subpicture_types_reply * int) option =
    let orig = at in
    let at = at + 1 in
    let at = at + 1 in
    let at = at + 6 in
    let* num, at = decode_int32 buf ~at in
    let num = num in
    let at = at + 20 in
    let* types, at = decode_list Xv.decode_image_format_info num buf ~at in
    ignore orig;
    Some (types, at)
end
